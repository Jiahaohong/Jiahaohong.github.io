<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darcy&#39;s Blog</title>
  
  <subtitle>Shy first Intimate last Friendly forever!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://39.106.115.216/"/>
  <updated>2020-03-02T09:56:32.814Z</updated>
  <id>http://39.106.115.216/</id>
  
  <author>
    <name>Darcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Data StandardScaler</title>
    <link href="http://39.106.115.216/2020/03/01/Python%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96/"/>
    <id>http://39.106.115.216/2020/03/01/Python%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96/</id>
    <published>2020-03-01T09:06:22.000Z</published>
    <updated>2020-03-02T09:56:32.814Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Before-we-begin-our-discussion-of-how-StandardScaler-works-let’s-simply-talk-about-some-basic-knowleges-of-array-If-you-are-already-familiar-with-the-usage-of-transformation-just-step-over-the-first-block-never-mind"><a href="#Before-we-begin-our-discussion-of-how-StandardScaler-works-let’s-simply-talk-about-some-basic-knowleges-of-array-If-you-are-already-familiar-with-the-usage-of-transformation-just-step-over-the-first-block-never-mind" class="headerlink" title="Before we begin our discussion of how StandardScaler works,let’s simply talk about some basic knowleges of array.If you are already familiar with the usage of transformation, just step over the first block, never mind."></a>Before we begin our discussion of how StandardScaler works,let’s simply talk about some basic knowleges of array.If you are already familiar with the usage of transformation, just step over the first block, never mind.</h4><h2 id="Numpy-Array"><a href="#Numpy-Array" class="headerlink" title="Numpy Array"></a>Numpy Array</h2><p><em>Cause some apparent reason, we do not distinguish array from matrix later</em></p><ul><li><h3 id="How-to-define-an-array"><a href="#How-to-define-an-array" class="headerlink" title="How to define an array"></a>How to define an array</h3><p>  Let’s see the code first:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = (<span class="string">'1,2,3;4,5,6;7,8,9;10,11,12'</span>)</span><br></pre></td></tr></table></figure><p>  if you print the array <em>A</em> on the screen,and you will see the following output:  </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(A)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>  It’s quite clear that the elements in the same row are wrapped in one bracket,and all rows are also wrapped in a brackets. So a bracket is a dimention.  </p><p>  Now let’s look back on the definition.The array content is write in a parenthese, and array elements are in quotes marks.The elements forming the same row are seperated by comma,and different rows are seperated by semicolon.<br>  You can also define an array like this:  </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p>  Please don’t forget the bracket between the rows and parenthese!</p></li><li><h3 id="How-to-transform-the-shape-of-an-array"><a href="#How-to-transform-the-shape-of-an-array" class="headerlink" title="How to transform the shape of an array"></a>How to transform the shape of an array</h3><p>  In many situatons, we need to transform the data form to adjust different tasks.Such as change the time string from “3/1/2020” to “2020-3-1”.So as array.Numpy provides us a tool to transform the shape of an array,let’s see how it works.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(A) <span class="comment">#The same array as before</span></span><br><span class="line">print(A.reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>  And you will get the following output:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>  See,quite simple!The function “reshape” transforms the 4x3 array to a 3x4 array.That how it works.<br>  And if the current array cannot be transformed,it will show you a big red ERROR.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(A.reshape(<span class="number">4</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ValueError: cannot reshape array of size <span class="number">12</span> into shape (<span class="number">4</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>OK,all above is what I want to talk about the array in numpy.And next we will talk about StandardScaler.</p></li></ul><h2 id="StandardScaler-Principle"><a href="#StandardScaler-Principle" class="headerlink" title="StandardScaler Principle"></a>StandardScaler Principle</h2><p>In fact,we need a whole probability theory to figure out how to standerdscale.But I don’t want to complicate matters here. So I give out the formula straightforward.<br>$$<br>x_{i}^<em>=\frac{x_{i}-\mu}{\sigma}<br>$$<br>In the formula,$x_{i}$ is the ith element’s original value, and $\mu$ is the average of all elements’ value, and $\sigma$ is the standard devation of all elements,and $x_{i}^</em>$ is the ith elements’ value after standardscaling. After this magic transformation,you get a brand new sample that all elements it contains are standardscaled!  </p><p>But why we need to do something that seems not necessary?In a word,standardscaler has benifit to araise the posibility of getting a solution and improve solving speed.And in some learning method it is essential.I don’t really want to talk too much here.It’s not the main topic today.</p><h2 id="StandardScaler-in-Numpy"><a href="#StandardScaler-in-Numpy" class="headerlink" title="StandardScaler in Numpy"></a>StandardScaler in Numpy</h2><ul><li><h3 id="np-mean-array-axis"><a href="#np-mean-array-axis" class="headerlink" title="np.mean(array, axis)"></a>np.mean(array, axis)</h3><p>  The function of this API is obvious,but we still have to discuss the second parameter.It’s a fantastic param.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#suppose we have an array like this:</span></span><br><span class="line">A = np.array([[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]],[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]],[[<span class="number">1</span>,<span class="number">1</span>][<span class="number">2</span>,<span class="number">2</span>]]])</span><br><span class="line"><span class="comment">#emmmm,it's quite difficult to see clearly,let's print it</span></span><br><span class="line">print(A)</span><br><span class="line"><span class="comment">#we got this:</span></span><br><span class="line">[[[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">  [<span class="number">2</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">  [<span class="number">2</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">  [<span class="number">2</span> <span class="number">2</span>]]]</span><br><span class="line"><span class="comment">#that means in the zero dimention,there are three elements,and each of them is a structure of two dimention.You can image a cube in the space: it has three layers, and each layer is a rectangal consisted of four blocks,and each block contains a number.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#let's try to "mean" it and see what we will get.</span></span><br><span class="line">print(np.mean(A,axis=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span>]]</span><br><span class="line"><span class="comment">#it seems the original array has been cut in half?all [x,x] structures transform into x?let's go on the experiment.</span></span><br><span class="line">print(np.mean(A,axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">[[<span class="number">1.5</span> <span class="number">1.5</span>]</span><br><span class="line"> [<span class="number">1.5</span> <span class="number">1.5</span>]</span><br><span class="line"> [<span class="number">1.5</span> <span class="number">1.5</span>]]</span><br><span class="line"><span class="comment">#1.5 is just the mean between 1 and 2!does it combine all the [1,1] and [2,2] in the same dimention?if it really behaves like this,then we can predict that the param axis means which dimention will be compressed.</span></span><br><span class="line"><span class="comment">#as we have a three dimention array,</span></span><br><span class="line"><span class="comment">#"axis=2" stands for combining the elements in the least level of bracket--"x and x"--into a number x,</span></span><br><span class="line"><span class="comment">#"axis=1" stands for combining the elements in the second level of bracket--"[1,1] and [2,2]"--into a 1 dimention array [1.5,1.5],</span></span><br><span class="line"><span class="comment">#so "axis=0" stands for combining the elements in the highest level of bracket--"[[1,1],[2,2]] and [[1,1],[2,2]]"--into a 2 dimention array [[1,1],[2,2]]!let's continue.</span></span><br><span class="line">print(np.mean(A,axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">2</span>]]</span><br><span class="line"><span class="comment">#Exactly!</span></span><br></pre></td></tr></table></figure><p>  Let’s make a conclusion here:<br>  The value of axis means which dimention will be compressed into 1 element.</p></li><li><h3 id="np-std-array-axis"><a href="#np-std-array-axis" class="headerlink" title="np.std(array, axis)"></a>np.std(array, axis)</h3><p>  As we have the discussion before, we can be much easy here.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(np.std(A,axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>  The same conclusion as before!</p></li><li><h3 id="Standardscale"><a href="#Standardscale" class="headerlink" title="Standardscale"></a>Standardscale</h3><p>  Using the formula and API given before,we can get standardscale datas like this:  </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get an array with two dimentions,and the first dimention has two elements, the second dimention has three elements.And we will conbine the first dimention next.</span></span><br><span class="line">a = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],[<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"><span class="comment">#get the average</span></span><br><span class="line">a_mean = np.mean(a,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#get the stardard devation</span></span><br><span class="line">a_std = np.std(a,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#using the formula</span></span><br><span class="line">a_ = (a - a_mean)/a_std</span><br><span class="line"><span class="comment">#print the result</span></span><br><span class="line">print(a)</span><br><span class="line">print(a_mean)</span><br><span class="line">print(a_std)</span><br><span class="line">print(a_)</span><br><span class="line"></span><br><span class="line">[<span class="number">2.5</span> <span class="number">3.5</span> <span class="number">4.5</span>]</span><br><span class="line">[<span class="number">1.5</span> <span class="number">1.5</span> <span class="number">1.5</span>]</span><br><span class="line">[[<span class="number">-1.</span> <span class="number">-1.</span> <span class="number">-1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>  You may feel stange that: why the result are all 1 and -1?Maybe it is related to the data dimention or element number?<br>  First,let’s raise the dimention.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define an array with three dimentions and each dimention contains two elements.</span></span><br><span class="line">b = np.array([[[<span class="number">1.</span>,<span class="number">2.</span>],[<span class="number">2.</span>,<span class="number">3.</span>]],[[<span class="number">3.</span>,<span class="number">4.</span>],[<span class="number">5.</span>,<span class="number">6.</span>]]])</span><br><span class="line"><span class="comment">#the same operation as before......</span></span><br><span class="line"><span class="comment">#and we got this:</span></span><br><span class="line">[[<span class="number">2.</span>  <span class="number">3.</span> ]</span><br><span class="line"> [<span class="number">3.5</span> <span class="number">4.5</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">1.</span>  <span class="number">1.</span> ]</span><br><span class="line"> [<span class="number">1.5</span> <span class="number">1.5</span>]]</span><br><span class="line"></span><br><span class="line">[[[<span class="number">-1.</span> <span class="number">-1.</span>]</span><br><span class="line">  [<span class="number">-1.</span> <span class="number">-1.</span>]]</span><br><span class="line"> [[ <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line">  [ <span class="number">1.</span>  <span class="number">1.</span>]]] </span><br><span class="line"> ```  </span><br><span class="line">Emmmm....-1or1?It seems has nothing to do with dimention.Let's try to add the elements number.</span><br><span class="line">```python</span><br><span class="line"><span class="comment">#this time the array is similar to the first one,and the only difference is it has three elements in the first dimention.</span></span><br><span class="line">c = np.array([<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],[<span class="number">3.</span>,<span class="number">4.</span>,<span class="number">5.</span>],[<span class="number">5.</span>,<span class="number">6.</span>,<span class="number">7.</span>])</span><br><span class="line"><span class="comment">#all the same...</span></span><br><span class="line">[<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line">[<span class="number">1.63299316</span> <span class="number">1.63299316</span> <span class="number">1.63299316</span>]</span><br><span class="line">[[<span class="number">-1.22474487</span> <span class="number">-1.22474487</span> <span class="number">-1.22474487</span>]</span><br><span class="line"> [ <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.</span>        ]</span><br><span class="line"> [ <span class="number">1.22474487</span>  <span class="number">1.22474487</span>  <span class="number">1.22474487</span>]]</span><br></pre></td></tr></table></figure><p>  Something different happeded!This time we combine three elements and the result are totally different!Although the result seem much a mass,but it is not so coincident as the first one.</p></li></ul><p>OK,all above is today’s talk.If you find something I am wrong,please point out and tell me,and I will be appriciate about that.Thanks! </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Before-we-begin-our-discussion-of-how-StandardScaler-works-let’s-simply-talk-about-some-basic-knowleges-of-array-If-you-are-already-
      
    
    </summary>
    
    
    
      <category term="Python" scheme="http://39.106.115.216/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：数据分配器</title>
    <link href="http://39.106.115.216/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://39.106.115.216/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/</id>
    <published>2020-02-14T02:07:15.000Z</published>
    <updated>2020-02-14T03:47:16.631Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="什么是数据分配器"><a href="#什么是数据分配器" class="headerlink" title="什么是数据分配器"></a>什么是数据分配器</h3><p>  将公共输入信号分配到不同通道上的逻辑电路。</p></li><li><h3 id="用译码器实现数据分配器"><a href="#用译码器实现数据分配器" class="headerlink" title="用译码器实现数据分配器"></a>用译码器实现数据分配器</h3><p>  现在之前说到过的译码器多使能端派上用场了。   </p><ul><li>先简单说说使能端E2和E1的特性，当总使能端E3有效时（高电平），E2和E1中任何一个接收到无效信号（低电平）都会使所有输出端输出无效信号（低电平）。  </li><li>再来看看各输出端的逻辑函数：<br>Y5 = E3 · E2 · E1 · A3 · <span style="text-decoration:overline">A2</span> · A1 =  E3 · E2 · E1 · m5  </li><li>其余端口由5号端口同理得出，通式如下：<br>Yi = E3 · E2 · E1 · mi  </li><li>现在设计使能端。将总使能端E3保持有效，E2也保持有效，E1通入要分配的信号D。那么，当信号D为高电平时，E1有效，有且仅有mi所对应的那一路输出端输出高电平（其余输出端为低电平，参看译码器真值表）；当信号D为低电平时，E1无效，所有输出端输出低电平，包括mi所对应的那一路输出端。这样就保证了mi对应的那一路输出端高低电平与输入信号D保持一致，而其他输出端一直为低电平。</li><li>两个译码器可以组成更多路输出的译码器，这种组合译码器用上述方法也同样可以做成更多路的数据分配器。</li></ul></li><li><h3 id="用逻辑门实现数据分配器"><a href="#用逻辑门实现数据分配器" class="headerlink" title="用逻辑门实现数据分配器"></a>用逻辑门实现数据分配器</h3><ul><li>先来介绍三态门。三态门有一个输入端，一个输出端，和一个使能端，当使能端有效时，三态门输出和输入相同；当使能端无效时，三态门输出为高阻态。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是数据分配器&quot;&gt;&lt;a href=&quot;#什么是数据分配器&quot; class=&quot;headerlink&quot; title=&quot;什么是数据分配器&quot;&gt;&lt;/a&gt;什么是数据分配器&lt;/h3&gt;&lt;p&gt;  将公共输入信号分配到不同通道上的逻辑电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：译码器</title>
    <link href="http://39.106.115.216/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/"/>
    <id>http://39.106.115.216/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/</id>
    <published>2020-02-13T01:50:37.000Z</published>
    <updated>2020-02-14T03:10:49.938Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="译码器的原理"><a href="#译码器的原理" class="headerlink" title="译码器的原理"></a>译码器的原理</h3><ol><li><p>2线-4线译码器<br> 先看看这种译码器的真值表： </p><table><thead><tr><th align="center">E</th><th align="center">A1</th><th align="center">A0</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td></tr></tbody></table><p> 在使能端有效的情况下，我们可以写出各个输出端的逻辑表达式，如下：<br> Y0 = <span style="text-decoration:overline">A1</span> · <span style="text-decoration:overline">A0</span><br> Y1 = <span style="text-decoration:overline">A1</span> · A0<br> Y2 = A1 · <span style="text-decoration:overline">A0</span><br> Y3 = A1 · A0<br> 不难发现，每个输出端的逻辑表达式都是输入逻辑变量的最小项。如果将使能端也考虑进去，将上述每一个输出端的逻辑表达式和使能端逻辑变量相与即可。  </p></li><li><p>3线-4线译码器<br> 先看看这种译码器的使能端的真值表：    </p><table><thead><tr><th align="center">E3</th><th align="center">E2</th><th align="center">E1</th><th align="center">A3</th><th align="center">A2</th><th align="center">A1</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th><th align="center">Y4</th><th align="center">Y5</th><th align="center">Y6</th><th align="center">Y7</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">X</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p> 可以看出，这三个使能端中E3优先级最高，是总开关，E2和E1的功能是一样的，但是怎么用呢？</p></li></ol></li><li><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><ol><li>为什么2线-4线译码器74HC139的逻辑符号中，使能端和输出端要各自连接一个非门？</li><li>为什么3线-8线译码器74HC138需要三个使能端？</li><li>如何使用74HC138和少量逻辑门实现三变量逻辑函数？</li></ol></li><li><h3 id="关于译码器连接非门的问题"><a href="#关于译码器连接非门的问题" class="headerlink" title="关于译码器连接非门的问题"></a>关于译码器连接非门的问题</h3><p>  虽然说逻辑函数可以使用与或非三种逻辑门来实现，但是，通常情况下这些逻辑门都不是结构上最简单的。实际上与非门的结构最为简单，并且可以由与非门完成其他基本逻辑们的功能。因此，逻辑电路可能会有一些非门在输入输出端。</p></li><li><h3 id="关于译码器的多使能端的问题"><a href="#关于译码器的多使能端的问题" class="headerlink" title="关于译码器的多使能端的问题"></a>关于译码器的多使能端的问题</h3><p>  多个使能端可以拓展译码器的功能，比如之后的数据分配器和数据选择器等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;译码器的原理&quot;&gt;&lt;a href=&quot;#译码器的原理&quot; class=&quot;headerlink&quot; title=&quot;译码器的原理&quot;&gt;&lt;/a&gt;译码器的原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;2线-4线译码器&lt;br&gt; 先看看这种译码器的真值表： &lt;/p&gt;
&lt;tab
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：编码器</title>
    <link href="http://39.106.115.216/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://39.106.115.216/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/</id>
    <published>2020-02-11T08:20:07.000Z</published>
    <updated>2020-03-02T08:35:33.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是编码，什么是编码器"><a href="#什么是编码，什么是编码器" class="headerlink" title="什么是编码，什么是编码器"></a>什么是编码，什么是编码器</h2><p>编码就是<strong>赋予二进制代码特殊含义</strong>的过程。 </p><p>编码器就是实现编码功能的逻辑电路。 </p><p>举个栗子：  </p><blockquote><p>当你被困在监狱，给你探监的联络员给你传递情报，你们事先（抓进监狱前）约定将三个苹果和一个栗子按苹果、苹果、栗子、苹果的顺序摆放时，表示时机成熟，今晚有人接应，如果按栗子、苹果、苹果、苹果的顺序摆放时，表示时机不成熟，那么你就可以从联络员送来的物品摆放顺序中获得情报。而“事先约定”就是“编码”。<br>同样的，逻辑电路也可以实现这样的功能。比如四个输入信号为0010时，表示11；输入信号为1000时表示00。这也是一种编码，只不过编码后的输出也是二进制。</p></blockquote><h2 id="普通编码器"><a href="#普通编码器" class="headerlink" title="普通编码器"></a>普通编码器</h2><p><em>任何时候<strong>只允许一个信号输入有效</strong>的编码器称为普通编码器。</em> </p><ul><li><h3 id="普通编码器的名称含义"><a href="#普通编码器的名称含义" class="headerlink" title="普通编码器的名称含义"></a>普通编码器的名称含义</h3><p>  如果输入信号有4个，那么输出信号只需要2个就可以表示输入信号的4种状态。这就是4线2线普通编码器。也就是说，普通编码器如果有2^n个输入信号，那么它只需要n个输出信号就可以表达输入信号的所有状态。 </p></li><li><h3 id="普通编码器的真值表"><a href="#普通编码器的真值表" class="headerlink" title="普通编码器的真值表"></a>普通编码器的真值表</h3><table><thead><tr><th align="center">I0</th><th align="center">I1</th><th align="center">I2</th><th align="center">I3</th><th align="center">Y0</th><th align="center">Y1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  从上面4线2线普通编码器的真值表或卡诺图（Q1卡诺图是怎样的呢？）得到普通编码器的逻辑表达式如下：<br>  Y0 = I2 + I3<br>  Y1 = I1 + I3   </p></li><li><h3 id="普通编码器的编码重叠问题"><a href="#普通编码器的编码重叠问题" class="headerlink" title="普通编码器的编码重叠问题"></a>普通编码器的编码重叠问题</h3><p>  结合真值表和逻辑表达式可知，普通编码器只有在<strong>有且仅有一个输入信号</strong>有效时才能正常工作，否则将会出现<strong>编码重叠</strong>的问题。比如，四个信号为0101时，也会产生11的输出，这样的话编码器之后的电路就会将0101误认为0001。由于在实际问题中，精准控制所有输入信号满足要求是十分困难的，而且这种编码重叠会造成后续电路的故障，所以为了解决编码重叠的问题，电器工程师们又发明了优先编码器。</p></li></ul><h2 id="优先编码器"><a href="#优先编码器" class="headerlink" title="优先编码器"></a>优先编码器</h2><p><em>事先规定好<strong>信号的优先级</strong>的编码器称为优先编码器。</em>  </p><ul><li><h3 id="优先编码器的“优先”"><a href="#优先编码器的“优先”" class="headerlink" title="优先编码器的“优先”"></a>优先编码器的“优先”</h3><p>  看到这你可能会问，什么是信号优先级？怎么规定信号优先级呢？我们先举个栗子解释一下信号优先级：  </p><blockquote><p>一名士兵在执行任务时，收到了两条来自上级的命令，一条是班长的，说开始执行任务，另一条是连长的，说任务终止。这时候，由于连长军衔高，他的命令就被士兵执行了，而班长的命令就被忽略了。<br>同样的，优先编码器在接收到的所有信号中，有多个信号有效时，它会选择级别高的信号进行编码，而优先级低的信号就不执行编码。</p></blockquote><p>  那么怎么实现信号优先级的设置？或者说编码器怎么识别出信号的优先级的呢？这就要知道优先编码器的真值表是怎么设计的了。</p></li><li><h3 id="优先编码器的真值表"><a href="#优先编码器的真值表" class="headerlink" title="优先编码器的真值表"></a>优先编码器的真值表</h3><table><thead><tr><th align="center">I0</th><th align="center">I1</th><th align="center">I2</th><th align="center">I3</th><th align="center">Y0</th><th align="center">Y1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">x</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">1</td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  和普通编码器的真值表对照一下就可以发现，优先编码器的有些输入信号为有效时，不论其他信号是否有效，输出结果总是一样的，这种不会被其他信号干扰其输出的信号就叫做高优先级信号，而输出会被其他信号干扰的信号叫做低优先级信号。前面的高低优先级都是相对概念。（Q2你能看出这个编码器输入信号的优先级吗？）  </p><p>  同样的，分别根据Y0和Y1的卡诺图可以求出它们的逻辑表达式，如下：<br>  Y0 = I2 + I3<br>  Y1 = I1 · <span style="text-decoration:overline">I2</span> + I3  </p><p>  从逻辑表达式可以知道，优先编码器并不是具有什么智慧才能够分辨不同的输入信号，“优先级”实际上是逻辑门的组合而产生的效果。接下来我们使用简单的logism软件来设计一下4线2线优先编码器。</p></li><li><h3 id="Logism之优先编码器"><a href="#Logism之优先编码器" class="headerlink" title="Logism之优先编码器"></a>Logism之优先编码器</h3><p>  分析逻辑表达式，有四个输入端和两个输出端，一个非门、一个与门和两个或门，组装后结果如下：  </p>  <img src="/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism1.jpg"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是编码，什么是编码器&quot;&gt;&lt;a href=&quot;#什么是编码，什么是编码器&quot; class=&quot;headerlink&quot; title=&quot;什么是编码，什么是编码器&quot;&gt;&lt;/a&gt;什么是编码，什么是编码器&lt;/h2&gt;&lt;p&gt;编码就是&lt;strong&gt;赋予二进制代码特殊含义&lt;/stron
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：卡诺图（2）</title>
    <link href="http://39.106.115.216/2020/02/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%882%EF%BC%89/"/>
    <id>http://39.106.115.216/2020/02/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%882%EF%BC%89/</id>
    <published>2020-02-09T08:53:34.000Z</published>
    <updated>2020-02-11T03:55:58.894Z</updated>
    
    <content type="html"><![CDATA[<p><em>由上篇blog知道，卡诺图是一个将最小项按二维格雷码的形式排布的表格，每个格子对应着一个最小项，那么卡诺图怎么使用呢？</em></p><ul><li><h3 id="什么是逻辑函数的卡诺图"><a href="#什么是逻辑函数的卡诺图" class="headerlink" title="什么是逻辑函数的卡诺图"></a>什么是逻辑函数的卡诺图</h3><p>  逻辑函数的卡诺图每一个格子不仅对应着一个最小项了，若该格子为1，表示这个格子对应的最小项在逻辑函数中出现，反之若该格子为0，表示该格子对应的最小项在逻辑函数中没有出现。将逻辑函数的每一个最小项对应填到同变量数的卡诺图中，这个卡诺图就是该逻辑函数的卡诺图。</p></li><li><h3 id="如何获得逻辑函数的卡诺图"><a href="#如何获得逻辑函数的卡诺图" class="headerlink" title="如何获得逻辑函数的卡诺图"></a>如何获得逻辑函数的卡诺图</h3><p>  首先将逻辑函数化成与或表达式，然后通过重叠律（A+<span style="text-decoration:overline">A</span>=1）将表达式中每一个乘积项（与项）增补成最小项，然后画出卡诺图，最后在卡诺图中找到逻辑函数每一个最小项对应的格子，将改格子写为1，其余格子全写0。</p></li><li><h3 id="逻辑函数的卡诺图如何化简"><a href="#逻辑函数的卡诺图如何化简" class="headerlink" title="逻辑函数的卡诺图如何化简"></a>逻辑函数的卡诺图如何化简</h3><ul><li>先看看哪里数字1多，然后画圈圈把他们围住，注意，这些圈圈不能随便画，有以下几点原则:</li></ul><ol><li>圈圈中包围的数字1的个数必须为2的整数幂，即1、2、4、8个等等。</li><li>圈圈中包围的数字只能是1，且圈圈围住的方格组合起来必须是矩形，即1x1、1x2、2x2、2x4的大小等等。</li><li>圈圈个数尽可能少（因为每个圈圈最后就是一个乘积项，圈圈越少结果越简单），每个圈圈包围的数字1尽可能多。</li><li>不同的圈圈<strong>可以重复包围</strong>同一个数字1（这一点初学容易忽视）。</li><li>如果一个圈圈中所有的数字1都已经被其他圈圈围住了，那么这个圈圈就是多余的，可以省去（这一点消除竞争与冒险时会反过来利用）。</li></ol><ul><li>现在圈圈画完了，开始整理，将每一个圈圈所对应的乘积项写出来（即圈圈中所有最小项相“与”），然后将这些乘积项全部“或”起来，就是化简后的表达式了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;由上篇blog知道，卡诺图是一个将最小项按二维格雷码的形式排布的表格，每个格子对应着一个最小项，那么卡诺图怎么使用呢？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是逻辑函数的卡诺图&quot;&gt;&lt;a href=&quot;#什么是逻辑函数的卡诺图&quot; class=&quot;head
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：卡诺图（1）</title>
    <link href="http://39.106.115.216/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/"/>
    <id>http://39.106.115.216/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/</id>
    <published>2020-02-08T02:49:33.000Z</published>
    <updated>2020-02-11T02:53:02.773Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="什么是卡诺图"><a href="#什么是卡诺图" class="headerlink" title="什么是卡诺图"></a>什么是卡诺图</h3><ul><li>相邻最小项<br>若两个最小项之间仅有一个逻辑变量互为反变量，那么这两个最小项为相邻最小项。例如：m2（<span style="text-decoration:overline">A</span>·B·<span style="text-decoration:overline">C</span>）与m6（A·B·<span style="text-decoration:overline">C</span>）仅有逻辑变量A不同，因此m2与m6互为相邻最小项。</li><li>卡诺图<br>由一个个小方格组成，每个小方格代表一种最小项。几何位置上相邻的格子代表相邻最小项。  </li></ul></li><li><h3 id="如何构造卡诺图"><a href="#如何构造卡诺图" class="headerlink" title="如何构造卡诺图"></a>如何构造卡诺图</h3><p>  <em>这里将构造卡诺图只是将卡诺图的形式构造出来，只表示最小项之间的几何位置关系，与之后要讲的“逻辑函数的卡诺图”有区别。</em></p><p>  <em>其实卡诺图没有固定的画法，比如两变量的卡诺图可以画成一行，也可以画成两行两列，但为了方便，之后的卡诺图都是如下画法。</em></p><ul><li>展开折叠法  <img src="/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/两变量卡诺图.png" width="200px"><img src="/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/三变量卡诺图.png" width="200px"><img src="/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/四变量卡诺图.png" width="200px">  </li></ul><ol><li>先记住两变量卡诺图，假设两逻辑变量分别为C和D，列号从左至右依次为00、01、11、10，最小项就是列号；</li><li>将两变量卡诺图沿着水平线对称翻折到下方，变成两行，第一行对应第三个逻辑变量B的反变量，行号为0，第二行对应第三个逻辑变量B的原变量，行号为1；</li><li>同理，将三变量卡诺图沿着水平线对称翻折到下方，变成四行，一二行对应第四个逻辑变量A的反变量，行号依次为00和01，三四行对应第四个逻辑变量A的原变量，行号依次为11和10。</li></ol></li><li><h3 id="卡诺图的特点"><a href="#卡诺图的特点" class="headerlink" title="卡诺图的特点"></a>卡诺图的特点</h3><ol><li>由上述卡诺图的构造方法，可以将卡诺图理解成<strong>二维的格雷码</strong>，因为他们的构造方法十分相似，只是格雷码只能在一个方向上反复对称翻折构造，而卡诺图可以在两个方向上对称翻折构造。</li><li>基于1的理解，不难发现卡诺图的两个维度标号都是格雷码，但是这里的格雷码的0和1有着明确的含义，即逻辑变量的反变量和原变量。这样就可以轻松的画出卡诺图，也可以由卡诺图轻松的获得每一个各自对应的最小项（自行理解）。</li><li>如果将最小项的标号（格雷码）转换成二进制码，可以发现这些二进制码按照从小到大的顺序S行排列，即从左上角开始，第一行从左向右递增，第二行从右向左递增，以此类推。这为从真值表到卡诺图的转换提供了方便（自行理解）。</li><li>卡诺图最左边的格子和最右边的格子、最下面的格子和最上面的格子也是几何相邻的格子。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是卡诺图&quot;&gt;&lt;a href=&quot;#什么是卡诺图&quot; class=&quot;headerlink&quot; title=&quot;什么是卡诺图&quot;&gt;&lt;/a&gt;什么是卡诺图&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;相邻最小项&lt;br&gt;若两个最小项之间仅有一个逻辑变量互为反变量，那么这两个最小项
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：逻辑代数基本定理</title>
    <link href="http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/"/>
    <id>http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/</id>
    <published>2020-02-07T02:48:54.000Z</published>
    <updated>2020-02-08T07:59:52.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑代数基本定律"><a href="#逻辑代数基本定律" class="headerlink" title="逻辑代数基本定律"></a>逻辑代数基本定律</h2><ul><li>0、1律</li><li>重叠律</li><li>互补律</li><li>还原律</li><li>交换律</li><li>结合律</li><li><strong><em>分配律</em></strong><ul><li>A·（B + C）= A · B + A · C</li><li><strong>A + B · C = （A + B）·（A + C）</strong></li></ul></li><li><strong><em>反演律</em></strong>（摩根定理）<ul><li><span style="text-decoration:overline">A·B·C</span> = <span style="text-decoration:overline">A</span> + <span style="text-decoration:overline">B</span> + <span style="text-decoration:overline">C</span></li><li><span style="text-decoration:overline">A+B+C</span> = <span style="text-decoration:overline">A</span> · <span style="text-decoration:overline">B</span> · <span style="text-decoration:overline">C</span></li></ul></li></ul><h2 id="逻辑代数基本公式"><a href="#逻辑代数基本公式" class="headerlink" title="逻辑代数基本公式"></a>逻辑代数基本公式</h2><ul><li>吸收律  <ul><li>A + A·B = A</li><li>A（A + B） = A</li></ul></li></ul><h2 id="逻辑代数基本规则"><a href="#逻辑代数基本规则" class="headerlink" title="逻辑代数基本规则"></a>逻辑代数基本规则</h2><ul><li>带入规则</li><li>反演规则<br>如果将表达式中与（·）换成或（+）、或（+）换成与（·）、反变量换成原变量、原变量换成反变量、1换成0、0换成1，那么得到的表达式即使原表达式的反演表达式。<br>注意不要改变运算顺序，适当使用小括号保证原表达式的运算顺序。</li><li>对偶规则</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逻辑代数基本定律&quot;&gt;&lt;a href=&quot;#逻辑代数基本定律&quot; class=&quot;headerlink&quot; title=&quot;逻辑代数基本定律&quot;&gt;&lt;/a&gt;逻辑代数基本定律&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;0、1律&lt;/li&gt;
&lt;li&gt;重叠律&lt;/li&gt;
&lt;li&gt;互补律&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：最小项最大项</title>
    <link href="http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%A1%B9%E6%9C%80%E5%A4%A7%E9%A1%B9/"/>
    <id>http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%A1%B9%E6%9C%80%E5%A4%A7%E9%A1%B9/</id>
    <published>2020-02-07T01:35:48.000Z</published>
    <updated>2020-02-08T03:33:00.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小项"><a href="#最小项" class="headerlink" title="最小项"></a>最小项</h2><ul><li><h3 id="什么是最小项？"><a href="#什么是最小项？" class="headerlink" title="什么是最小项？"></a>什么是最小项？</h3><ul><li>现在有N个逻辑变量，若一个乘积项（与项）包含了这N个变量的原变量或非变量，且每种变量只以原变量或非变量的形式出现一次，那么该乘积项称为最小项。例如三个逻辑变量的最小项有如下8种:<br><span style="text-decoration:overline">A</span>·<span style="text-decoration:overline">B</span>·<span style="text-decoration:overline">C</span>、<span style="text-decoration:overline">A</span>·<span style="text-decoration:overline">B</span>·C、<span style="text-decoration:overline">A</span>·B·C、<span style="text-decoration:overline">A</span>·B·<span style="text-decoration:overline">C</span><br>A·B·<span style="text-decoration:overline">C</span>、A·B·C、A·<span style="text-decoration:overline">B</span>·C、A·<span style="text-decoration:overline">B</span>·<span style="text-decoration:overline">C</span>  </li><li>可以看出，每个最小项中，A、B、C分别只出现一次，要么是原变量（A、B、C），要么是反变量（<span style="text-decoration:overline">A</span>、<span style="text-decoration:overline">B</span>、<span style="text-decoration:overline">C</span>）。</li></ul></li><li><h3 id="为什么叫最小项？"><a href="#为什么叫最小项？" class="headerlink" title="为什么叫最小项？"></a>为什么叫最小项？</h3><ul><li>从概率论的角度看，如果每一个逻辑变量代表一个事件，事件发生和不发生的概率都是0.5，那么所有事件的交集（与运算）的发生概率最小，所以叫最小项。  </li><li>也可以将最小项看成是组成其他事件的基本单位，通过最小项的合并（或运算）来实现其他事件。</li></ul></li><li><h3 id="最小项如何编号？"><a href="#最小项如何编号？" class="headerlink" title="最小项如何编号？"></a>最小项如何编号？</h3><ul><li><p>简单的来说，原变量用1表示，反变量用0表示，然后组合起来转换成十进制就是对应最小项的编号。如下表：  </p><table><thead><tr><th align="center">A B C</th><th align="center">编号</th><th align="center">A B C</th><th align="center">编号</th></tr></thead><tbody><tr><td align="center">0 0 0</td><td align="center">m0</td><td align="center">1 0 0</td><td align="center">m4</td></tr><tr><td align="center">0 0 1</td><td align="center">m1</td><td align="center">1 0 1</td><td align="center">m5</td></tr><tr><td align="center">0 1 0</td><td align="center">m2</td><td align="center">1 1 0</td><td align="center">m6</td></tr><tr><td align="center">0 1 1</td><td align="center">m3</td><td align="center">1 1 1</td><td align="center">m7</td></tr></tbody></table></li><li><p>为什么这样编号？因为当与运算中任意一个因子为0时，与运算结果为0，因子取值不具有唯一性；当且仅当与运算中所有因子为1时，与运算结果为1，因子取值具有唯一性。因此当原变量取1反变量取0时，最小项表达式所有因子为1，最小项表达式结果为1。</p></li></ul></li></ul><ul><li><h3 id="什么是最小项表达式？"><a href="#什么是最小项表达式？" class="headerlink" title="什么是最小项表达式？"></a>什么是最小项表达式？</h3><ul><li>基本表达式中与或表达式的一种标准形式，各逻辑变量之间先进行与运算形成最小项，然后各最小项之间进行或运算形成最小项表达式。</li></ul></li><li><h3 id="如何获得最小项表达式？"><a href="#如何获得最小项表达式？" class="headerlink" title="如何获得最小项表达式？"></a>如何获得最小项表达式？</h3><ul><li>常用配项法获得。利用逻辑表达式基本定律（A+<span style="text-decoration:overline">A</span>=1）增加各项中的逻辑变量。</li></ul></li></ul><h2 id="最大项"><a href="#最大项" class="headerlink" title="最大项"></a>最大项</h2><p>最大项与最小项互补，大家自行脑补:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小项&quot;&gt;&lt;a href=&quot;#最小项&quot; class=&quot;headerlink&quot; title=&quot;最小项&quot;&gt;&lt;/a&gt;最小项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是最小项？&quot;&gt;&lt;a href=&quot;#什么是最小项？&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：码制</title>
    <link href="http://39.106.115.216/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/"/>
    <id>http://39.106.115.216/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/</id>
    <published>2020-02-04T07:35:22.000Z</published>
    <updated>2020-02-05T08:46:10.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="码制概念"><a href="#码制概念" class="headerlink" title="码制概念"></a>码制概念</h2><p>码制是用0和1组成的代码表示人类交流的字符的规则。</p><h2 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h2><ul><li>特点：循环码、反射码</li></ul><h2 id="格雷码与二进制码的转换"><a href="#格雷码与二进制码的转换" class="headerlink" title="格雷码与二进制码的转换"></a>格雷码与二进制码的转换</h2><h4 id="二进制码转换为格雷码"><a href="#二进制码转换为格雷码" class="headerlink" title="二进制码转换为格雷码"></a>二进制码转换为格雷码</h4><ul><li>格雷码最高位（最左边）与二进制码最高位相同</li><li>二进制码从左到右，相邻两位相加，作为格雷码的下一位</li></ul><h4 id="格雷码转换为二进制码"><a href="#格雷码转换为二进制码" class="headerlink" title="格雷码转换为二进制码"></a>格雷码转换为二进制码</h4><ul><li>二进制码的最高位（最左边）与格雷码相同</li><li>将产生的二进制码与下一位格雷码相加，作为下一位二进制码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;码制概念&quot;&gt;&lt;a href=&quot;#码制概念&quot; class=&quot;headerlink&quot; title=&quot;码制概念&quot;&gt;&lt;/a&gt;码制概念&lt;/h2&gt;&lt;p&gt;码制是用0和1组成的代码表示人类交流的字符的规则。&lt;/p&gt;
&lt;h2 id=&quot;格雷码&quot;&gt;&lt;a href=&quot;#格雷码&quot; clas
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：补码</title>
    <link href="http://39.106.115.216/2020/02/03/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A1%A5%E7%A0%81/"/>
    <id>http://39.106.115.216/2020/02/03/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A1%A5%E7%A0%81/</id>
    <published>2020-02-03T07:09:40.000Z</published>
    <updated>2020-02-03T14:12:00.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="真值补码对应表"><a href="#真值补码对应表" class="headerlink" title="真值补码对应表"></a>真值补码对应表</h2><p>以8bit数为例</p><table><thead><tr><th align="center">真值-无符号</th><th align="center">补码</th><th align="center">真值-有符号</th><th align="center">补码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0000 0000</td><td align="center">0</td><td align="center">0000 0000</td></tr><tr><td align="center">1</td><td align="center">0000 0001</td><td align="center">1</td><td align="center">0000 0001</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">127</td><td align="center">0111 1111</td><td align="center">127</td><td align="center">0111 1111</td></tr><tr><td align="center">128</td><td align="center">1000 0000</td><td align="center">-128</td><td align="center">1000 0000</td></tr><tr><td align="center">129</td><td align="center">1000 0001</td><td align="center">-127</td><td align="center">1000 0001</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">255</td><td align="center">1111 1111</td><td align="center">-1</td><td align="center">1111 1111</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>可以看出，负数与其绝对值的真值和为0，但是补码和为 1 0000 0000，由于只能存储8bit，故多出的第8号位上的1舍去，余下的0到7号位均为0，对应真值也就是0了。</li><li>为什么-1规定为1111 1111呢？由数学同余概念可知，255对256余-1，所以-1对应255，同理可得其他负数。这样一来，一个数减去1就可以用这个数加上255来表示，只不过计算结果多出的第8位会舍去，剩下的0到7号位表示的就是减法的结果。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;真值补码对应表&quot;&gt;&lt;a href=&quot;#真值补码对应表&quot; class=&quot;headerlink&quot; title=&quot;真值补码对应表&quot;&gt;&lt;/a&gt;真值补码对应表&lt;/h2&gt;&lt;p&gt;以8bit数为例&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;cente
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python语法简介</title>
    <link href="http://39.106.115.216/2020/01/31/Python%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://39.106.115.216/2020/01/31/Python%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</id>
    <published>2020-01-31T08:37:28.000Z</published>
    <updated>2020-03-01T09:46:20.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul><li>范围：无穷  </li><li>表示：十进制、二进制(0b)、十六进制(0x)、八进制(0o)  </li><li>常用函数：pow(x,y)</li><li>函数作用：计算x的y次幂，y为任意整数或浮点数</li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li>范围：近似无穷（有不确定尾数） </li><li>表示：小数点、科学计数法 </li><li>常用函数：round(x[,y])</li><li>函数作用：对x四舍五入，y为截取的小数位数，若省去y则对x取整</li><li>应用场景：判断两个浮点数是否相等</li></ul><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul><li>范围：无穷（数字类型中级别最高，范围最广）  </li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>表示：单引号或双引号括起来的多个字符，对应即可</li><li>操作符：<ul><li>+：将两个字符串连接</li><li>*：将一个字符串复制n次</li></ul></li><li>操作：<ul><li>str.split(x)：将字符串以x为分隔符分割成列表</li><li>x.join(str)：将字符串str的每一个字符后面插入字符串x，str最后一个字符后面不插入</li></ul></li></ul><h2 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>定义：s = set(…)或s = {…}<ul><li>注意：要生成空集合只能使用set方法，空大括号默认生成空字典</li></ul></li><li>操作符：<ul><li>A|B：并</li><li>A-B：差</li><li>A&amp;B：交</li><li>A^B：补</li><li>关系操作符</li></ul></li><li>应用场景：数据去重</li></ul><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><ul><li>定义：具有先后关系的一组元素</li><li>衍生：字符串、元组、列表<ul><li>字符串：str = ‘abc’</li><li>元组：t = (…)或t = tuple(…)</li><li>列表：lt = […]或lt = list[…]</li></ul></li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>映射是一种键（索引/属性）和值（数据）的对应</li><li>定义：d = {…}或d = dict(…)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;h3 id=&quot;整数&quot;&gt;&lt;a href=&quot;#整数&quot; class=&quot;headerlink&quot; title=&quot;整数&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Python" scheme="http://39.106.115.216/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://39.106.115.216/2020/01/31/hello-world/"/>
    <id>http://39.106.115.216/2020/01/31/hello-world/</id>
    <published>2020-01-30T23:45:56.429Z</published>
    <updated>2020-01-30T23:45:56.429Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
