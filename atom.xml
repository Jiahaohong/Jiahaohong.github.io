<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darcy&#39;s Blog</title>
  
  <subtitle>Hope is something as precious as dimond.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/Jiahaohong/"/>
  <updated>2020-09-21T00:08:03.874Z</updated>
  <id>http://github.com/Jiahaohong/</id>
  
  <author>
    <name>Darcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matlab:快速傅里叶变换实现</title>
    <link href="http://github.com/Jiahaohong/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/Jiahaohong/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-19T19:13:55.000Z</published>
    <updated>2020-09-21T00:08:03.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是傅里叶变换"><a href="#一、什么是傅里叶变换" class="headerlink" title="一、什么是傅里叶变换"></a>一、什么是傅里叶变换</h3><p>简单来说，傅里叶变换将一个函数分解为一组三角函数的和，通过将这个函数分别和这组三角函数中的每一个进行内积运算，可以求得每个三角函数前面的系数。  </p><h4 id="正交函数集"><a href="#正交函数集" class="headerlink" title="正交函数集"></a>正交函数集</h4><p>  正交函数集满足如下两条性质：  </p><ol><li><p>正交函数集中的任意两个不相同函数的内积为0；  </p></li><li><p>如果正交函数集中存在一个函数可以由函数集中除它以外的函数表示，则这个函数集不是正交函数集。  </p><p>用类比的角度看，这个定义和线性代数中的基向量组的定义一致。说明正交函数集其实相当于函数空间中的一组基向量，函数空间中的一个函数对应向量空间中的一个向量，任何向量可以由基向量表示，同样的，任何函数可以由正交函数集表示。基向量可以写成矩阵的形式，同理，正交函数集也可以写成向量的形式。如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  这是一个1维向量，当前乘一个函数时就可以利用矩阵的乘法将函数分解到这个正交函数集上。  <center>[f(x)] * [1, sin(wx), cos(wx), ..., sin(nwx), cos(nwx), ...] =</center>  <center>[a0, b1*sin(wx), a1*cos(wx), ..., bn*sin(nwx), an*cos(nwx), ...]</center>  注意这些系数通过原函数f(x)和基函数内积等运算得到的。  </li></ol><h4 id="内积运算"><a href="#内积运算" class="headerlink" title="内积运算"></a>内积运算</h4><p>  内积定义为向量a在向量b上的投影向量，当内积运算后的结果除以向量b的模长，就可以计算出向量a在向量b上投影占向量b的比例，这个比例就是基函数前面的系数。内积是反映两个向量相似度的重要指标，当两个向量完全相等时，它们的内积取得最大值。因此正交函数集的系数的含义，可以理解为原函数和基函数的相似度，相似度越大，这个基函数的系数越大。</p><p>因此，总体上来看，正交函数集构成了一个无穷维数的函数空间，这个空间里的任何函数都可以由这些基函数的加权求和表示，权重就是原函数和积函数的内积，及将原函数投影到这些正交函数集上。  </p><h3 id="二、离散傅里叶变换"><a href="#二、离散傅里叶变换" class="headerlink" title="二、离散傅里叶变换"></a>二、离散傅里叶变换</h3><p>上一个板块中讲到傅里叶变换是连续函数空间里的，如果处理的函数是一个离散的函数，那么就要用到离散傅里叶变换。离散傅里叶变换与来连续傅里叶变换的最大区别是求系数时的积分运算变成了求和运算。将正交函数集的向量形式抄写如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  注意，这里的每一列都是一个连续函数，如果用离散的x坐标将其离散化，就可以获得离散傅里叶变换的正交函数集矩阵，如下：  <img src="/Jiahaohong/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/DMat.jpg">  <p>这是一个二维矩阵，每一列代表一个正交函数，每一行代表一个离散坐标x。将离散函数写成向量的形式后就可以用矩阵的乘法求出变换后的函数。注意，上述矩阵并没有限制离散变量的取值范围以及基函数的个数，如果要满足矩阵乘法的要求，离散变量x的取值范围应该和原函数的x范围相同，一般来说，基函数的个数（变换后的变量w取值范围）也和原函数x的范围一致。  </p><h3 id="三、一维快速傅里叶变换的原理"><a href="#三、一维快速傅里叶变换的原理" class="headerlink" title="三、一维快速傅里叶变换的原理"></a>三、一维快速傅里叶变换的原理</h3><h3 id="四、二维傅里叶变换的性质"><a href="#四、二维傅里叶变换的性质" class="headerlink" title="四、二维傅里叶变换的性质"></a>四、二维傅里叶变换的性质</h3><h3 id="五、二维快速傅里叶变换的实现"><a href="#五、二维快速傅里叶变换的实现" class="headerlink" title="五、二维快速傅里叶变换的实现"></a>五、二维快速傅里叶变换的实现</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是傅里叶变换&quot;&gt;&lt;a href=&quot;#一、什么是傅里叶变换&quot; class=&quot;headerlink&quot; title=&quot;一、什么是傅里叶变换&quot;&gt;&lt;/a&gt;一、什么是傅里叶变换&lt;/h3&gt;&lt;p&gt;简单来说，傅里叶变换将一个函数分解为一组三角函数的和，通过将这个函数分别和这
      
    
    </summary>
    
    
    
      <category term="Matlab" scheme="http://github.com/Jiahaohong/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Keil5安装芯片包</title>
    <link href="http://github.com/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/"/>
    <id>http://github.com/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/</id>
    <published>2020-07-29T06:03:03.000Z</published>
    <updated>2020-07-29T06:54:41.016Z</updated>
    
    <content type="html"><![CDATA[<p>如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：</p><ul><li><p>打开下载芯片包的界面</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/1.png"> </li><li><p>在左侧双击你需要的芯片</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/2.png"></li><li><p>点击右侧你需要的芯片包的Install按钮</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/3.png"></li><li><p>单击选中下方报错的行</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/4.png"></li><li><p>复制后粘贴到浏览器网址栏</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/5.png"></li><li><p>去掉头尾留下地址，按回车即可下载</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/6.png">  <img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/7.png"></li><li><p>下载完毕后回到下载芯片包界面，点击file里的import选项</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/8.png"></li><li><p>在弹出窗口里找到之前下载的文件导入</p><img src="/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/9.png"></li></ul><p>完成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开下载芯片包的界面&lt;/p&gt;
&lt;img src=&quot;/Jiahaohong/2020/07/29/Keil5%E5%AE%89%E8%A3%85
      
    
    </summary>
    
    
    
      <category term="Keil5" scheme="http://github.com/Jiahaohong/tags/Keil5/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:制作数据集</title>
    <link href="http://github.com/Jiahaohong/2020/07/22/Tensrflow-%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://github.com/Jiahaohong/2020/07/22/Tensrflow-%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-07-22T13:45:51.000Z</published>
    <updated>2020-07-22T13:48:29.221Z</updated>
    
    <content type="html"><![CDATA[<p>tf.data.Dataset.from_tensor_slice(tensor)<br>将输入tensor按照第一个维度拆分</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tf.data.Dataset.from_tensor_slice(tensor)&lt;br&gt;将输入tensor按照第一个维度拆分&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://github.com/Jiahaohong/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令（重制版）</title>
    <link href="http://github.com/Jiahaohong/2020/07/18/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://github.com/Jiahaohong/2020/07/18/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-07-18T13:55:57.000Z</published>
    <updated>2020-07-22T08:48:01.488Z</updated>
    
    <content type="html"><![CDATA[<p><em>系统使用Ubuntu18.04，无图形界面，本地系统为Windows10</em></p><h3 id="一、Linux系统指令"><a href="#一、Linux系统指令" class="headerlink" title="一、Linux系统指令"></a>一、Linux系统指令</h3><ul><li>进入指定文件夹<br>cd /root/mygit/project1</li><li>进入上层文件夹<br>cd ..</li><li>进入根目录文件夹(root)<br>cd ~</li><li>显示当前文件夹路径<br>pwd</li><li>显示当前文件夹里的文件和文件夹<br>ls -l</li><li>在当前文件夹下创建文件夹<br>mkdir project2</li><li>在当前文件夹下创建文件<br>touch readme.txt<br>touch gitCommand.md<br>touch go.sh</li><li>删除文件或文件夹<br>sudo rm -r readme.txt<br>sudo rm -r project2</li><li>重命名文件或文件夹<br>mv readme.txt README.txt  </li><li>将上述指令结合起来使用，你就可以非常方便的解决一些文件操作的小问题了。比如进入某个文件夹，新建一个子文件夹用来存放自己的markdown笔记，就可以在命令窗口里输入如下命令：<br>cd /usr/note &amp;&amp; mkdir LinuxNotes &amp;&amp; touch day1.md</li></ul><h3 id="二、常用软件指令"><a href="#二、常用软件指令" class="headerlink" title="二、常用软件指令"></a>二、常用软件指令</h3><ul><li>screen<ul><li>新建一个新窗口<br>screen -S name<br>注意S是大写</li><li>将当前窗口挂起（后台运行）<br>ctrl + A + D<br>注意这是快捷键，按后面的键时不要松开前面的键</li><li>显示当前已经开启的窗口<br>screen -ls<br>显示的时候会显示窗口ID和名字，以及是否挂起</li><li>进入挂起窗口<br>screen -r name<br>注意r是小写</li><li>关闭窗口<br>kill ID<br>注意ID可以用screen -ls指令查看</li></ul></li><li>zip  <ul><li>解压文件到当前目录<br>unzip file.zip</li><li>压缩文件<br>zip -r file_name.zip file.txt<br>注意是将file.txt文件压缩为file_name.zip文件，不要弄反了 </li></ul></li></ul><h3 id="三、上传下载文件"><a href="#三、上传下载文件" class="headerlink" title="三、上传下载文件"></a>三、上传下载文件</h3><ul><li>rz/sz  <ul><li>从服务器下载文件<br>sz file.zip</li><li>从本地上传文件<br>rz<br>注意本地需要相应软件，比如Xshell</li></ul></li><li>windows命令窗口上传文件  <ul><li>pscp C:/fold1/fold1_2/file.txt <a href="mailto:root@xx.xxx.xxx.xxx">root@xx.xxx.xxx.xxx</a>:/usr/folderA  </li></ul></li></ul><h3 id="四、anaconda使用指令"><a href="#四、anaconda使用指令" class="headerlink" title="四、anaconda使用指令"></a>四、anaconda使用指令</h3><ul><li>查看虚拟环境列表<br>conda info -e</li><li>创建虚拟环境<br>conda create -n env_name</li><li>进入虚拟环境<br>conda activate env_name</li><li>退出虚拟环境<br>conda deactivate</li><li>在当前虚拟环境下安装 包<br>conda install appname<br>conda install URL</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;系统使用Ubuntu18.04，无图形界面，本地系统为Windows10&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、Linux系统指令&quot;&gt;&lt;a href=&quot;#一、Linux系统指令&quot; class=&quot;headerlink&quot; title=&quot;一、Linux系统指令&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://github.com/Jiahaohong/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深度学习：卷积神经网络</title>
    <link href="http://github.com/Jiahaohong/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://github.com/Jiahaohong/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-17T13:57:15.000Z</published>
    <updated>2020-09-20T22:29:16.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、卷积神经网络符号说明"><a href="#一、卷积神经网络符号说明" class="headerlink" title="一、卷积神经网络符号说明"></a>一、卷积神经网络符号说明</h3><p><em>这里将卷积层和池化层看作一层神经网络，但分开描述</em><br><em>这里手的图像可以是抽象的多维矩阵</em></p><ol><li><p>图像n  </p><ul><li>图像数量：m  </li><li>图像高度：n<sub>H</sub>  </li><li>图像宽度：n<sub>W</sub>  </li><li>图像信道：n<sub>C</sub></li></ul></li><li><p>过滤器Filter  </p><ul><li>形状：f<sub>H</sub><sup>[l]</sup> * f<sub>W</sub><sup>[l]</sup>，指一个过滤器的一层矩阵的高和宽，大多数的时候，f<sub>H</sub><sup>[l]</sup> =  f<sub>W</sub><sup>[l]</sup> = 3  </li><li>边沿padding：p<sup>[l]</sup>，用来将过滤器要过滤的图像填充成指定形状</li><li>步长step：s<sup>[l]</sup>，表示过滤器在输入图像上移动一次所经过的像素个数</li><li>信道channel：n<sub>C</sub><sup>[l-1]</sup>，注意，第l层的过滤器的信道数量和上一层的输出图像信道数量相同，这是卷积运算的前提条件  </li></ul></li><li><p>池化层Pooling  </p><ul><li>形状：f<sub>H</sub><sup>[l]</sup> * f<sub>W</sub><sup>[l]</sup></li><li>边沿padding：p<sup>[l]</sup>，用来将池化层要池化的图像填充成指定形状</li><li>步长step：s<sup>[l]</sup>，表示池在输入图像上移动一次所经过的像素个数</li><li>信道channel：n<sub>C</sub><sup>[l]</sup> = f<sub>m</sub>，注意，第l层的池的信道数量和这一层过滤器的个数相同。</li></ul></li><li><p>全连接FullConnection</p><ul><li>普通的神经网络连接层</li></ul></li></ol><h3 id="二、卷积神经网络的基本模块"><a href="#二、卷积神经网络的基本模块" class="headerlink" title="二、卷积神经网络的基本模块"></a>二、卷积神经网络的基本模块</h3><ol><li>卷积层<br>卷积操作是由过滤器和上一层的输出完成的。首先来看看卷积操作是如何完成的，然后再研究其中的数据维数等细节。  <ul><li>卷积操作<br>图像的形状为n<sub>H</sub> * n<sub>W</sub>，过滤器的形状为f<sub>H</sub> * f<sub>W</sub>，假设图像没有加边沿padding，过滤器的步长为1，那么将过滤器矩阵和图像矩阵左上角对齐，重叠的格子中的数据相乘，将得到的结果相加作为输出矩阵的第一个元素，然后将过滤器矩阵右移一个像素（一个步长），重复上述操作得到输出矩阵的第二个元素，以此类推，直到右移超出图像边界时，向下移动一个像素，再从最左边开始重复上述操作。</li><li>数据维数<br>由于过滤器所操作的图像可能有多层通道，那么过滤器的通道数和图像必须对应，相同通道的过滤器和图像矩阵进行卷积操作，得到的结果相加作为输出矩阵的一个通道。因此，过滤器有几个，输出矩阵的通道数就有几个。</li></ul></li><li>池化层<br>池化操作简单来说是将图片分为几个区域，从中挑选出符合要求的数据组成新的图像。池和过滤器的结构和定义相似，只不过池中矩阵的每一位上没有权重，只是用来区分图像区域。池化操作和卷积的操作流程相似，但不是将池中的数据加权求和，而是取最大值或平均值作为输出。</li><li>全连接层<br>全连接层时普通的DNN网络，通过将之前网络提取出来的特征展平，再连接，最后输出结果</li></ol><h3 id="三、卷积神经网络的前向传播和反向传播算法"><a href="#三、卷积神经网络的前向传播和反向传播算法" class="headerlink" title="三、卷积神经网络的前向传播和反向传播算法"></a>三、卷积神经网络的前向传播和反向传播算法</h3><p>。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、卷积神经网络符号说明&quot;&gt;&lt;a href=&quot;#一、卷积神经网络符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、卷积神经网络符号说明&quot;&gt;&lt;/a&gt;一、卷积神经网络符号说明&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这里将卷积层和池化层看作一层神经网络，但分开描述&lt;/
      
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="http://github.com/Jiahaohong/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Python:Numpy</title>
    <link href="http://github.com/Jiahaohong/2020/07/11/Python-Numpy/"/>
    <id>http://github.com/Jiahaohong/2020/07/11/Python-Numpy/</id>
    <published>2020-07-11T09:39:51.000Z</published>
    <updated>2020-07-19T11:56:49.614Z</updated>
    
    <content type="html"><![CDATA[<ul><li>np.zeros(shape, dtype=float)  </li><li>np.random.rand()<br>括号里为矩阵维数，获得数值在0~1之间的随机数矩阵</li><li>np.random.randn()<br>括号里为矩阵维数，获得数值为正态分布的随机数矩阵</li><li>np.sum(A,axis=None)<br>把axis对应的维度的数相加，变成0维</li><li>np.squeeze(X)<br>把X中只有1个元素的维度去掉</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;np.zeros(shape, dtype=float)  &lt;/li&gt;
&lt;li&gt;np.random.rand()&lt;br&gt;括号里为矩阵维数，获得数值在0~1之间的随机数矩阵&lt;/li&gt;
&lt;li&gt;np.random.randn()&lt;br&gt;括号里为矩阵维数，获得数值为正
      
    
    </summary>
    
    
    
      <category term="Python" scheme="http://github.com/Jiahaohong/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习:逻辑回归的符号和公式</title>
    <link href="http://github.com/Jiahaohong/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <id>http://github.com/Jiahaohong/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F/</id>
    <published>2020-07-07T01:48:36.000Z</published>
    <updated>2020-07-18T13:54:15.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、符号说明"><a href="#一、符号说明" class="headerlink" title="一、符号说明"></a>一、符号说明</h3><p>一个样本包含两个部分，特征x和标签y</p><ul><li>x<br>表示某一个样本的特征的集合，通常是一个列向量，其中每一个维度表示一个特征</li><li>x<sub>j</sub><br>表示第j个特征</li><li>x<sup>(i)</sup><br>表示第i个样本的特征数据，注意上标是小括号</li><li>x<sup>(i)</sup><sub>j</sub><br>表示第i个样本的第j个特征，注意上标是小括号</li><li>y<br>表示一个样本的真实标签，通常时一个列向量，其中每一个维度代表一个种类，如果该样本这一个维度为0，表示该样本不属于该种类；如果该样本的这一维度为1，表示该样本属于该种类</li><li>y<sup>(i)</sup><br>表示第i个样本的标签，注意上标是小括号  </li></ul><p>一层神经网络由三部分组成，第一部分是与上一层神经网络连接的权重矩阵，第二部分是权重矩阵的输出，第三部分是权重矩阵的输出经过该层神经元的激活函数后的输出结果</p><ul><li>n<sub>i</sub><br>表示第i层神经网络的神经元个数，通常输入层（第0层）写作n<sub>x</sub>，输出层（最后一层）写作n<sub>L</sub></li><li>W<sup>[i]</sup><br>表示连接第i-1层和第i层神经元的权重矩阵，矩阵形状为(n<sub>i</sub>,n<sub>i-1</sub>)，n<sub>i</sub>是第i层的神经元个数</li><li>Z<sup>[i]</sup><br>表示第i层神经元的输入</li><li>A<sup>[i]</sup><br>表示Z<sup>[i]</sup>经过第i层神经元的激活函数后的输出，之后要输入到下一层的权重矩阵W<sup>[i+1]</sup>里；特别的，输入的样本特征可以看作是A<sup>[0]</sup>  </li></ul><p>偏导数部分的符号是程序里的变量标识符，不是数学里的微分字符</p><ul><li>dW<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li><li>dZ<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li><li>dA<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li></ul><h3 id="二、公式"><a href="#二、公式" class="headerlink" title="二、公式"></a>二、公式</h3><ol><li>前向传播公式<br>(1) Z<sup>[i]</sup> = W<sup>[i]</sup> · A<sup>[i-1]</sup> + b<sup>[i]</sup><br>(2) A<sup>[i]</sup> = g<sup>[i]</sup>(Z<sup>[i]</sup>)</li><li>反向传播公式<br>(1) dW<sup>[i]</sup> = (1/m)·dZ<sup>[i]</sup>·A<sup>[i-1]T</sup><br>(2) db<sup>[i]</sup> = (1/m)·sum(dZ<sup>[i]</sup>)<br>(3) dZ<sup>[i-1]</sup> = W<sup>[i]T</sup>·dZ<sup>[i]</sup>*g<sup>[i-1]’</sup>(Z<sup>[i-1]</sup>)</li><li>公示推导的简单说明<br>对于公式1，根据矩阵求导公式d( f(X) ) = d( A·X )/dX = A<sup>T</sup>，再由矩阵相等时维度相同，可得1个样本时的偏导数为dZ<sup>[i]</sup>·A<sup>[i-1]T</sup>，如果有m个样本，则取平均值1/m。<br>对于公式3，类似公式1的求导公式得出下一层网络的输入Z<sup>[i]</sup>对上一层网络的输出A<sup>[i-1]</sup>的偏导函数为W<sup>[i]T</sup>,同样根据矩阵相等时维度必须相同可得公式3，注意后面的g<sup>[i-1]’</sup>(Z<sup>[i-1]</sup>)只不过是A<sup>[i-1]</sup>对Z<sup>[i-1]</sup>的偏导函数，因为A<sup>[i-1]</sup> = g<sup>[i-1]</sup>(Z<sup>[i-1]</sup>)。</li></ol><h3 id="三、常用激活函数导数"><a href="#三、常用激活函数导数" class="headerlink" title="三、常用激活函数导数"></a>三、常用激活函数导数</h3><ul><li>S(x) = sigmoid(X)<br> S<sup>‘</sup>(x) = S(x)·(1-S(x))</li><li>f(x) = tanh(x)<br> f<sup>‘</sup>(x) = 1-(f(x))<sup>2</sup></li><li>f(x) = ReLU(x)<br> f<sup>‘</sup>(x) = max{0,a}</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、符号说明&quot;&gt;&lt;a href=&quot;#一、符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、符号说明&quot;&gt;&lt;/a&gt;一、符号说明&lt;/h3&gt;&lt;p&gt;一个样本包含两个部分，特征x和标签y&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x&lt;br&gt;表示某一个样本的特征的集合，通常是
      
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="http://github.com/Jiahaohong/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：竞争与冒险</title>
    <link href="http://github.com/Jiahaohong/2020/05/29/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%86%92%E9%99%A9/"/>
    <id>http://github.com/Jiahaohong/2020/05/29/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%86%92%E9%99%A9/</id>
    <published>2020-05-29T08:35:53.000Z</published>
    <updated>2020-05-29T14:14:41.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、竞争与冒险的定义"><a href="#一、竞争与冒险的定义" class="headerlink" title="一、竞争与冒险的定义"></a>一、竞争与冒险的定义</h3><p>当一个逻辑门的两个输入变量在同一时刻发生翻转，而变化的时间有差异的现象，称为竞争。<br>由竞争产生输出干扰脉冲的现象称为冒险。</p><h3 id="二、竞争与冒险的判别"><a href="#二、竞争与冒险的判别" class="headerlink" title="二、竞争与冒险的判别"></a>二、竞争与冒险的判别</h3><p>已知一个逻辑表达式，如何判别由该逻辑表达式设计的电路会不会产生竞争与冒险？<br>首先我们需要找到在该表达式中同时出现有原变量和反变量的输入变量，然后我们将所有其他变量选择合适的值，看逻辑表达式是否能成为该输入变量的原变量和反变量的组合，若是那么就会有竞争与冒险现象。</p><h3 id="三、如何消除竞争与冒险现象"><a href="#三、如何消除竞争与冒险现象" class="headerlink" title="三、如何消除竞争与冒险现象"></a>三、如何消除竞争与冒险现象</h3><ol><li>发现并消去互补相乘项<br>如果互补项没有直接的相乘，尝试拆括号将互补项乘到一起消去。</li><li>增加乘积项避免互补项相加<br>从原表达式中增加一些不改变结果的乘积项，使得原来满足互补项相加的条件作用下，多出一些其他表达式，避免互补项相加。   </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、竞争与冒险的定义&quot;&gt;&lt;a href=&quot;#一、竞争与冒险的定义&quot; class=&quot;headerlink&quot; title=&quot;一、竞争与冒险的定义&quot;&gt;&lt;/a&gt;一、竞争与冒险的定义&lt;/h3&gt;&lt;p&gt;当一个逻辑门的两个输入变量在同一时刻发生翻转，而变化的时间有差异的现象，称为
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:搭建网络步骤</title>
    <link href="http://github.com/Jiahaohong/2020/05/20/Tensorflow-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E6%AD%A5%E9%AA%A4/"/>
    <id>http://github.com/Jiahaohong/2020/05/20/Tensorflow-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E6%AD%A5%E9%AA%A4/</id>
    <published>2020-05-20T01:50:21.000Z</published>
    <updated>2020-07-22T08:46:55.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、六步法"><a href="#一、六步法" class="headerlink" title="一、六步法"></a>一、六步法</h3><ol><li>import   </li><li>train,test  </li><li>model = tf.keras.models.Seque ntial  </li><li>model.compile<br>配置训练方法，比如优化器、损失函数   </li><li>model.fit  </li><li>model.summary</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、六步法&quot;&gt;&lt;a href=&quot;#一、六步法&quot; class=&quot;headerlink&quot; title=&quot;一、六步法&quot;&gt;&lt;/a&gt;一、六步法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;import   &lt;/li&gt;
&lt;li&gt;train,test  &lt;/li&gt;
&lt;li&gt;model = tf.
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://github.com/Jiahaohong/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:激活函数和损失函数</title>
    <link href="http://github.com/Jiahaohong/2020/05/20/Tensorflow-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>http://github.com/Jiahaohong/2020/05/20/Tensorflow-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-20T01:02:28.000Z</published>
    <updated>2020-05-20T03:26:45.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、激活函数"><a href="#一、激活函数" class="headerlink" title="一、激活函数"></a>一、激活函数</h3><ul><li><p>Sigmoid函数<br>tf.nn.sigmoid(x)<br>特点：<br>（1）导数不为0的范围太小，容易造成梯度消失<br>（2）输出非0均值，收敛慢<br>（3）幂运算计算复杂，训练时间长</p></li><li><p>Relu函数</p></li></ul><h3 id="二、损失函数"><a href="#二、损失函数" class="headerlink" title="二、损失函数"></a>二、损失函数</h3><ul><li>softmax</li><li>cross-entropy</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、激活函数&quot;&gt;&lt;a href=&quot;#一、激活函数&quot; class=&quot;headerlink&quot; title=&quot;一、激活函数&quot;&gt;&lt;/a&gt;一、激活函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sigmoid函数&lt;br&gt;tf.nn.sigmoid(x)&lt;br&gt;特点：&lt;br&gt;（1）导数
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://github.com/Jiahaohong/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:常用函数</title>
    <link href="http://github.com/Jiahaohong/2020/05/19/Tensorflow-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://github.com/Jiahaohong/2020/05/19/Tensorflow-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-19T01:22:16.000Z</published>
    <updated>2020-05-19T09:14:05.723Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>强制类型转换<br>tf.cast(张量名,dtype=数据类型)</p></li><li><p>计算张量维度上的最值<br>tf.reduce_min(张量名)<br>tf.reduce_max(张量名)<br>如果没有指定维度，那么默认寻找这个张量所有元素里的最值。</p></li><li><p>axis<br>用于指定函数作用的维度。比如在二维张量中(数组)，axis=0代表作用维度是列，tf.reduce_mean(a,axis=0)表示分别在张量a的所有列中找到最小值。</p></li></ul><ul><li><p>tf.Variable<br>将变量标记为“可训练”，被标记的变量会在反向传播中记录梯度信息。可用于参数初始化。</p></li><li><p>张量对应元素的四则运算<br>tf.add(a,b)<br>tf.subtract(a,b)<br>tf.multiply(a,b)<br>tf.divide(a,b)<br>张量a，b维度必须相同。</p></li><li><p>矩阵乘<br>tf.matmul(A,B)</p></li><li><p>tf.data.Dataset.from_tensor_slices<br>将特征和标签配对</p></li><li><p>tf.GradientTape</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    w = tf.Variable(tf.constant(<span class="number">3.0</span>))</span><br><span class="line">    loss = tf.pow(w,<span class="number">2</span>)</span><br><span class="line">grad = tape.gradient(loss,w)</span><br><span class="line">print(grad)</span><br></pre></td></tr></table></figure></li><li><p>tf.one_hot<br>独热编码，在分类问题中常用做标签，1表示是，0表示非。<br>tf.one_hot(代转换数据,depth=几分类)</p></li><li><p>assign_sub<br>只能作用于“可训练”变量，相当于i–。</p></li><li><p>tf.argmax<br>返回张量指定维度的最大值的索引，及最大值的位置。注意不是最大索引值。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;强制类型转换&lt;br&gt;tf.cast(张量名,dtype=数据类型)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算张量维度上的最值&lt;br&gt;tf.reduce_min(张量名)&lt;br&gt;tf.reduce_max(张量名)&lt;br&gt;如果没有指定维度，那么默认寻找这个张量
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://github.com/Jiahaohong/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:Tensor</title>
    <link href="http://github.com/Jiahaohong/2020/05/18/Tensorflow-Tensor/"/>
    <id>http://github.com/Jiahaohong/2020/05/18/Tensorflow-Tensor/</id>
    <published>2020-05-18T14:28:09.000Z</published>
    <updated>2020-05-19T01:19:59.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p><font color="yellow">tf.int, tf.float</font><br>    tf.int32, tf.int64, tf.float32, tf.float64<br><font color="yellow">tf.bool</font><br>    tf.constant([True,False])<br><font color="yellow">tf.string</font><br>    tf.constrant(“Hello,world!”)</p><h3 id="二、张量（Tensor）"><a href="#二、张量（Tensor）" class="headerlink" title="二、张量（Tensor）"></a>二、张量（Tensor）</h3><p>向量和矩阵的高维拓展。<strong>张量可以表示n维数组。</strong></p><ul><li><p>如何创建张量？<br><font color="yellow">tf.constant(张量内容，dtype=数据类型)</font>  </p></li><li><p>如何查看张量形状（维数）？<br><font color="yellow">print(a.shape)</font><br>输出：shape=(2,)<br>输出中shape的括号里逗号隔开了几个数字，该张量就是几维，上例中张量a是一个一维数组，包含两个元素。</p></li><li><p>numpy数据类型和tensor数据类型的转换<br><font color="yellow">tf.convert_to_tensor(数据名，dtype=数据类型)</font></p></li><li><p>创建全为指定值的张量<br><font color="yellow">tf.zeros(维度)<br>tf.ones(维度)<br>tf.fill(维度，指定值)</font><br>其中，维度如果是1维就直接写元素个数，如果是二维及二维以上，用[n,m,j,k,……]表示张量形状。</p></li><li><p>生成正太分布的随机数<br><font color="yellow">tf.random.normal(维度，mean=均值，stdev=标准差)</font><br>默认mean=0，stdev=1。</p></li><li><p>生成2$delta$范围内的正太分布随机数<br><font color="yellow">tf.random.truncated_normal(维度，mean=均值，stdev=标准差)</font><br>随机数生成在均值加减2倍标准差的范围内。</p></li><li><p>生成均匀分布随机数<br><font color="yellow">tf.random.uniform(维度，minval=最小值，maxval=最大值)</font><br>随机数在[minval,maxval)的左闭右开区间上。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、数据类型&quot;&gt;&lt;a href=&quot;#一、数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型&quot;&gt;&lt;/a&gt;一、数据类型&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;yellow&quot;&gt;tf.int, tf.float&lt;/font&gt;&lt;br&gt;    tf
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://github.com/Jiahaohong/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：触发器</title>
    <link href="http://github.com/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://github.com/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2020-05-18T07:45:24.000Z</published>
    <updated>2020-08-27T08:00:59.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、主从D触发器"><a href="#一、主从D触发器" class="headerlink" title="一、主从D触发器"></a>一、主从D触发器</h3><p>略</p><h3 id="二、触发器逻辑功能"><a href="#二、触发器逻辑功能" class="headerlink" title="二、触发器逻辑功能"></a>二、触发器逻辑功能</h3><p>下面介绍一些常用的触发器的特性方程（Q’代表次态）。</p><ul><li>D触发器<br>Q’=D</li><li>JK触发器<br>Q’=J<span style="text-decoration:overline">Q</span>+<span style="text-decoration:overline">K</span>Q</li><li>T触发器<br>相当于JK触发器J端和K端接到一起：<br>Q’=T<span style="text-decoration:overline">Q</span>+<span style="text-decoration:overline">T</span>Q</li><li>T’触发器<br>相当于T触发器T端始终接高电平：<br>Q’=<span style="text-decoration:overline">Q</span></li><li>SR触发器<br>Q’=S+<span style="text-decoration:overline">R</span>Q<br>S·R=0</li></ul><h3 id="三、触发器的逻辑功能转换"><a href="#三、触发器的逻辑功能转换" class="headerlink" title="三、触发器的逻辑功能转换"></a>三、触发器的逻辑功能转换</h3><p>用D触发器可以实现其他所有的触发器。总体方法是：由于D触发器的特性方程和需要转换的触发器的特性方程是等价的，那么就可以由代转换的触发器特性方程推出输入端D的逻辑表达式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、主从D触发器&quot;&gt;&lt;a href=&quot;#一、主从D触发器&quot; class=&quot;headerlink&quot; title=&quot;一、主从D触发器&quot;&gt;&lt;/a&gt;一、主从D触发器&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&quot;二、触发器逻辑功能&quot;&gt;&lt;a href=&quot;#二、触发器逻辑功能&quot; 
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：锁存器</title>
    <link href="http://github.com/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/"/>
    <id>http://github.com/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/</id>
    <published>2020-05-18T03:19:29.000Z</published>
    <updated>2020-08-27T03:01:03.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基本双稳态电路"><a href="#一、基本双稳态电路" class="headerlink" title="一、基本双稳态电路"></a>一、基本双稳态电路</h3><p>先直接给出书本上的定义：具有0、1两种逻辑状态，并且进入其中任何一种逻辑状态后均能长期保持这种状态不变的单元电路。<br>并且<strong>规定</strong>Q端输出为0的时候，该电路逻辑状态为0；Q端输出为1的时候，该电路逻辑状态为1。  </p><img src="/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/基本双稳态电路.png">   <p>那么如何分析该电路的状态呢？<br>首先假定电路的一个逻辑状态，比如为0；然后确定两输出端的逻辑电平，此时Q为0，Q非为1；接着分析反馈到输入端的逻辑电平，G1输入1，G2输入0；最后通过输入和逻辑门检查输出端的逻辑电平是否和假设一致（此例G1输出0和假设一致），如果一致，表示电路逻辑状态就是假设的逻辑状态，已经稳定了，如果不一致，需要修改假设的逻辑状态再进行一次判断，若第二次分析结果还是不一致，则说明电路进入了不确定状态。</p><h3 id="二、基本SR锁存器"><a href="#二、基本SR锁存器" class="headerlink" title="二、基本SR锁存器"></a>二、基本SR锁存器</h3><p>将基本双稳态电路的非门换成两输入或非门就构成了一种基本SR锁存器，如果换成两输入与非门就构成了另一种基本SR锁存器。   </p><ul><li><p>或非门SR锁存器<br><strong>定义Q=1为锁存器的1状态，Q=0为锁存器的0状态。</strong>  </p><img src="/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/基本SR锁存器.png">  <p>这个电路的状态如何分析？<br>总体来说和双稳态电路的分析过程差不多，但是考虑到多出来两个输入端，所以在分析锁存器的状态的时候，不仅需要假设锁存器的输出状态，还要假设锁存器的输入状态。下面给出锁存器的功能表：</p></li></ul><table><thead><tr><th align="center">S</th><th align="center">R</th><th align="center">Q</th><th align="center"><span style="text-decoration: overline">Q</span></th><th align="center">Function</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">不变</td><td align="center">不变</td><td align="center">保持</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">置0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">置1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">非定义状态（危险）</td></tr></tbody></table><p>  总结一下：S端代表SET，及设置为1状态；R端代表RESET，及重置0状态；S端和R端接收到高电平时才会发挥作用，接收到低电平时不起作用；S端和R端不能同时起作用，及送入S端和R端的信号满足S·R=0，二者不能同时为1。</p><ul><li><p>与非门锁存器<br><strong>定义Q=1为锁存器的1状态，Q=0为锁存器的0状态。</strong>  </p><img src="/Jiahaohong/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/基本SR锁存器2.png">  <p>与非门锁存器和或非门锁存器送入输入端的信号是互补的，其他一摸一样。可以理解为在或非门两个输入端外分别连接一个非门。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基本双稳态电路&quot;&gt;&lt;a href=&quot;#一、基本双稳态电路&quot; class=&quot;headerlink&quot; title=&quot;一、基本双稳态电路&quot;&gt;&lt;/a&gt;一、基本双稳态电路&lt;/h3&gt;&lt;p&gt;先直接给出书本上的定义：具有0、1两种逻辑状态，并且进入其中任何一种逻辑状态后均能长
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据库：什么是范式？（下）</title>
    <link href="http://github.com/Jiahaohong/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://github.com/Jiahaohong/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-26T08:02:04.000Z</published>
    <updated>2020-08-27T06:46:25.335Z</updated>
    
    <content type="html"><![CDATA[<p><em>范式的规定随着序号的增加而逐渐严格，序号大的范式一定满足序号小的范式的要求</em></p><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><em><strong>属性不可分</strong></em><br>这是最简单也是最基础的范式，<strong>所有关系模型</strong>必须满足这个范式。这个定义已经十分清晰明了了，即在实际情况中，我们选取的关系模型的属性必须具有原子性，不可分性，但是同时又不必过于细致，能够满足实际应用要求即可。</p><p><em>接下来的范式定义就逐渐晦涩难懂了，我会采用实际例子来辅助理解</em></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p><em><strong>所有非主属性完全依赖于任意一个键码</strong></em><br>在这里我们要重点关注一个词：完全。什么样的依赖从才能说是完全依赖呢？我们看看下面这个图书馆借书登记的例子。  </p><table><thead><tr><th align="center">Name</th><th align="center">Title</th><th align="center">Date</th><th align="center">Domitory</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Pride And Prejudice</td><td align="center">2020/3/26</td><td align="center">Domitory A</td></tr><tr><td align="center">Lucy</td><td align="center">Jane Eyre</td><td align="center">2020/1/18</td><td align="center">Domitory B</td></tr></tbody></table><p>在这个借书信息关系表中，我们可以<strong>通过生活实际</strong>得出如下的函数依赖关系：Name Title-&gt;Date和Name-&gt;Domitory。通过<strong>闭包</strong>，我们可以求出关系表的键码为{Name，Title}，Date这个属性是通过这个键码确定的，但是Domitory这个属性是通过这个<strong>键码的子集</strong>{Name}确定的，因此这个关系表不符合第二范式。<br>这时候只要选择一个函数依赖分离出一个新的关系表就可以解决这个问题。比如选择函数依赖Name-&gt;Domitory分离出第一个表：  </p><table><thead><tr><th align="center">Name</th><th align="center">Domitory</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Domitory A</td></tr><tr><td align="center">Lucy</td><td align="center">Domitory B</td></tr></tbody></table><p><strong>剩下的属性集</strong>作为第二个表：  </p><table><thead><tr><th align="center">Name</th><th align="center">Title</th><th align="center">Date</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Pride And Prejudice</td><td align="center">2020/3/26</td></tr><tr><td align="center">Lucy</td><td align="center">Jane Eyre</td><td align="center">2020/1/18</td></tr></tbody></table><p>这样两个表就都符合第二范式了。当然，实际问题可能更加复杂，比如上面第二个表分离出来后还是不符合第二范式，那么就要根据别的函数依赖继续分离第二个表。</p><p>需要注意的是，第二范式并不要求非主属性直接依赖于同一个键码，但是非主属性一定能够通过某种函数传递而依赖于同一个键码。看上去挺绕的是不是？我们来看一个例子：  </p><table><thead><tr><th align="center">Name</th><th align="center">Domitory</th><th align="center">DomitoryManagement</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Domitory A</td><td align="center">Uncle Ben</td></tr><tr><td align="center">Lucy</td><td align="center">Domitory B</td><td align="center">Aunt Jenny</td></tr></tbody></table><p>在这个关系表中，DomitoryManagement不直接依赖于键码{Name}，但是它依赖于Domitory，并且Domitory依赖于键码{Name}，这是一个传递依赖，所以符合第二范式。这一点是区分第二范式和第三范式的关键，因为第三范式要求不能有传递依赖。</p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><em><strong>如果对于关系R中的任何非平凡依赖A1A2…An-&gt;B，它们满 足条件：或者A1A2…An是超键码，或者B是某个键码的组成部分，则关系R满足第三范式</strong></em></p><h2 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;范式的规定随着序号的增加而逐渐严格，序号大的范式一定满足序号小的范式的要求&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一范式&quot;&gt;&lt;a href=&quot;#第一范式&quot; class=&quot;headerlink&quot; title=&quot;第一范式&quot;&gt;&lt;/a&gt;第一范式&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;str
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：什么是范式（上）？</title>
    <link href="http://github.com/Jiahaohong/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://github.com/Jiahaohong/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-03-24T13:00:35.000Z</published>
    <updated>2020-03-30T06:11:51.682Z</updated>
    
    <content type="html"><![CDATA[<p>在细致讨论关系数据库的范式之前，我们要理解几个重要概念。</p><h2 id="关系的键码"><a href="#关系的键码" class="headerlink" title="关系的键码"></a>关系的键码</h2><h3 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h3><p>一个关系表的键码满足如下条件：</p><ol><li>键码是该关系表中的一个<strong>属性</strong>或<strong>多个属性的集合</strong></li><li>由给定的键码可以确定该关系的所有属性</li><li>键码的任何<strong>真子集</strong>都不能确定该关系的所有属性</li></ol><p>看上去有点绕？没关系，看看下面的栗子就明白了。</p><blockquote><p>1号栗子</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Gender</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">18</td></tr><tr><td align="center">002</td><td align="center">Jessica</td><td align="center">Female</td><td align="center">18</td></tr><tr><td align="center">003</td><td align="center">Lucy</td><td align="center">Female</td><td align="center">17</td></tr><tr><td align="center">004</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">17</td></tr></tbody></table><p>1号栗子中有四个属性，如果你只知道后面三个属性中的任何一个的内容，你都无法确定这个属性是谁的。比如告诉你这个人18岁，问他叫什么名字？再比如告诉你这个人叫Darcy，问他几岁？<br>同样的，如果你知道后面三个属性中的任何两个，你也是无法确定这个人的其他信息的。比如告诉你这个人叫Darcy，Male，问你他几岁？<br>但是如果你同时知道后面这三个属性的内容，那么你就可以在这个表中唯一确定一个人了！比如告诉你这个人叫Darcy，性别Male，年龄17，那么查表你就知道这个人是004号而不是001号。那么这三个属性就可以作为这个表的键码，写成这样{Name，Gender，Age}。<br>聪明的你发现，直接告诉我一个人的ID不就好了？的确如此，ID属性也是这个表的一个键码，这也说明一个关系表中的键码可以有多个，而且每个键码的优劣也有区别，这里不做讨论。</p></blockquote><p>综上所述，一个关系表的键码其实没有多神秘，它也是属性（属性集），只不过它比较特别，它可以帮你找到这个表中的其他属性。而且这样热心的属性（属性集）在一个表中可能会有多个。</p><h3 id="超键码"><a href="#超键码" class="headerlink" title="超键码"></a>超键码</h3><p>一个表中的键码加上其他0个或多个非键码属性构成的属性集合就是超键码。</p><blockquote><p>还是1号栗子<br>如果该表的键码{ID}加上Age属性，那么新的属性集合{ID，Age}就构成了一个超键码。</p></blockquote><p>注意咯，键码一定是超键码，但是超键码不一定是键码。</p><h3 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h3><p>如果一个属性是任意键码的子集，那么这个属性是主属性。<br>如果一个属性不是任何键码的子集，那么这个属性是非主属性。</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="什么是函数依赖？"><a href="#什么是函数依赖？" class="headerlink" title="什么是函数依赖？"></a>什么是函数依赖？</h3><p>简单理解为：如果已知属性A1和属性A2就一定可以推出属性B，那么称函数A1，A2决定B，并且记作A1A2-&gt;B。其中属性A1和A2可以更多。<br><del>数学理解为：一个函数依赖（函数）将定义属性集（定义域）映射到值属性集（值域）。这是我瞎写的。</del></p><blockquote><p>下面再次有请我们的1号栗子</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Gender</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">18</td></tr><tr><td align="center">002</td><td align="center">Jessica</td><td align="center">Female</td><td align="center">18</td></tr><tr><td align="center">003</td><td align="center">Lucy</td><td align="center">Female</td><td align="center">17</td></tr><tr><td align="center">004</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">17</td></tr></tbody></table><p>由键码的分析可以看到，从属性集ID可以推知属性集Name、Gender、Age，那么这就构成了一个函数依赖，写为ID-&gt;Name Gender Age。</p></blockquote><h3 id="函数依赖的分类"><a href="#函数依赖的分类" class="headerlink" title="函数依赖的分类"></a>函数依赖的分类</h3><p>下面将函数依赖简记为{A}-&gt;{B}，其中{A}和{B}都是属性集。</p><ul><li>平凡依赖<br>B是A的子集。<br><del>这个函数依赖很差劲，它不能告诉我们任何它没有的信息。</del></li><li>非平凡依赖<br>B不是A的子集，但B和A的交集不为空。<br><del>这个函数依赖还是有点用的，至少告诉了我们一些其他信息。</del></li><li>完全非平凡依赖<br>B和A的交集为空<br><del>Amazing！这个函数依赖告诉了我们全新的东西！</del></li></ul><h3 id="函数依赖的运算规则"><a href="#函数依赖的运算规则" class="headerlink" title="函数依赖的运算规则"></a>函数依赖的运算规则</h3><ul><li>分解规则<br>A1A2…An-&gt;B1B2…Bm等价于A1A2…An-&gt;Bi(i=1,2,…,m),即将一个函数依赖分解成为一组函数依赖。</li><li>合并规则<br>A1A2…An-&gt;Bi(i=1,2,…,m)等价于A1A2…An-&gt;B1B2…Bm，即将一组函数依赖合成为一个函数依赖，是分解规则的逆运算。</li><li>平凡依赖规则<br>A1A2…An-&gt;B1B2…Bm等价于A1A2…An-&gt;C1C2…Ck，其中C属于B但不属于A，即将B中和A相同的属性去掉，剩下的属性构成新的集合C还是满足原来的函数依赖。</li><li>增长规则<br>如果A1A2…An-&gt;B1B2…Bm，则对于任何属性集 C1C2…Ck，A1A2…An C1C2…Ck-&gt;B1B2…Bm C1C2…Ck,即平凡依赖规则的逆运算。</li><li>传递规则<br>若函数依赖A-&gt;B和B-&gt;C在关系R中成立,则函数依赖A-&gt;C在关系R中也成立.</li></ul><h2 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>准确的定义：首先我们有一个属性集A{A1，A2，···，An}，然后我们又有了一个函数依赖集S{S1，S2，···，Sn}，至此我们就能够通过函数依赖集中的函数依赖，确定属性集A能够决定的属性集B，称为属性集A的闭包，并记为{A1，A2，···，An}+。<br>通过上述闭包的定义，我们知道要确定一个闭包必须知道两个缺一不可的信息，一是原来的属性集，二是给定的函数依赖集。如果属性集改变，或者函数依赖集改变，都会改变闭包最终包含的属性。<br><del>数学的定义：给定一系列函数Si，将定义域A映射到值域Bi，那么Bi的集合就是定义域A的闭包。</del></p><h3 id="闭包的计算"><a href="#闭包的计算" class="headerlink" title="闭包的计算"></a>闭包的计算</h3><blockquote><p>2号栗子登场<br>给定属性集{A，B，C}和函数依赖集{AB-&gt;D，C-&gt;E}，求{A，B，C}+？<br>计算方法：选取一个函数依赖，作用于属性集上，去掉这个函数依赖，并将原来的属性集更新为新的属性集，再次选取一个函数依赖，重复此步骤，直到函数依赖集为空或者余下的所有函数依赖都无法作用于当前属性集，那么当前的属性集就是原属性集的闭包。<br>X = {A，B，C}<br>选AB-&gt;D作用于X<br>X = {A，B，C，D}<br>选C-&gt;E作用于X<br>X = {A，B，C，D，E}<br>此时函数依赖集为空，得到闭包{A，B，C，D，E}</p></blockquote><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul><li>检验一个属性集是否为关系的键码</li><li>检验一个函数依赖是否蕴含于函数依赖集</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在细致讨论关系数据库的范式之前，我们要理解几个重要概念。&lt;/p&gt;
&lt;h2 id=&quot;关系的键码&quot;&gt;&lt;a href=&quot;#关系的键码&quot; class=&quot;headerlink&quot; title=&quot;关系的键码&quot;&gt;&lt;/a&gt;关系的键码&lt;/h2&gt;&lt;h3 id=&quot;键码&quot;&gt;&lt;a href=&quot;#键码&quot;
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：E-R图</title>
    <link href="http://github.com/Jiahaohong/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AE-R%E5%9B%BE/"/>
    <id>http://github.com/Jiahaohong/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AE-R%E5%9B%BE/</id>
    <published>2020-03-12T12:11:32.000Z</published>
    <updated>2020-03-12T13:29:17.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ER图三要素"><a href="#ER图三要素" class="headerlink" title="ER图三要素"></a>ER图三要素</h2><ul><li>实体集<br>具有相同特性的同一类事物的集合，矩形表示。</li><li>属性<br>描述实体摸个特性的值，椭圆形表示。</li><li>联系<br>两个或多个实体集之间的联系，菱形表示。</li></ul><h2 id="联系的多重性"><a href="#联系的多重性" class="headerlink" title="联系的多重性"></a>联系的多重性</h2><ul><li>一对一联系，双边箭头。</li><li>一对多联系，从一指向多的箭头。</li><li>多对多联系，不加箭头。  <h3 id="如何判断两个实体集之间的联系的多重性？"><a href="#如何判断两个实体集之间的联系的多重性？" class="headerlink" title="如何判断两个实体集之间的联系的多重性？"></a>如何判断两个实体集之间的联系的多重性？</h3>如果从某个实体集A中的一个实体a出发，经过一个联系，只有另一个实体集B中唯一的一个实体b与之对应，则从A经过联系指向实体集B的连线应该加箭头。</li></ul><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>ER图中的联系可以涉及多个实体，这是ODL中所不具备的。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>键码<br>在实体集中，唯一标识一个实体的属性或属性集。用下划线表示某些属性或属性集构成了键码。注意，键码本质上也是属性。</li><li>参照完整性约束  <ol><li>必须是多对一或一对一联系。</li><li>R是从实体集E到实体集F的联系，如果若E中的一个实体e存在，那么与之对应的实体f必须存在。</li></ol></li></ul><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>如果实体集C具有实体集D的全部属性和联系，并且还拥有一些其他的属性，那么称实体集C是实体集D的子类。用等腰三角形链接超类（可以理解为父类）和子类，顶点指向超类。</p><h3 id="ODL子类和ER图子类的区别"><a href="#ODL子类和ER图子类的区别" class="headerlink" title="ODL子类和ER图子类的区别"></a>ODL子类和ER图子类的区别</h3><ul><li>ODL的子类必须是同一个类的部分成员。</li><li>ER图的实体可以属于多个实体集。</li><li>ODL子类类似Java，ER图子类类似C++。</li></ul><h2 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h2><p>如果实体集C的<strong>键码</strong>中的一些或全部属于实体集D，那么实体集C为实体集D的弱实体集。用双边矩形表示弱实体集，用双边菱形表示实体集C和D的联系。</p><h3 id="如何理解弱实体集"><a href="#如何理解弱实体集" class="headerlink" title="如何理解弱实体集"></a>如何理解弱实体集</h3><ul><li>层次结构<br>在现实世界中的弱实体集E依赖于提供给他键码的实体集F，没有实体集F，就不能确定实体集E。</li><li>连接实体集</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ER图三要素&quot;&gt;&lt;a href=&quot;#ER图三要素&quot; class=&quot;headerlink&quot; title=&quot;ER图三要素&quot;&gt;&lt;/a&gt;ER图三要素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实体集&lt;br&gt;具有相同特性的同一类事物的集合，矩形表示。&lt;/li&gt;
&lt;li&gt;属性&lt;br&gt;描述实体
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：数据分配器</title>
    <link href="http://github.com/Jiahaohong/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://github.com/Jiahaohong/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/</id>
    <published>2020-02-14T02:07:15.000Z</published>
    <updated>2020-04-24T01:55:41.517Z</updated>
    
    <content type="html"><![CDATA[<p>将公共输入信号分配到不同通道上的逻辑电路。相当于一个单刀多掷开关。</p><h2 id="用译码器实现数据分配器"><a href="#用译码器实现数据分配器" class="headerlink" title="用译码器实现数据分配器"></a>用译码器实现数据分配器</h2><p>现在之前说到过的译码器多使能端派上用场了。实际上74HC138芯片的使能端E1和E2上连接有非门，但为了方便，接下来的讨论以芯片内部信号的高低电平为准，而不会以外部信号高低来写逻辑表达式。<br><img src="/Jiahaohong/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/74HC138.png"></p><ul><li>先简单说说使能端E2和E1的特性，当总使能端E3有效时（高电平），E2和E1中任何一个接收到无效信号（低电平）都会使所有输出端输出无效信号（低电平）。  </li><li>再来看看各输出端的逻辑函数，以5号端口为例：<br>Y5 = E3 · E2 · E1 · A3 · <span style="text-decoration:overline">A2</span> · A1 =  E3 · E2 · E1 · m5  </li><li>其余端口由5号端口同理得出，通式如下：<br>Yi = E3 · E2 · E1 · mi  </li><li>现在设计使能端。将总使能端E3保持有效，E2也保持有效，E1通入要分配的信号D。那么，当信号D为高电平时，E1有效，有且仅有mi所对应的那一路输出端输出高电平（其余输出端为低电平，参看译码器真值表）；当信号D为低电平时，E1无效，所有输出端输出低电平，包括mi所对应的那一路输出端。这样就保证了mi对应的那一路输出端高低电平与输入信号D保持一致，而其他输出端一直为低电平。</li><li>两个译码器可以组成更多路输出的译码器，这种组合译码器用上述方法也同样可以做成更多路的数据分配器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将公共输入信号分配到不同通道上的逻辑电路。相当于一个单刀多掷开关。&lt;/p&gt;
&lt;h2 id=&quot;用译码器实现数据分配器&quot;&gt;&lt;a href=&quot;#用译码器实现数据分配器&quot; class=&quot;headerlink&quot; title=&quot;用译码器实现数据分配器&quot;&gt;&lt;/a&gt;用译码器实现数据分配器&lt;
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：译码器</title>
    <link href="http://github.com/Jiahaohong/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/"/>
    <id>http://github.com/Jiahaohong/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/</id>
    <published>2020-02-13T01:50:37.000Z</published>
    <updated>2020-08-27T02:22:53.897Z</updated>
    
    <content type="html"><![CDATA[<p>译码器是和编码器相对的逻辑器件，用来将经过编码的二进制代码解码成最初的信号。常用的译码器有二进制译码器，二-十进制译码器和显示译码器。</p><h2 id="译码器原理"><a href="#译码器原理" class="headerlink" title="译码器原理"></a>译码器原理</h2><ul><li><h3 id="逻辑门器件的设计方法"><a href="#逻辑门器件的设计方法" class="headerlink" title="逻辑门器件的设计方法"></a>逻辑门器件的设计方法</h3><p>  一般来说，一个逻辑门器件解决一个或一类实际的问题，我们通过对问题的分析可以得出逻辑门的输入逻辑变量和输出逻辑变量之间的逻辑表达式，再通过逻辑表达式以及逻辑运算得到符合问题要求的逻辑电路。</p></li><li><h3 id="2线4线译码器"><a href="#2线4线译码器" class="headerlink" title="2线4线译码器"></a>2线4线译码器</h3><p>  先看看这种译码器的真值表： </p><table><thead><tr><th align="center">E</th><th align="center">A1</th><th align="center">A0</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  在使能端有效的情况下，我们可以写出各个输出端的逻辑表达式，如下：<br>  Y0 = <span style="text-decoration:overline">A1</span> · <span style="text-decoration:overline">A0</span><br>  Y1 = <span style="text-decoration:overline">A1</span> · A0<br>  Y2 = A1 · <span style="text-decoration:overline">A0</span><br>  Y3 = A1 · A0<br>  不难发现，每个输出端的逻辑表达式都是输入逻辑变量的最小项。如果将使能端也考虑进去，将上述每一个输出端的逻辑表达式和使能端逻辑变量相与即可。  </p></li><li><h3 id="3线8线译码器"><a href="#3线8线译码器" class="headerlink" title="3线8线译码器"></a>3线8线译码器</h3><p>  先看看这种译码器的使能端的真值表：    </p><table><thead><tr><th align="center">E3</th><th align="center">E2</th><th align="center">E1</th><th align="center">A2</th><th align="center">A1</th><th align="center">A0</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th><th align="center">Y4</th><th align="center">Y5</th><th align="center">Y6</th><th align="center">Y7</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">X</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>  可以看出，这三个使能端中E3优先级最高，是总开关，E2和E1的功能是一样的，但是怎么用呢？  </p><p>  撇开使能端，我们单独讨论一下该译码器的真值表：  </p><table><thead><tr><th align="center">A2</th><th align="center">A1</th><th align="center">A0</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th><th align="center">Y4</th><th align="center">Y5</th><th align="center">Y6</th><th align="center">Y7</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">不难看出，输出信号端口下标（十进制）对应的二进制码就是三个输入信号组合成的二进制码，也就是3位逻辑变量的最小项，即Yi=mi。这个公式很重要，<strong>因为这让译码器除了能够翻译二进制码，还能够根据输入信号输出逻辑表达式的结果</strong>。</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li></ul><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol><li>为什么2线-4线译码器74HC139的逻辑符号中，使能端和输出端要各自连接一个非门？</li><li>为什么3线-8线译码器74HC138需要三个使能端？</li><li>如何使用74HC138和少量逻辑门实现三变量逻辑函数？</li></ol><ul><li><h3 id="关于译码器连接非门的问题"><a href="#关于译码器连接非门的问题" class="headerlink" title="关于译码器连接非门的问题"></a>关于译码器连接非门的问题</h3><p>  虽然说逻辑函数可以使用与或非三种逻辑门来实现，但是，通常情况下这些逻辑门都不是电子结构上最简单的。实际上与非门的电子结构最为简单，并且可以由与非门完成其他基本逻辑们的功能。因此，逻辑电路可能会有一些非门在输入输出端。</p></li><li><h3 id="关于译码器的多使能端的问题"><a href="#关于译码器的多使能端的问题" class="headerlink" title="关于译码器的多使能端的问题"></a>关于译码器的多使能端的问题</h3><p>  多个使能端可以拓展译码器的功能，比如之后的数据分配器和数据选择器等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;译码器是和编码器相对的逻辑器件，用来将经过编码的二进制代码解码成最初的信号。常用的译码器有二进制译码器，二-十进制译码器和显示译码器。&lt;/p&gt;
&lt;h2 id=&quot;译码器原理&quot;&gt;&lt;a href=&quot;#译码器原理&quot; class=&quot;headerlink&quot; title=&quot;译码器原理&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：编码器</title>
    <link href="http://github.com/Jiahaohong/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://github.com/Jiahaohong/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/</id>
    <published>2020-02-11T08:20:07.000Z</published>
    <updated>2020-05-18T03:09:29.512Z</updated>
    
    <content type="html"><![CDATA[<p>编码就是<strong>赋予二进制代码特殊含义</strong>的过程。 </p><p>编码器就是实现编码功能的逻辑电路。 </p><h3 id="一、普通编码器"><a href="#一、普通编码器" class="headerlink" title="一、普通编码器"></a>一、普通编码器</h3><p><em>任何时候<strong>只允许一个信号输入有效</strong>的编码器称为普通编码器。</em> </p><ul><li><p>普通编码器的名称含义<br>  如果输入信号有4位，那么输出信号只需要2位就可以表示输入信号的4种状态。这就是4线2线普通编码器。也就是说，普通编码器如果有2^n位输入信号，那么它只需要n位输出信号就可以表达输入信号的所有状态。 </p></li><li><p>普通编码器的真值表</p><table><thead><tr><th align="center">I0</th><th align="center">I1</th><th align="center">I2</th><th align="center">I3</th><th align="center">Y0</th><th align="center">Y1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  从上面4线2线普通编码器的真值表或卡诺图（Q1卡诺图是怎样的呢？）得到普通编码器的逻辑表达式如下：<br>  $Y0 = I2 + I3$<br>  $Y1 = I1 + I3$   </p></li><li><p>普通编码器的编码重叠问题<br>  结合真值表和逻辑表达式可知，普通编码器只有在<strong>有且仅有一个输入信号</strong>有效时才能正常工作，否则将会出现<strong>编码重叠</strong>的问题。比如，四个信号为0101时，也会产生11的输出，这样的话编码器之后的电路就会将0101误认为0001。由于在实际问题中，精准控制所有输入信号满足要求是十分困难的，而且这种编码重叠会造成后续电路的故障，所以为了解决编码重叠的问题，电器工程师们又发明了优先编码器。</p></li></ul><h3 id="二、优先编码器"><a href="#二、优先编码器" class="headerlink" title="二、优先编码器"></a>二、优先编码器</h3><p><em>事先规定好<strong>信号的优先级</strong>的编码器称为优先编码器。</em>  </p><ul><li><p>优先编码器的“优先”<br>  看到这你可能会问，什么是信号优先级？怎么规定信号优先级呢?</p><p>  首先来说说信号的优先级。在普通编码器中，每次输入的信号必须和事先规定的信号二进制码完全一致，逻辑门才能正确识别这个信号，但是优先编码器不同，它可以将“混合”的信号中优先级最高的那个信号识别出来并进行编码，而其他优先级低的信号对这一过程没有影响。那么什么信号是“混合”信号呢？简单来说，0001信号和1000信号混合了，那么混合信号就是1001，假如0001的优先级高于1000，那么这个混合后信号输入到编码器中，编码器会自动识别出0001信号进行编码，并且忽略1000信号。 </p><p>  那么怎么实现信号优先级的设置？或者说编码器怎么识别出信号的优先级的呢？这就要知道优先编码器的逻辑表达式是怎么设计的了。</p></li><li><p>优先编码器的真值表  </p><table><thead><tr><th align="center">I0</th><th align="center">I1</th><th align="center">I2</th><th align="center">I3</th><th align="center">Y0</th><th align="center">Y1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">x</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">1</td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  和普通编码器的真值表对照一下就可以发现，优先编码器的有些输入信号为有效时，不论其他信号是否有效（画x的信号），输出结果总是一样的，这种不会被其他信号干扰其输出的信号就叫做高优先级信号，而输出会被其他信号干扰的信号叫做低优先级信号。前面的高低优先级都是相对概念。（Q2你能看出这个编码器输入信号的优先级吗？）  </p><p>  同样的，分别根据Y0和Y1的卡诺图可以求出它们的逻辑表达式，如下：<br>  $Y0 = I2 + I3$<br>  $Y1 = I1 · \overline{I2} + I3$  </p><p>  从逻辑表达式可以知道，优先编码器并不是具有什么智慧才能够分辨不同的输入信号，“优先级”实际上是逻辑门的组合而产生的效果。接下来我们使用简单的logism软件来设计一下4线2线优先编码器。</p></li></ul><h3 id="三、Logism之优先编码器"><a href="#三、Logism之优先编码器" class="headerlink" title="三、Logism之优先编码器"></a>三、Logism之优先编码器</h3><ul><li><p>简单实现<br>  分析逻辑表达式，有四个输入端和两个输出端，一个非门、一个与门和两个或门，组装后结果如下：  </p>  <img src="/Jiahaohong/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism1.png">  </li><li><p>逻辑门优化<br>  由于逻辑门的具体实现中，电路基本上由同一种逻辑门组成，因此我们考虑将上述基本逻辑门改成与非门。</p><p>  一般将电路图中的逻辑门换成与非门（或非门也可）有两种思路，第一种通过将基本逻辑电路改写成与非门组成的逻辑电路单元，再用这些单元替换原电路中的逻辑门；第二种是从逻辑表达式入手，通过摩根定理将逻辑表达式全部换成与非表达式（或非表达式）。通常情况下，第二种方法更为简便快捷，且设计出来的电路效率更高。</p><p>  我们对逻辑表达式取两次非运算，得到变换后的逻辑表达式如下：<br>  $Y0=\overline{\overline{I2}·\overline{I3}}$<br>  $Y1=\overline{\overline{I1·\overline{I2}}·\overline{T3}}$<br>  Logism效果图如下：  </p>  <img src="/Jiahaohong/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism2.png">   </li><li><p>功能修正<br>  实际上，这样的电路功能是不完善的，甚至在某些情况下是错误的、危险的。现在考虑输入端信号为0000的情况，这时候根据逻辑表达式，输出应该为00，但是这和输入端信号为1000时的输出是相同的，这就产生了编码重叠的问题。为了解决这个问题，我们需要对输入端信号是否时有效的来进行判断，即新增一个输出端，所有输入端均为无效状态（0）时，新增输出端输出为无效（0），当任何一个输入端信号为有效（1）时，新增输出端也有效（1）。那么，新增的输出信号应该为所有输入信号的“或”即$E=I0+I1+I2+I3$，但是由于只提供与非门，所以根据摩根定理，该输出端的逻辑表达式转换成与非表达式$E=\overline{\overline{I0}·\overline{I1}·\overline{I2}·\overline{I3}}$，这样就可以只用与非门实现该输出端的功能了。改进后的电路如下：  </p>  <img src="/Jiahaohong/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism3.png"></li><li><p>功能拓展<br>  实际生产的逻辑器件中，上述这种器件的可拓展性比较差，因为其缺少相应的使能端，就比如真正的8线3线优先编码器就有3个使能端、1个额外的输出端（标记编码器是否在正常工作），这样这个器件就可以很好地和其他器件进行信息的传递，从而达到组合器件实现更复杂功能的效果。我们的4线2线优先编码器该如何改进呢？请读者思考一下吧！</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编码就是&lt;strong&gt;赋予二进制代码特殊含义&lt;/strong&gt;的过程。 &lt;/p&gt;
&lt;p&gt;编码器就是实现编码功能的逻辑电路。 &lt;/p&gt;
&lt;h3 id=&quot;一、普通编码器&quot;&gt;&lt;a href=&quot;#一、普通编码器&quot; class=&quot;headerlink&quot; title=&quot;一、普通编码器
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://github.com/Jiahaohong/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
</feed>
