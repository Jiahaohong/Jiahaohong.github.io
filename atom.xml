<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darcy&#39;s Blog</title>
  
  <subtitle>Shy first Intimate later Friendly forever!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://39.106.115.216/"/>
  <updated>2020-04-07T11:18:21.974Z</updated>
  <id>http://39.106.115.216/</id>
  
  <author>
    <name>Darcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库：SQL</title>
    <link href="http://39.106.115.216/2020/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9ASQL/"/>
    <id>http://39.106.115.216/2020/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9ASQL/</id>
    <published>2020-04-07T11:12:24.000Z</published>
    <updated>2020-04-07T11:18:21.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ol><li>定义模式<br>CREATE SHEMA <SHEMANAME> AUTHORIZATION <USERNAME><br>注意：如果模式名缺省，则模式名默认和用户名一样。</USERNAME></SHEMANAME></li><li>删除模式<br>DROP SHEMA <SHEMANAME> &lt;CASCADE|RESRTICT&gt;<ul><li>CASCADE(级联)<br>删除模式的同时把该模式中所有数据库对象全部删除 </li></ul></SHEMANAME></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据定义&quot;&gt;&lt;a href=&quot;#数据定义&quot; class=&quot;headerlink&quot; title=&quot;数据定义&quot;&gt;&lt;/a&gt;数据定义&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;定义模式&lt;br&gt;CREATE SHEMA &lt;SHEMANAME&gt; AUTHORIZATION &lt;USERNAME
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://39.106.115.216/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：什么是范式？（下）</title>
    <link href="http://39.106.115.216/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://39.106.115.216/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-26T08:02:04.000Z</published>
    <updated>2020-03-31T08:44:52.230Z</updated>
    
    <content type="html"><![CDATA[<p><em>范式的规定随着序号的增加而逐渐严格，序号大的范式一定满足序号小的范式的要求</em></p><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><em><strong>属性不可分</strong></em><br>这是最简单也是最基础的范式，<strong>所有关系模型</strong>必须满足这个范式。这个定义已经十分清晰明了了，即在实际情况中，我们选取的关系模型的属性必须具有原子性，不可分性，但是同时又不必过于细致，能够满足实际应用要求即可。</p><p><em>接下来的范式定义就逐渐晦涩难懂了，我会采用实际例子来辅助理解</em></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p><em><strong>所有非主属性完全依赖于任意一个键码</strong></em><br>在这里我们要重点关注一个词：完全。什么样的依赖从才能说是完全依赖呢？我们看看下面这个图书馆借书登记的例子。  </p><table><thead><tr><th align="center">Name</th><th align="center">Title</th><th align="center">Date</th><th align="center">Domitory</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Pride And Prejudice</td><td align="center">2020/3/26</td><td align="center">Domitory A</td></tr><tr><td align="center">Lucy</td><td align="center">Jane Eyre</td><td align="center">2020/1/18</td><td align="center">Domitory B</td></tr></tbody></table><p>在这个借书信息关系表中，我们可以<strong>通过生活实际</strong>得出如下的函数依赖关系：Name Title-&gt;Date和Name-&gt;Domitory。通过<strong>闭包</strong>，我们可以求出关系表的键码为{Name，Title}，Date这个属性是通过这个键码确定的，但是Domitory这个属性是通过这个<strong>键码的子集</strong>{Name}确定的，因此这个关系表不符合第二范式。<br>这时候只要选择一个函数依赖分离出一个新的关系表就可以解决这个问题。比如选择函数依赖Name-&gt;Domitory分离出第一个表：  </p><table><thead><tr><th align="center">Name</th><th align="center">Domitory</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Domitory A</td></tr><tr><td align="center">Lucy</td><td align="center">Domitory B</td></tr></tbody></table><p><strong>剩下的属性集</strong>作为第二个表：  </p><table><thead><tr><th align="center">Name</th><th align="center">Title</th><th align="center">Date</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Pride And Prejudice</td><td align="center">2020/3/26</td></tr><tr><td align="center">Lucy</td><td align="center">Jane Eyre</td><td align="center">2020/1/18</td></tr></tbody></table><p>这样两个表就都符合第二范式了。当然，实际问题可能更加复杂，比如上面第二个表分离出来后还是不符合第二范式，那么就要根据别的函数依赖继续分离第二个表。</p><p>需要注意的是，第二范式并不要求非主属性直接依赖于同一个键码，但是非主属性一定能够通过某种函数传递而依赖于同一个键码。看上去挺绕的是不是？我们来看一个例子：  </p><table><thead><tr><th align="center">Name</th><th align="center">Domitory</th><th align="center">DomitoryManagement</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Domitory A</td><td align="center">Uncle Ben</td></tr><tr><td align="center">Lucy</td><td align="center">Domitory B</td><td align="center">Aunt Jenny</td></tr></tbody></table><p>在这个关系表中，DomitoryManagement不直接依赖于键码{Name}，但是它依赖于Domitory，并且Domitory依赖于键码{Name}，这是一个传递依赖，所以符合第二范式。这一点是区分第二范式和第三范式的关键，因为第三范式要求不能有传递依赖。</p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><em><strong>如果对于关系R中的任何非平凡依赖A1A2…An-&gt;B，它们满 足条件：或者A1A2…An是超键码，或者B是某个键码的组成部分，则关系R满足第三范式</strong></em></p><h2 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h2><h2 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;范式的规定随着序号的增加而逐渐严格，序号大的范式一定满足序号小的范式的要求&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一范式&quot;&gt;&lt;a href=&quot;#第一范式&quot; class=&quot;headerlink&quot; title=&quot;第一范式&quot;&gt;&lt;/a&gt;第一范式&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;str
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://39.106.115.216/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：什么是范式（上）？</title>
    <link href="http://39.106.115.216/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://39.106.115.216/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-03-24T13:00:35.000Z</published>
    <updated>2020-03-30T06:11:51.682Z</updated>
    
    <content type="html"><![CDATA[<p>在细致讨论关系数据库的范式之前，我们要理解几个重要概念。</p><h2 id="关系的键码"><a href="#关系的键码" class="headerlink" title="关系的键码"></a>关系的键码</h2><h3 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h3><p>一个关系表的键码满足如下条件：</p><ol><li>键码是该关系表中的一个<strong>属性</strong>或<strong>多个属性的集合</strong></li><li>由给定的键码可以确定该关系的所有属性</li><li>键码的任何<strong>真子集</strong>都不能确定该关系的所有属性</li></ol><p>看上去有点绕？没关系，看看下面的栗子就明白了。</p><blockquote><p>1号栗子</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Gender</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">18</td></tr><tr><td align="center">002</td><td align="center">Jessica</td><td align="center">Female</td><td align="center">18</td></tr><tr><td align="center">003</td><td align="center">Lucy</td><td align="center">Female</td><td align="center">17</td></tr><tr><td align="center">004</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">17</td></tr></tbody></table><p>1号栗子中有四个属性，如果你只知道后面三个属性中的任何一个的内容，你都无法确定这个属性是谁的。比如告诉你这个人18岁，问他叫什么名字？再比如告诉你这个人叫Darcy，问他几岁？<br>同样的，如果你知道后面三个属性中的任何两个，你也是无法确定这个人的其他信息的。比如告诉你这个人叫Darcy，Male，问你他几岁？<br>但是如果你同时知道后面这三个属性的内容，那么你就可以在这个表中唯一确定一个人了！比如告诉你这个人叫Darcy，性别Male，年龄17，那么查表你就知道这个人是004号而不是001号。那么这三个属性就可以作为这个表的键码，写成这样{Name，Gender，Age}。<br>聪明的你发现，直接告诉我一个人的ID不就好了？的确如此，ID属性也是这个表的一个键码，这也说明一个关系表中的键码可以有多个，而且每个键码的优劣也有区别，这里不做讨论。</p></blockquote><p>综上所述，一个关系表的键码其实没有多神秘，它也是属性（属性集），只不过它比较特别，它可以帮你找到这个表中的其他属性。而且这样热心的属性（属性集）在一个表中可能会有多个。</p><h3 id="超键码"><a href="#超键码" class="headerlink" title="超键码"></a>超键码</h3><p>一个表中的键码加上其他0个或多个非键码属性构成的属性集合就是超键码。</p><blockquote><p>还是1号栗子<br>如果该表的键码{ID}加上Age属性，那么新的属性集合{ID，Age}就构成了一个超键码。</p></blockquote><p>注意咯，键码一定是超键码，但是超键码不一定是键码。</p><h3 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h3><p>如果一个属性是任意键码的子集，那么这个属性是主属性。<br>如果一个属性不是任何键码的子集，那么这个属性是非主属性。</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="什么是函数依赖？"><a href="#什么是函数依赖？" class="headerlink" title="什么是函数依赖？"></a>什么是函数依赖？</h3><p>简单理解为：如果已知属性A1和属性A2就一定可以推出属性B，那么称函数A1，A2决定B，并且记作A1A2-&gt;B。其中属性A1和A2可以更多。<br><del>数学理解为：一个函数依赖（函数）将定义属性集（定义域）映射到值属性集（值域）。这是我瞎写的。</del></p><blockquote><p>下面再次有请我们的1号栗子</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Gender</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">18</td></tr><tr><td align="center">002</td><td align="center">Jessica</td><td align="center">Female</td><td align="center">18</td></tr><tr><td align="center">003</td><td align="center">Lucy</td><td align="center">Female</td><td align="center">17</td></tr><tr><td align="center">004</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">17</td></tr></tbody></table><p>由键码的分析可以看到，从属性集ID可以推知属性集Name、Gender、Age，那么这就构成了一个函数依赖，写为ID-&gt;Name Gender Age。</p></blockquote><h3 id="函数依赖的分类"><a href="#函数依赖的分类" class="headerlink" title="函数依赖的分类"></a>函数依赖的分类</h3><p>下面将函数依赖简记为{A}-&gt;{B}，其中{A}和{B}都是属性集。</p><ul><li>平凡依赖<br>B是A的子集。<br><del>这个函数依赖很差劲，它不能告诉我们任何它没有的信息。</del></li><li>非平凡依赖<br>B不是A的子集，但B和A的交集不为空。<br><del>这个函数依赖还是有点用的，至少告诉了我们一些其他信息。</del></li><li>完全非平凡依赖<br>B和A的交集为空<br><del>Amazing！这个函数依赖告诉了我们全新的东西！</del></li></ul><h3 id="函数依赖的运算规则"><a href="#函数依赖的运算规则" class="headerlink" title="函数依赖的运算规则"></a>函数依赖的运算规则</h3><ul><li>分解规则<br>A1A2…An-&gt;B1B2…Bm等价于A1A2…An-&gt;Bi(i=1,2,…,m),即将一个函数依赖分解成为一组函数依赖。</li><li>合并规则<br>A1A2…An-&gt;Bi(i=1,2,…,m)等价于A1A2…An-&gt;B1B2…Bm，即将一组函数依赖合成为一个函数依赖，是分解规则的逆运算。</li><li>平凡依赖规则<br>A1A2…An-&gt;B1B2…Bm等价于A1A2…An-&gt;C1C2…Ck，其中C属于B但不属于A，即将B中和A相同的属性去掉，剩下的属性构成新的集合C还是满足原来的函数依赖。</li><li>增长规则<br>如果A1A2…An-&gt;B1B2…Bm，则对于任何属性集 C1C2…Ck，A1A2…An C1C2…Ck-&gt;B1B2…Bm C1C2…Ck,即平凡依赖规则的逆运算。</li><li>传递规则<br>若函数依赖A-&gt;B和B-&gt;C在关系R中成立,则函数依赖A-&gt;C在关系R中也成立.</li></ul><h2 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>准确的定义：首先我们有一个属性集A{A1，A2，···，An}，然后我们又有了一个函数依赖集S{S1，S2，···，Sn}，至此我们就能够通过函数依赖集中的函数依赖，确定属性集A能够决定的属性集B，称为属性集A的闭包，并记为{A1，A2，···，An}+。<br>通过上述闭包的定义，我们知道要确定一个闭包必须知道两个缺一不可的信息，一是原来的属性集，二是给定的函数依赖集。如果属性集改变，或者函数依赖集改变，都会改变闭包最终包含的属性。<br><del>数学的定义：给定一系列函数Si，将定义域A映射到值域Bi，那么Bi的集合就是定义域A的闭包。</del></p><h3 id="闭包的计算"><a href="#闭包的计算" class="headerlink" title="闭包的计算"></a>闭包的计算</h3><blockquote><p>2号栗子登场<br>给定属性集{A，B，C}和函数依赖集{AB-&gt;D，C-&gt;E}，求{A，B，C}+？<br>计算方法：选取一个函数依赖，作用于属性集上，去掉这个函数依赖，并将原来的属性集更新为新的属性集，再次选取一个函数依赖，重复此步骤，直到函数依赖集为空或者余下的所有函数依赖都无法作用于当前属性集，那么当前的属性集就是原属性集的闭包。<br>X = {A，B，C}<br>选AB-&gt;D作用于X<br>X = {A，B，C，D}<br>选C-&gt;E作用于X<br>X = {A，B，C，D，E}<br>此时函数依赖集为空，得到闭包{A，B，C，D，E}</p></blockquote><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul><li>检验一个属性集是否为关系的键码</li><li>检验一个函数依赖是否蕴含于函数依赖集</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在细致讨论关系数据库的范式之前，我们要理解几个重要概念。&lt;/p&gt;
&lt;h2 id=&quot;关系的键码&quot;&gt;&lt;a href=&quot;#关系的键码&quot; class=&quot;headerlink&quot; title=&quot;关系的键码&quot;&gt;&lt;/a&gt;关系的键码&lt;/h2&gt;&lt;h3 id=&quot;键码&quot;&gt;&lt;a href=&quot;#键码&quot;
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://39.106.115.216/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：E-R图</title>
    <link href="http://39.106.115.216/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AE-R%E5%9B%BE/"/>
    <id>http://39.106.115.216/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AE-R%E5%9B%BE/</id>
    <published>2020-03-12T12:11:32.000Z</published>
    <updated>2020-03-12T13:29:17.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ER图三要素"><a href="#ER图三要素" class="headerlink" title="ER图三要素"></a>ER图三要素</h2><ul><li>实体集<br>具有相同特性的同一类事物的集合，矩形表示。</li><li>属性<br>描述实体摸个特性的值，椭圆形表示。</li><li>联系<br>两个或多个实体集之间的联系，菱形表示。</li></ul><h2 id="联系的多重性"><a href="#联系的多重性" class="headerlink" title="联系的多重性"></a>联系的多重性</h2><ul><li>一对一联系，双边箭头。</li><li>一对多联系，从一指向多的箭头。</li><li>多对多联系，不加箭头。  <h3 id="如何判断两个实体集之间的联系的多重性？"><a href="#如何判断两个实体集之间的联系的多重性？" class="headerlink" title="如何判断两个实体集之间的联系的多重性？"></a>如何判断两个实体集之间的联系的多重性？</h3>如果从某个实体集A中的一个实体a出发，经过一个联系，只有另一个实体集B中唯一的一个实体b与之对应，则从A经过联系指向实体集B的连线应该加箭头。</li></ul><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>ER图中的联系可以涉及多个实体，这是ODL中所不具备的。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>键码<br>在实体集中，唯一标识一个实体的属性或属性集。用下划线表示某些属性或属性集构成了键码。注意，键码本质上也是属性。</li><li>参照完整性约束  <ol><li>必须是多对一或一对一联系。</li><li>R是从实体集E到实体集F的联系，如果若E中的一个实体e存在，那么与之对应的实体f必须存在。</li></ol></li></ul><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>如果实体集C具有实体集D的全部属性和联系，并且还拥有一些其他的属性，那么称实体集C是实体集D的子类。用等腰三角形链接超类（可以理解为父类）和子类，顶点指向超类。</p><h3 id="ODL子类和ER图子类的区别"><a href="#ODL子类和ER图子类的区别" class="headerlink" title="ODL子类和ER图子类的区别"></a>ODL子类和ER图子类的区别</h3><ul><li>ODL的子类必须是同一个类的部分成员。</li><li>ER图的实体可以属于多个实体集。</li><li>ODL子类类似Java，ER图子类类似C++。</li></ul><h2 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h2><p>如果实体集C的<strong>键码</strong>中的一些或全部属于实体集D，那么实体集C为实体集D的弱实体集。用双边矩形表示弱实体集，用双边菱形表示实体集C和D的联系。</p><h3 id="如何理解弱实体集"><a href="#如何理解弱实体集" class="headerlink" title="如何理解弱实体集"></a>如何理解弱实体集</h3><ul><li>层次结构<br>在现实世界中的弱实体集E依赖于提供给他键码的实体集F，没有实体集F，就不能确定实体集E。</li><li>连接实体集</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ER图三要素&quot;&gt;&lt;a href=&quot;#ER图三要素&quot; class=&quot;headerlink&quot; title=&quot;ER图三要素&quot;&gt;&lt;/a&gt;ER图三要素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实体集&lt;br&gt;具有相同特性的同一类事物的集合，矩形表示。&lt;/li&gt;
&lt;li&gt;属性&lt;br&gt;描述实体
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://39.106.115.216/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>git指令大全</title>
    <link href="http://39.106.115.216/2020/03/09/git%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://39.106.115.216/2020/03/09/git%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2020-03-08T23:56:00.000Z</published>
    <updated>2020-03-24T13:34:43.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件操作指令"><a href="#文件操作指令" class="headerlink" title="文件操作指令"></a>文件操作指令</h2><ul><li><p>进入指定文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd c:mygit&#x2F;project1</span><br></pre></td></tr></table></figure></li><li><p>进入上层文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure></li><li><p>进入根目录文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure></li><li><p>显示当前文件夹路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure></li><li><p>显示当前文件夹里的文件和文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹下创建文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir project2</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹下创建文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch readme.txt</span><br><span class="line">touch gitCommand.md</span><br></pre></td></tr></table></figure><p>将上述指令结合起来使用，你就可以非常方便的解决一些文件操作的小问题了。比如进入某个文件夹，新建一个子文件夹用来存放自己的markdown笔记，就可以在gitbash里输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd f: &amp;&amp; mkdir myNotes &amp;&amp; touch gitNote1.md</span><br></pre></td></tr></table></figure><h2 id="git操作指令"><a href="#git操作指令" class="headerlink" title="git操作指令"></a>git操作指令</h2></li><li><p>创建git仓库（初始化）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件操作指令&quot;&gt;&lt;a href=&quot;#文件操作指令&quot; class=&quot;headerlink&quot; title=&quot;文件操作指令&quot;&gt;&lt;/a&gt;文件操作指令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进入指定文件夹&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Git" scheme="http://39.106.115.216/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：数据分配器</title>
    <link href="http://39.106.115.216/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://39.106.115.216/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/</id>
    <published>2020-02-14T02:07:15.000Z</published>
    <updated>2020-02-14T03:47:16.631Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="什么是数据分配器"><a href="#什么是数据分配器" class="headerlink" title="什么是数据分配器"></a>什么是数据分配器</h3><p>  将公共输入信号分配到不同通道上的逻辑电路。</p></li><li><h3 id="用译码器实现数据分配器"><a href="#用译码器实现数据分配器" class="headerlink" title="用译码器实现数据分配器"></a>用译码器实现数据分配器</h3><p>  现在之前说到过的译码器多使能端派上用场了。   </p><ul><li>先简单说说使能端E2和E1的特性，当总使能端E3有效时（高电平），E2和E1中任何一个接收到无效信号（低电平）都会使所有输出端输出无效信号（低电平）。  </li><li>再来看看各输出端的逻辑函数：<br>Y5 = E3 · E2 · E1 · A3 · <span style="text-decoration:overline">A2</span> · A1 =  E3 · E2 · E1 · m5  </li><li>其余端口由5号端口同理得出，通式如下：<br>Yi = E3 · E2 · E1 · mi  </li><li>现在设计使能端。将总使能端E3保持有效，E2也保持有效，E1通入要分配的信号D。那么，当信号D为高电平时，E1有效，有且仅有mi所对应的那一路输出端输出高电平（其余输出端为低电平，参看译码器真值表）；当信号D为低电平时，E1无效，所有输出端输出低电平，包括mi所对应的那一路输出端。这样就保证了mi对应的那一路输出端高低电平与输入信号D保持一致，而其他输出端一直为低电平。</li><li>两个译码器可以组成更多路输出的译码器，这种组合译码器用上述方法也同样可以做成更多路的数据分配器。</li></ul></li><li><h3 id="用逻辑门实现数据分配器"><a href="#用逻辑门实现数据分配器" class="headerlink" title="用逻辑门实现数据分配器"></a>用逻辑门实现数据分配器</h3><ul><li>先来介绍三态门。三态门有一个输入端，一个输出端，和一个使能端，当使能端有效时，三态门输出和输入相同；当使能端无效时，三态门输出为高阻态。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是数据分配器&quot;&gt;&lt;a href=&quot;#什么是数据分配器&quot; class=&quot;headerlink&quot; title=&quot;什么是数据分配器&quot;&gt;&lt;/a&gt;什么是数据分配器&lt;/h3&gt;&lt;p&gt;  将公共输入信号分配到不同通道上的逻辑电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：译码器</title>
    <link href="http://39.106.115.216/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/"/>
    <id>http://39.106.115.216/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/</id>
    <published>2020-02-13T01:50:37.000Z</published>
    <updated>2020-04-13T01:55:22.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是译码器"><a href="#什么是译码器" class="headerlink" title="什么是译码器"></a>什么是译码器</h2><p>译码器是和编码器相对的逻辑器件，用来将经过编码器编码的二进制代码解码成最初的信号。常用的译码器有二进制译码器，二-十进制译码器和显示译码器。</p><h2 id="译码器原理"><a href="#译码器原理" class="headerlink" title="译码器原理"></a>译码器原理</h2><ul><li><h3 id="逻辑门器件的设计方法"><a href="#逻辑门器件的设计方法" class="headerlink" title="逻辑门器件的设计方法"></a>逻辑门器件的设计方法</h3><p>  一般来说，一个逻辑门器件解决一个或一类实际的问题，我们通过对问题的分析可以得出逻辑门的输入逻辑变量和输出逻辑变量之间的逻辑表达式，再通过逻辑表达式以及逻辑运算得到符合问题要求的逻辑电路。</p></li><li><h3 id="2线4线译码器"><a href="#2线4线译码器" class="headerlink" title="2线4线译码器"></a>2线4线译码器</h3><p>  先看看这种译码器的真值表： </p><table><thead><tr><th align="center">E</th><th align="center">A1</th><th align="center">A0</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  在使能端有效的情况下，我们可以写出各个输出端的逻辑表达式，如下：<br>  Y0 = <span style="text-decoration:overline">A1</span> · <span style="text-decoration:overline">A0</span><br>  Y1 = <span style="text-decoration:overline">A1</span> · A0<br>  Y2 = A1 · <span style="text-decoration:overline">A0</span><br>  Y3 = A1 · A0<br>  不难发现，每个输出端的逻辑表达式都是输入逻辑变量的最小项。如果将使能端也考虑进去，将上述每一个输出端的逻辑表达式和使能端逻辑变量相与即可。  </p></li><li><h3 id="3线8线译码器"><a href="#3线8线译码器" class="headerlink" title="3线8线译码器"></a>3线8线译码器</h3><p>  先看看这种译码器的使能端的真值表：    </p><table><thead><tr><th align="center">E3</th><th align="center">E2</th><th align="center">E1</th><th align="center">A3</th><th align="center">A2</th><th align="center">A1</th><th align="center">Y0</th><th align="center">Y1</th><th align="center">Y2</th><th align="center">Y3</th><th align="center">Y4</th><th align="center">Y5</th><th align="center">Y6</th><th align="center">Y7</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">X</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>  可以看出，这三个使能端中E3优先级最高，是总开关，E2和E1的功能是一样的，但是怎么用呢？</p></li></ul><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol><li>为什么2线-4线译码器74HC139的逻辑符号中，使能端和输出端要各自连接一个非门？</li><li>为什么3线-8线译码器74HC138需要三个使能端？</li><li>如何使用74HC138和少量逻辑门实现三变量逻辑函数？</li></ol><ul><li><h3 id="关于译码器连接非门的问题"><a href="#关于译码器连接非门的问题" class="headerlink" title="关于译码器连接非门的问题"></a>关于译码器连接非门的问题</h3><p>  虽然说逻辑函数可以使用与或非三种逻辑门来实现，但是，通常情况下这些逻辑门都不是结构上最简单的。实际上与非门的结构最为简单，并且可以由与非门完成其他基本逻辑们的功能。因此，逻辑电路可能会有一些非门在输入输出端。</p></li><li><h3 id="关于译码器的多使能端的问题"><a href="#关于译码器的多使能端的问题" class="headerlink" title="关于译码器的多使能端的问题"></a>关于译码器的多使能端的问题</h3><p>  多个使能端可以拓展译码器的功能，比如之后的数据分配器和数据选择器等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是译码器&quot;&gt;&lt;a href=&quot;#什么是译码器&quot; class=&quot;headerlink&quot; title=&quot;什么是译码器&quot;&gt;&lt;/a&gt;什么是译码器&lt;/h2&gt;&lt;p&gt;译码器是和编码器相对的逻辑器件，用来将经过编码器编码的二进制代码解码成最初的信号。常用的译码器有二进制译码器
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：编码器</title>
    <link href="http://39.106.115.216/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://39.106.115.216/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/</id>
    <published>2020-02-11T08:20:07.000Z</published>
    <updated>2020-04-13T01:10:03.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是编码，什么是编码器"><a href="#什么是编码，什么是编码器" class="headerlink" title="什么是编码，什么是编码器"></a>什么是编码，什么是编码器</h2><p>编码就是<strong>赋予二进制代码特殊含义</strong>的过程。 </p><p>编码器就是实现编码功能的逻辑电路。 </p><h2 id="普通编码器"><a href="#普通编码器" class="headerlink" title="普通编码器"></a>普通编码器</h2><p><em>任何时候<strong>只允许一个信号输入有效</strong>的编码器称为普通编码器。</em> </p><ul><li><h3 id="普通编码器的名称含义"><a href="#普通编码器的名称含义" class="headerlink" title="普通编码器的名称含义"></a>普通编码器的名称含义</h3><p>  如果输入信号有4个，那么输出信号只需要2个就可以表示输入信号的4种状态。这就是4线2线普通编码器。也就是说，普通编码器如果有2^n个输入信号，那么它只需要n个输出信号就可以表达输入信号的所有状态。 </p></li><li><h3 id="普通编码器的真值表"><a href="#普通编码器的真值表" class="headerlink" title="普通编码器的真值表"></a>普通编码器的真值表</h3><table><thead><tr><th align="center">I0</th><th align="center">I1</th><th align="center">I2</th><th align="center">I3</th><th align="center">Y0</th><th align="center">Y1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  从上面4线2线普通编码器的真值表或卡诺图（Q1卡诺图是怎样的呢？）得到普通编码器的逻辑表达式如下：<br>  $Y0 = I2 + I3$<br>  $Y1 = I1 + I3$   </p></li><li><h3 id="普通编码器的编码重叠问题"><a href="#普通编码器的编码重叠问题" class="headerlink" title="普通编码器的编码重叠问题"></a>普通编码器的编码重叠问题</h3><p>  结合真值表和逻辑表达式可知，普通编码器只有在<strong>有且仅有一个输入信号</strong>有效时才能正常工作，否则将会出现<strong>编码重叠</strong>的问题。比如，四个信号为0101时，也会产生11的输出，这样的话编码器之后的电路就会将0101误认为0001。由于在实际问题中，精准控制所有输入信号满足要求是十分困难的，而且这种编码重叠会造成后续电路的故障，所以为了解决编码重叠的问题，电器工程师们又发明了优先编码器。</p></li></ul><h2 id="优先编码器"><a href="#优先编码器" class="headerlink" title="优先编码器"></a>优先编码器</h2><p><em>事先规定好<strong>信号的优先级</strong>的编码器称为优先编码器。</em>  </p><ul><li><h3 id="优先编码器的“优先”"><a href="#优先编码器的“优先”" class="headerlink" title="优先编码器的“优先”"></a>优先编码器的“优先”</h3><p>  看到这你可能会问，什么是信号优先级？怎么规定信号优先级呢?<br>  首先来说说信号的优先级。在普通编码器中，每次输入的信号必须和事先规定的信号二进制码完全一致，逻辑门才能正确识别这个信号，但是优先编码器不同，它可以将“混合”的信号中优先级最高的那个信号识别出来并进行编码，而其他优先级低的信号对这一过程没有影响。那么什么信号是“混合”信号呢？简单来说，0001信号和1000信号混合了，那么混合信号就是1001，假如0001的优先级高于1000，那么这个混合后信号输入到编码器中，编码器会自动识别出0001信号进行编码，并且忽略1000信号，。<br>  那么怎么实现信号优先级的设置？或者说编码器怎么识别出信号的优先级的呢？这就要知道优先编码器的逻辑表达式是怎么设计的了。</p></li><li><h3 id="优先编码器的真值表"><a href="#优先编码器的真值表" class="headerlink" title="优先编码器的真值表"></a>优先编码器的真值表</h3><table><thead><tr><th align="center">I0</th><th align="center">I1</th><th align="center">I2</th><th align="center">I3</th><th align="center">Y0</th><th align="center">Y1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">x</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">1</td><td align="center">0</td><td align="center"><strong>1</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">1</td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>  和普通编码器的真值表对照一下就可以发现，优先编码器的有些输入信号为有效时，不论其他信号是否有效，输出结果总是一样的，这种不会被其他信号干扰其输出的信号就叫做高优先级信号，而输出会被其他信号干扰的信号叫做低优先级信号。前面的高低优先级都是相对概念。（Q2你能看出这个编码器输入信号的优先级吗？）  </p><p>  同样的，分别根据Y0和Y1的卡诺图可以求出它们的逻辑表达式，如下：<br>  $Y0 = I2 + I3$<br>  $Y1 = I1 · \overline{I2} + I3$  </p><p>  从逻辑表达式可以知道，优先编码器并不是具有什么智慧才能够分辨不同的输入信号，“优先级”实际上是逻辑门的组合而产生的效果。接下来我们使用简单的logism软件来设计一下4线2线优先编码器。</p></li></ul><h2 id="Logism之优先编码器"><a href="#Logism之优先编码器" class="headerlink" title="Logism之优先编码器"></a>Logism之优先编码器</h2><ul><li><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>  分析逻辑表达式，有四个输入端和两个输出端，一个非门、一个与门和两个或门，组装后结果如下：  </p>  <img src="/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism1.png">  </li><li><h3 id="逻辑门优化"><a href="#逻辑门优化" class="headerlink" title="逻辑门优化"></a>逻辑门优化</h3><p>  由于逻辑门的具体实现中，电路基本上由同一种逻辑门组成，因此我们考虑将上述基本逻辑门改成与非门。</p><p>  一般将电路图中的逻辑门换成与非门（或非门也可）有两种思路，第一种通过将基本逻辑电路改写成与非门组成的逻辑电路单元，再用这些单元替换原电路中的逻辑门；第二种是从逻辑表达式入手，通过摩根定理将逻辑表达式全部换成与非表达式（或非表达式）。通常情况下，第二种方法更为简便快捷，且设计出来的电路效率更高。</p><p>  我们对逻辑表达式取两次非运算，得到变换后的逻辑表达式如下：<br>  $Y0=\overline{\overline{I2}·\overline{I3}}$<br>  $Y1=\overline{\overline{I1·\overline{I2}}·\overline{T3}}$<br>  Logism效果图如下：  </p>  <img src="/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism2.png">   </li><li><h3 id="功能修正"><a href="#功能修正" class="headerlink" title="功能修正"></a>功能修正</h3><p>  实际上，这样的电路功能是不完善的，甚至在某些情况下是错误的、危险的。现在考虑输入端信号为0000的情况，这时候根据逻辑表达式，输出应该为00，但是这和输入端信号为1000时的输出是相同的，这就产生了编码重叠的问题。为了解决这个问题，我们需要对输入端信号是否时有效的来进行判断，即新增一个输出端，所有输入端均为无效状态（0）时，新增输出端输出为无效（0），当任何一个输入端信号为有效（1）时，新增输出端也有效（1）。那么，新增的输出信号应该为所有输入信号的“或”即$E=I0+I1+I2+I3$，但是由于只提供与非门，所以根据摩根定理，该输出端的逻辑表达式转换成与非表达式$E=\overline{\overline{I0}·\overline{I1}·\overline{I2}·\overline{I3}}$，这样就可以只用与非门实现该输出端的功能了。改进后的电路如下：  </p>  <img src="/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/logism3.png"></li><li><h3 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h3><p>  实际生产的逻辑器件中，上述这种器件的可拓展性比较差，因为其缺少相应的使能端，就比如真正的8线3线优先编码器就有3个使能端、1个额外的输出端（标记编码器是否在正常工作），这样这个器件就可以很好地和其他器件进行信息的传递，从而达到组合器件实现更复杂功能的效果。我们的4线2线优先编码器该如何改进呢？请读者思考一下吧！</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是编码，什么是编码器&quot;&gt;&lt;a href=&quot;#什么是编码，什么是编码器&quot; class=&quot;headerlink&quot; title=&quot;什么是编码，什么是编码器&quot;&gt;&lt;/a&gt;什么是编码，什么是编码器&lt;/h2&gt;&lt;p&gt;编码就是&lt;strong&gt;赋予二进制代码特殊含义&lt;/stron
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：卡诺图（2）</title>
    <link href="http://39.106.115.216/2020/02/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%882%EF%BC%89/"/>
    <id>http://39.106.115.216/2020/02/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%882%EF%BC%89/</id>
    <published>2020-02-09T08:53:34.000Z</published>
    <updated>2020-03-20T06:22:53.409Z</updated>
    
    <content type="html"><![CDATA[<p><em>由上篇知道，卡诺图是一个将最小项按二维格雷码的形式排布的表格，每个格子对应着一个最小项，那么卡诺图怎么使用呢？</em></p><ul><li><h3 id="什么是逻辑函数的卡诺图"><a href="#什么是逻辑函数的卡诺图" class="headerlink" title="什么是逻辑函数的卡诺图"></a>什么是逻辑函数的卡诺图</h3><p>  逻辑函数的卡诺图每一个格子不仅对应着一个最小项了，若该格子为1，表示这个格子对应的最小项在逻辑函数中出现，反之若该格子为0，表示该格子对应的最小项在逻辑函数中没有出现。将逻辑函数的每一个最小项对应填到同变量数的卡诺图中，这个卡诺图就是该逻辑函数的卡诺图。</p></li><li><h3 id="如何获得逻辑函数的卡诺图"><a href="#如何获得逻辑函数的卡诺图" class="headerlink" title="如何获得逻辑函数的卡诺图"></a>如何获得逻辑函数的卡诺图</h3><p>  首先将逻辑函数化成与或表达式，然后通过重叠律（A+<span style="text-decoration:overline">A</span>=1）将表达式中每一个乘积项（与项）增补成最小项，然后画出卡诺图，最后在卡诺图中找到逻辑函数每一个最小项对应的格子，将改格子写为1，其余格子全写0。</p></li><li><h3 id="逻辑函数的卡诺图如何化简"><a href="#逻辑函数的卡诺图如何化简" class="headerlink" title="逻辑函数的卡诺图如何化简"></a>逻辑函数的卡诺图如何化简</h3><ul><li>先看看哪里数字1多，然后画圈圈把他们围住，注意，这些圈圈不能随便画，有以下几点原则:</li></ul><ol><li>圈圈中包围的数字1的个数必须为2的整数幂，即1、2、4、8个等等。</li><li>圈圈中包围的数字只能是1，且圈圈围住的方格组合起来必须是矩形，即1x1、1x2、2x2、2x4的大小等等。</li><li>圈圈个数尽可能少（因为每个圈圈最后就是一个乘积项，圈圈越少结果越简单），每个圈圈包围的数字1尽可能多。</li><li>不同的圈圈<strong>可以重复包围</strong>同一个数字1（这一点初学容易忽视）。</li><li>如果一个圈圈中所有的数字1都已经被其他圈圈围住了，那么这个圈圈就是多余的，可以省去（这一点消除竞争与冒险时会反过来利用）。</li></ol><ul><li>现在圈圈画完了，开始整理，将每一个圈圈所对应的乘积项写出来（即圈圈中所有最小项相“与”），然后将这些乘积项全部“或”起来，就是化简后的表达式了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;由上篇知道，卡诺图是一个将最小项按二维格雷码的形式排布的表格，每个格子对应着一个最小项，那么卡诺图怎么使用呢？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是逻辑函数的卡诺图&quot;&gt;&lt;a href=&quot;#什么是逻辑函数的卡诺图&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：卡诺图（1）</title>
    <link href="http://39.106.115.216/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/"/>
    <id>http://39.106.115.216/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/</id>
    <published>2020-02-08T02:49:33.000Z</published>
    <updated>2020-03-27T09:19:43.747Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="什么是卡诺图"><a href="#什么是卡诺图" class="headerlink" title="什么是卡诺图"></a>什么是卡诺图</h3><ul><li>相邻最小项<br>若两个最小项之间仅有一个逻辑变量互为反变量，那么这两个最小项为相邻最小项。例如：m2（<span style="text-decoration:overline">A</span>·B·<span style="text-decoration:overline">C</span>）与m6（A·B·<span style="text-decoration:overline">C</span>）仅有逻辑变量A不同，因此m2与m6互为相邻最小项。</li><li>卡诺图<br>由一个个小方格组成，每个小方格代表一种最小项。几何位置上相邻的格子代表相邻最小项。  </li></ul></li><li><h3 id="如何构造卡诺图"><a href="#如何构造卡诺图" class="headerlink" title="如何构造卡诺图"></a>如何构造卡诺图</h3><p>  <em>这里将构造卡诺图只是将卡诺图的形式构造出来，只表示最小项之间的几何位置关系，与之后要讲的“逻辑函数的卡诺图”有区别。</em></p><p>  <em>其实卡诺图没有固定的画法，比如两变量的卡诺图可以画成一行，也可以画成两行两列，但为了方便，之后的卡诺图都是如下画法。</em></p></li></ul><img src="/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/两变量卡诺图.png" width="200px"><img src="/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/三变量卡诺图.png" width="200px"><img src="/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/四变量卡诺图.png" width="200px"><ol><li>先记住两变量卡诺图，假设两逻辑变量分别为C和D，格子编号从左至右依次为00、01、11、10，换算成十进制就是0、1、3、2；</li><li>将两变量卡诺图沿着水平线对称翻折到下方，变成两行，第一行对应第三个逻辑变量B的反变量，行号为0，第二行对应第三个逻辑变量B的原变量，行号为1；</li><li>同理，将三变量卡诺图沿着水平线对称翻折到下方，变成四行，一二行对应第四个逻辑变量A的反变量，行号依次为00和01，三四行对应第四个逻辑变量A的原变量，行号依次为11和10。</li><li>至此就将四变量卡诺图构造好了，每个格子的对应的最小项的编号是行号与列好组成的4位二进制数，转换成十进制数就和图示一样（注意这里是将格雷码当成二进制数，从数值上转换成十进制数，而不是将格雷码转换成对应的二进制码后再转换成十进制）。</li></ol><ul><li><h3 id="卡诺图的特点"><a href="#卡诺图的特点" class="headerlink" title="卡诺图的特点"></a>卡诺图的特点</h3><ol><li>由上述卡诺图的构造方法，可以将卡诺图理解成<strong>二维的格雷码</strong>，因为他们的构造方法十分相似，只是格雷码只能在一个方向上反复对称翻折构造，而卡诺图可以在两个方向上对称翻折构造。</li><li>基于1的理解，不难发现卡诺图的两个维度标号都是格雷码，但是这里的格雷码的0和1有着明确的含义，即逻辑变量的反变量和原变量。这样就可以轻松的画出卡诺图，也可以由卡诺图轻松的获得每一个各自对应的最小项。</li><li>如果将最小项的标号（格雷码）转换成二进制码，可以发现这些二进制码按照从小到大的顺序S行排列，即从左上角开始，第一行从左向右递增，第二行从右向左递增，以此类推。这为从真值表到卡诺图的转换提供了方便。</li><li>卡诺图最左边的格子和最右边的格子、最下面的格子和最上面的格子也是几何相邻的格子。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是卡诺图&quot;&gt;&lt;a href=&quot;#什么是卡诺图&quot; class=&quot;headerlink&quot; title=&quot;什么是卡诺图&quot;&gt;&lt;/a&gt;什么是卡诺图&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;相邻最小项&lt;br&gt;若两个最小项之间仅有一个逻辑变量互为反变量，那么这两个最小项
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：逻辑代数基本定理</title>
    <link href="http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/"/>
    <id>http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/</id>
    <published>2020-02-07T02:48:54.000Z</published>
    <updated>2020-03-30T02:11:58.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑代数基本定律"><a href="#逻辑代数基本定律" class="headerlink" title="逻辑代数基本定律"></a>逻辑代数基本定律</h2><p><em>以下两个定律比较重要，故单独列出</em></p><ul><li><strong><em>分配律</em></strong><ul><li>A·（B + C）= A · B + A · C</li><li><strong>A + B · C = （A + B）·（A + C）</strong></li></ul></li><li><strong><em>反演律</em></strong>（摩根定理）<ul><li><span style="text-decoration:overline">A·B·C</span> = <span style="text-decoration:overline">A</span> + <span style="text-decoration:overline">B</span> + <span style="text-decoration:overline">C</span></li><li><span style="text-decoration:overline">A+B+C</span> = <span style="text-decoration:overline">A</span> · <span style="text-decoration:overline">B</span> · <span style="text-decoration:overline">C</span> </li></ul></li></ul><p><strong>基本定律的应用</strong><br>重叠律和同一律的逆应用可以带来凑项的效果。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/BasicFormulas.png" width="200px">  </p><h2 id="逻辑代数常用公式"><a href="#逻辑代数常用公式" class="headerlink" title="逻辑代数常用公式"></a>逻辑代数常用公式</h2><ul><li>吸收律<ul><li>A + A·B = A</li><li>A·（A + B） = A</li></ul></li><li>补吸收律<ul><li>A + <span style="text-decoration:overline">A</span>·B = A + B</li></ul></li><li>重要公式<ul><li>A·B + <span style="text-decoration:overline">A</span>·C + B·C = A·B + <span style="text-decoration:overline">A</span>·C</li><li><strong>A·B + <span style="text-decoration:overline">A</span>·C + B·C·D = A·B + <span style="text-decoration:overline">A</span>·C</strong></li></ul></li></ul><h2 id="逻辑代数基本规则"><a href="#逻辑代数基本规则" class="headerlink" title="逻辑代数基本规则"></a>逻辑代数基本规则</h2><ul><li>带入规则<br>同代数的带入规则。</li><li>反演规则<br>如果将表达式中与（·）换成或（+）、或（+）换成与（·）、反变量换成原变量、原变量换成反变量、1换成0、0换成1，那么得到的表达式即使原表达式的反演表达式。注意不要改变运算顺序，适当使用小括号将原表达式的与运算括起来保证原表达式的运算顺序。</li><li>对偶规则<br>如果将表达式中与（·）换成或（+）、或（+）换成与（·），保持运算顺序不变，变量不变，则得到原表达式的对偶表达式。</li></ul><p><strong>基本规则的应用</strong><br>在化简逻辑函数时，可以通过反演规则（对偶规则）将逻辑函数转换为对应的反演表达式（对偶表达式），然后对转换后的新表达式进行化简，将得到的结果再进行一次反演（对偶）即可得到原逻辑函数的化简结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逻辑代数基本定律&quot;&gt;&lt;a href=&quot;#逻辑代数基本定律&quot; class=&quot;headerlink&quot; title=&quot;逻辑代数基本定律&quot;&gt;&lt;/a&gt;逻辑代数基本定律&lt;/h2&gt;&lt;p&gt;&lt;em&gt;以下两个定律比较重要，故单独列出&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：最小项最大项</title>
    <link href="http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%A1%B9%E6%9C%80%E5%A4%A7%E9%A1%B9/"/>
    <id>http://39.106.115.216/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%A1%B9%E6%9C%80%E5%A4%A7%E9%A1%B9/</id>
    <published>2020-02-07T01:35:48.000Z</published>
    <updated>2020-04-13T09:14:59.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小项"><a href="#最小项" class="headerlink" title="最小项"></a>最小项</h2><ul><li><h3 id="什么是最小项？"><a href="#什么是最小项？" class="headerlink" title="什么是最小项？"></a>什么是最小项？</h3><ul><li>现在有N个逻辑变量，若一个乘积项（与项）包含了这N个变量的原变量或非变量，且每种变量只以原变量或非变量的形式出现一次，那么该乘积项称为最小项。例如三个逻辑变量的最小项有如下8种:<br><span style="text-decoration:overline">A</span>·<span style="text-decoration:overline">B</span>·<span style="text-decoration:overline">C</span>、<span style="text-decoration:overline">A</span>·<span style="text-decoration:overline">B</span>·C、<span style="text-decoration:overline">A</span>·B·C、<span style="text-decoration:overline">A</span>·B·<span style="text-decoration:overline">C</span><br>A·B·<span style="text-decoration:overline">C</span>、A·B·C、A·<span style="text-decoration:overline">B</span>·C、A·<span style="text-decoration:overline">B</span>·<span style="text-decoration:overline">C</span>  </li><li>可以看出，每个最小项中，A、B、C分别只出现一次，要么是原变量（A、B、C），要么是反变量（<span style="text-decoration:overline">A</span>、<span style="text-decoration:overline">B</span>、<span style="text-decoration:overline">C</span>）。</li></ul></li><li><h3 id="为什么叫最小项？"><a href="#为什么叫最小项？" class="headerlink" title="为什么叫最小项？"></a>为什么叫最小项？</h3><p>  从概率论的角度看，如果每一个逻辑变量代表一个事件，事件发生和不发生的概率都是0.5，那么所有事件的交集（与运算）的发生概率最小，所以叫最小项。如此看来，不同的最小项之间是互斥的，即任何两个不同的最小项不可能同时发生，<strong>所以不同最小项之间的与运算结果一定是0</strong>。</p></li><li><h3 id="最小项如何编号？"><a href="#最小项如何编号？" class="headerlink" title="最小项如何编号？"></a>最小项如何编号？</h3><p>  简单的来说，原变量用1表示，反变量用0表示，然后组合起来转换成十进制就是对应最小项的编号。如下表：  </p><table><thead><tr><th align="center">A B C</th><th align="center">编号</th><th align="center">A B C</th><th align="center">编号</th></tr></thead><tbody><tr><td align="center">0 0 0</td><td align="center">m0</td><td align="center">1 0 0</td><td align="center">m4</td></tr><tr><td align="center">0 0 1</td><td align="center">m1</td><td align="center">1 0 1</td><td align="center">m5</td></tr><tr><td align="center">0 1 0</td><td align="center">m2</td><td align="center">1 1 0</td><td align="center">m6</td></tr><tr><td align="center">0 1 1</td><td align="center">m3</td><td align="center">1 1 1</td><td align="center">m7</td></tr></tbody></table><p>  为什么这样编号？因为当与运算中任意一个因子为0时，与运算结果为0，因子取值不具有唯一性；当且仅当与运算中所有因子为1时，与运算结果为1，因子取值具有唯一性。因此当原变量取1反变量取0时，最小项表达式所有因子为1，最小项表达式结果为1。</p></li></ul><ul><li><h3 id="什么是最小项表达式？"><a href="#什么是最小项表达式？" class="headerlink" title="什么是最小项表达式？"></a>什么是最小项表达式？</h3><p>  基本表达式中与或表达式的一种标准形式，各逻辑变量之间先进行与运算形成最小项，然后各最小项之间进行或运算形成最小项表达式。</p></li><li><h3 id="如何获得最小项表达式？"><a href="#如何获得最小项表达式？" class="headerlink" title="如何获得最小项表达式？"></a>如何获得最小项表达式？</h3><p>  常用配项法获得。利用逻辑表达式基本定律（A+<span style="text-decoration:overline">A</span>=1）增加各项中的逻辑变量。</p></li></ul><h2 id="最大项"><a href="#最大项" class="headerlink" title="最大项"></a>最大项</h2><p>最大项与最小项互补，大家自行脑补:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小项&quot;&gt;&lt;a href=&quot;#最小项&quot; class=&quot;headerlink&quot; title=&quot;最小项&quot;&gt;&lt;/a&gt;最小项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是最小项？&quot;&gt;&lt;a href=&quot;#什么是最小项？&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：码制</title>
    <link href="http://39.106.115.216/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/"/>
    <id>http://39.106.115.216/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/</id>
    <published>2020-02-04T07:35:22.000Z</published>
    <updated>2020-04-13T05:24:59.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="码制概念"><a href="#码制概念" class="headerlink" title="码制概念"></a>码制概念</h2><p>码制是用0和1组成的代码表示人类交流的字符的规则。</p><h2 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h2><ul><li>特点：循环码、反射码</li></ul><h4 id="二进制码转换为格雷码"><a href="#二进制码转换为格雷码" class="headerlink" title="二进制码转换为格雷码"></a>二进制码转换为格雷码</h4><ul><li>格雷码最高位（最左边）与二进制码最高位相同</li><li>二进制码从左到右，相邻两位相加，作为格雷码的下一位</li><li><img src="/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/BtoG.png"></li></ul><h4 id="格雷码转换为二进制码"><a href="#格雷码转换为二进制码" class="headerlink" title="格雷码转换为二进制码"></a>格雷码转换为二进制码</h4><ul><li>二进制码的最高位（最左边）与格雷码相同</li><li>将产生的二进制码与下一位格雷码相加，作为下一位二进制码</li><li><img src="/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/GtoB.png"></li></ul><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><ul><li>BCD码是用四位二进制数表示一个0~9的数字的码制。</li><li>由于四位二进制数有16个，从中选取10个作为BCD码的方案有很多，下面的图列出了常用的BCD码。</li><li><img src="/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/BCD.png"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;码制概念&quot;&gt;&lt;a href=&quot;#码制概念&quot; class=&quot;headerlink&quot; title=&quot;码制概念&quot;&gt;&lt;/a&gt;码制概念&lt;/h2&gt;&lt;p&gt;码制是用0和1组成的代码表示人类交流的字符的规则。&lt;/p&gt;
&lt;h2 id=&quot;格雷码&quot;&gt;&lt;a href=&quot;#格雷码&quot; clas
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：补码</title>
    <link href="http://39.106.115.216/2020/02/03/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A1%A5%E7%A0%81/"/>
    <id>http://39.106.115.216/2020/02/03/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A1%A5%E7%A0%81/</id>
    <published>2020-02-03T07:09:40.000Z</published>
    <updated>2020-02-03T14:12:00.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="真值补码对应表"><a href="#真值补码对应表" class="headerlink" title="真值补码对应表"></a>真值补码对应表</h2><p>以8bit数为例</p><table><thead><tr><th align="center">真值-无符号</th><th align="center">补码</th><th align="center">真值-有符号</th><th align="center">补码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0000 0000</td><td align="center">0</td><td align="center">0000 0000</td></tr><tr><td align="center">1</td><td align="center">0000 0001</td><td align="center">1</td><td align="center">0000 0001</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">127</td><td align="center">0111 1111</td><td align="center">127</td><td align="center">0111 1111</td></tr><tr><td align="center">128</td><td align="center">1000 0000</td><td align="center">-128</td><td align="center">1000 0000</td></tr><tr><td align="center">129</td><td align="center">1000 0001</td><td align="center">-127</td><td align="center">1000 0001</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">255</td><td align="center">1111 1111</td><td align="center">-1</td><td align="center">1111 1111</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>可以看出，负数与其绝对值的真值和为0，但是补码和为 1 0000 0000，由于只能存储8bit，故多出的第8号位上的1舍去，余下的0到7号位均为0，对应真值也就是0了。</li><li>为什么-1规定为1111 1111呢？由数学同余概念可知，255对256余-1，所以-1对应255，同理可得其他负数。这样一来，一个数减去1就可以用这个数加上255来表示，只不过计算结果多出的第8位会舍去，剩下的0到7号位表示的就是减法的结果。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;真值补码对应表&quot;&gt;&lt;a href=&quot;#真值补码对应表&quot; class=&quot;headerlink&quot; title=&quot;真值补码对应表&quot;&gt;&lt;/a&gt;真值补码对应表&lt;/h2&gt;&lt;p&gt;以8bit数为例&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;cente
      
    
    </summary>
    
    
    
      <category term="数字电路" scheme="http://39.106.115.216/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://39.106.115.216/2020/01/31/hello-world/"/>
    <id>http://39.106.115.216/2020/01/31/hello-world/</id>
    <published>2020-01-30T23:45:56.429Z</published>
    <updated>2020-01-30T23:45:56.429Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
