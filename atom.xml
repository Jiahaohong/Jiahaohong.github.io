<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darcy&#39;s Blog</title>
  
  <subtitle>Hope is something as precious as dimond.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong.github.io/"/>
  <updated>2021-02-11T02:42:36.333Z</updated>
  <id>http://jiahaohong.github.io/</id>
  
  <author>
    <name>Darcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python:数据可视化包</title>
    <link href="http://jiahaohong.github.io/2021/02/11/Python-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%85/"/>
    <id>http://jiahaohong.github.io/2021/02/11/Python-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%85/</id>
    <published>2021-02-11T02:37:10.000Z</published>
    <updated>2021-02-11T02:42:36.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p>matplotlib也是常用的python作图工具包，可以画图表，显示图像。</p><h3 id="1-导入"><a href="#1-导入" class="headerlink" title="1.导入"></a>1.导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> plt</span><br></pre></td></tr></table></figure><h3 id="2-显示图像的格式"><a href="#2-显示图像的格式" class="headerlink" title="2.显示图像的格式"></a>2.显示图像的格式</h3><p>在console显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>在jupyter里显示可调的画布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matpoltlib jupyter</span><br></pre></td></tr></table></figure><h3 id="3-创建画布"><a href="#3-创建画布" class="headerlink" title="3.创建画布"></a>3.创建画布</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>figsize参数是一个内置的比例参数，不是以像素为单位。</p><h3 id="4-显示图像"><a href="#4-显示图像" class="headerlink" title="4.显示图像"></a>4.显示图像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.imread(<span class="string">'test.jpg'</span>)</span><br><span class="line">img = image[:,:,::<span class="number">-1</span>]</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>opencv彩色图片是GBR排列，而plt是RGB排列。</p><h3 id="5-保存图像"><a href="#5-保存图像" class="headerlink" title="5.保存图像"></a>5.保存图像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">'plt.jpg'</span>)</span><br></pre></td></tr></table></figure><h2 id="pecharts"><a href="#pecharts" class="headerlink" title="pecharts"></a>pecharts</h2><p>功能强大，配色好看的数据可视化包。官方教程在此：<br><a href="https://gallery.pyecharts.org/#/" target="_blank" rel="noopener">Pyecharts官方教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;matplotlib&quot;&gt;&lt;a href=&quot;#matplotlib&quot; class=&quot;headerlink&quot; title=&quot;matplotlib&quot;&gt;&lt;/a&gt;matplotlib&lt;/h2&gt;&lt;p&gt;matplotlib也是常用的python作图工具包，可以画图表，显示图像。
      
    
    </summary>
    
    
      <category term="数据处理" scheme="http://Jiahaohong.github.io/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://Jiahaohong.github.io/tags/Python/"/>
    
      <category term="数据处理包" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Python: Pandas DataFrame</title>
    <link href="http://jiahaohong.github.io/2021/02/10/Python-Pandas-DataFrame/"/>
    <id>http://jiahaohong.github.io/2021/02/10/Python-Pandas-DataFrame/</id>
    <published>2021-02-10T11:52:54.000Z</published>
    <updated>2021-02-10T13:05:00.353Z</updated>
    
    <content type="html"><![CDATA[<p>最近写美赛论文用到了许多图片，所以把最近用到的数据处理工具包在此做一下记录。</p><h2 id="pandas-DataFrame"><a href="#pandas-DataFrame" class="headerlink" title="pandas.DataFrame"></a>pandas.DataFrame</h2><p>pandas提供的DataFrame类的数据处理形式和数据库很类似。每一行是一个数据（也叫记录），每一列是一种属性。</p><h3 id="1-导入"><a href="#1-导入" class="headerlink" title="1.导入"></a>1.导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h3 id="1-从Excel文件中读取数据"><a href="#1-从Excel文件中读取数据" class="headerlink" title="1.从Excel文件中读取数据"></a>1.从Excel文件中读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">'data.xlsx'</span>,usecols=[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>df是DataFrame变量。usecols表示选择excel中的哪些列。</p><h3 id="2-按属性条件选择数据"><a href="#2-按属性条件选择数据" class="headerlink" title="2.按属性条件选择数据"></a>2.按属性条件选择数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pos = df.where(df[<span class="string">'Lab Status'</span>]==<span class="string">'Positive ID'</span>)</span><br></pre></td></tr></table></figure><p>此时，df中不满足条件的数据对应属性会被替换成NaN，然后存入pos，注意这里df自身没有被改变。pos也是一个DataFrame变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pos = pos.dropna(axis=<span class="number">0</span>,how=<span class="string">'any'</span>)</span><br></pre></td></tr></table></figure><p>axis=0表示按行删除数据。how=’any’表示只要这一行数据中有一个NaN元素就把这一行删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.where(df[<span class="string">'Lab Status'</span>]==<span class="string">'Positive ID'</span>).dropna(axis=<span class="number">0</span>,how=<span class="string">'any'</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>inplace表示直接对df操作，而不创建新DataFrame，也就是df自身被改变了。</p><h3 id="3-按列读数据"><a href="#3-按列读数据" class="headerlink" title="3.按列读数据"></a>3.按列读数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetimes = df[<span class="string">'Detection Date'</span>].values</span><br></pre></td></tr></table></figure><p>.values方法返回一个numpy数组。</p><h3 id="4-插入列（属性）"><a href="#4-插入列（属性）" class="headerlink" title="4.插入列（属性）"></a>4.插入列（属性）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.insert(<span class="number">0</span>,</span><br><span class="line">          <span class="string">'Year'</span>,</span><br><span class="line">          [df[<span class="string">'Detection Date'</span>].values[i].year <span class="keyword">for</span> i <span class="keyword">in</span> range(len(df))])</span><br></pre></td></tr></table></figure><p>0表示改列插入位置。’Year’表示该列的索引（可以理解为字典里的key）。最后[]列表是插入的数据，注意和df等长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写美赛论文用到了许多图片，所以把最近用到的数据处理工具包在此做一下记录。&lt;/p&gt;
&lt;h2 id=&quot;pandas-DataFrame&quot;&gt;&lt;a href=&quot;#pandas-DataFrame&quot; class=&quot;headerlink&quot; title=&quot;pandas.DataFra
      
    
    </summary>
    
    
      <category term="数据处理" scheme="http://Jiahaohong.github.io/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://Jiahaohong.github.io/tags/Python/"/>
    
      <category term="数据处理包" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Yukrili:Always with me</title>
    <link href="http://jiahaohong.github.io/2020/11/05/Yukrili-Always-with-me/"/>
    <id>http://jiahaohong.github.io/2020/11/05/Yukrili-Always-with-me/</id>
    <published>2020-11-05T02:27:35.000Z</published>
    <updated>2020-11-05T02:50:21.057Z</updated>
    
    <content type="html"><![CDATA[<p><strong>千与千寻 - Always With Me</strong><br><img src="/2020/11/05/Yukrili-Always-with-me/pu.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;千与千寻 - Always With Me&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2020/11/05/Yukrili-Always-with-me/pu.jpg&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="自学的尤克里里" scheme="http://Jiahaohong.github.io/categories/%E8%87%AA%E5%AD%A6%E7%9A%84%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C/"/>
    
    
      <category term="尤克里里" scheme="http://Jiahaohong.github.io/tags/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux:Git学习笔记</title>
    <link href="http://jiahaohong.github.io/2020/11/01/Linux-Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jiahaohong.github.io/2020/11/01/Linux-Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-01T01:36:02.000Z</published>
    <updated>2020-11-01T03:58:07.478Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要上传一些代码到Github上，当初写这些代码的时候并没有建立git仓库，而是在代码完成后才建立仓库的，所以查阅了一些资料，顺便复习一下寒假学习的git知识，并在此记录一下。<br><em>本期话题：上传整个文件夹内容到github</em>  </p><hr><p><em>第1步在github上操作</em></p><h3 id="1-在github上建立仓库"><a href="#1-在github上建立仓库" class="headerlink" title="1.在github上建立仓库"></a>1.在github上建立仓库</h3><p>来到你的github主页，有个绿色的new按钮，点击创建一个新仓库：<br><img src="/2020/11/01/Linux-Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/new.jpg"><br>之后弹出一个界面，填写仓库名字后就可以了，其他选项默认即可。我们假定这个仓库叫learngit：<br><img src="/2020/11/01/Linux-Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/name.jpg"></p><hr><p><em>之后几步在本地电脑上操作</em></p><h3 id="2-初始化本地仓库"><a href="#2-初始化本地仓库" class="headerlink" title="2.初始化本地仓库"></a>2.初始化本地仓库</h3><p>cd到你的文件夹目录下，然后使用指令：<br><kbd>git init</kbd>  </p><h3 id="3-将本地仓库和github仓库建立连接"><a href="#3-将本地仓库和github仓库建立连接" class="headerlink" title="3.将本地仓库和github仓库建立连接"></a>3.将本地仓库和github仓库建立连接</h3><p>我们已经有了一个空的本地仓库和一个空的github仓库，现在要建立它们之间的链接：<br><kbd>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:Jiahaohong/learngit.git</kbd></p><h3 id="4-添加整个文件夹到暂存区"><a href="#4-添加整个文件夹到暂存区" class="headerlink" title="4.添加整个文件夹到暂存区"></a>4.添加整个文件夹到暂存区</h3><p>经过第2步，我们已经建立了一个本地空仓库，现在要把这个仓库所在的文件全部放到这个仓库里：<br><kbd>git add .</kbd></p><h3 id="5-提交所有文件"><a href="#5-提交所有文件" class="headerlink" title="5.提交所有文件"></a>5.提交所有文件</h3><p>在第4步中我们已经将修改的文件添加到暂存区了，现在就需要暂存区的文件提交到分支。用如下指令：<br><kbd>git commit -m "All from local"</kbd><br>注意，-m参数表示给这次提交分支操作写注释，后面双引号里的内容就是注释，可以任意修改。</p><h3 id="6-推送到github仓库"><a href="#6-推送到github仓库" class="headerlink" title="6.推送到github仓库"></a>6.推送到github仓库</h3><p>现在本地仓库已经装好了所有文件，现在需要将他们发送到github的仓库里：<br><kbd>git push -u origin master</kbd></p><hr><p><em>可能出现的错误及解决方法</em>  </p><h3 id="Q-显示找不到仓库"><a href="#Q-显示找不到仓库" class="headerlink" title="Q:显示找不到仓库"></a>Q:显示找不到仓库</h3><p>A:首先检查你的第3步仓库地址写对没，如果没有写对，那么就要删除那个错误的远程仓库，用如下命令：<br><kbd>git remote rm origin</kbd><br>然后重新做第3步，由于本地仓库已经弄好，所以之后直接跳到第6步。</p><hr><p><em>笔记</em></p><h3 id="什么是add什么是commit"><a href="#什么是add什么是commit" class="headerlink" title="什么是add什么是commit"></a>什么是add什么是commit</h3><p>学习过git的原理的朋友应该知道git仓库有两个空间，一个是工作区，就是平时我们理解的文件夹和里面的文件，还有一个空间是版本库，里面又分成了两个更小的空间，一个是暂存区，另一个是分支，版本库保存了有记录以来的所有文件修改记录。我们提交自己的修改需要经过两个步骤，第一个步骤是把修改好的文件添加到暂存区，第二个步骤是把暂存区的文件提交到分支。可以这样理解，暂存区是一个一级缓冲区域，这样可以减少分支的修改次数。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近需要上传一些代码到Github上，当初写这些代码的时候并没有建立git仓库，而是在代码完成后才建立仓库的，所以查阅了一些资料，顺便复习一下寒假学习的git知识，并在此记录一下。&lt;br&gt;&lt;em&gt;本期话题：上传整个文件夹内容到github&lt;/em&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Linux学习之路" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="Git" scheme="http://Jiahaohong.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>图像处理:Graphcut算法</title>
    <link href="http://jiahaohong.github.io/2020/10/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-Graphcut%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong.github.io/2020/10/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-Graphcut%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-31T02:00:02.000Z</published>
    <updated>2020-11-13T10:08:27.042Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="2020-11-13"><a href="#2020-11-13" class="headerlink" title="2020.11.13"></a>2020.11.13</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ul><li>源点汇点<br>在最大流问题中，除了普通的图节点外，还有两个特殊的节点，一个是源点source，另一个是汇点sink。源点是所有流出发的节点，且只允许流出；汇点是所有流终止的节点，且只允许流进入。给一张图定义了这两个结点之后，这张图的最大流问题的解也就唯一确定了。</li><li>图的边<br>在Graphcut算法中，有两种边，一种是图像内部像素与像素之间的边，称为N-link，另一种是像素和源点汇点的边，称为T-link。  </li></ul><h3 id="二、能量方程E-X"><a href="#二、能量方程E-X" class="headerlink" title="二、能量方程E(X)"></a>二、能量方程E(X)</h3><p>如何衡量一个分割是好还是坏？我们引入能量方程：<br><img src="/2020/10/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-Graphcut%E7%AE%97%E6%B3%95/E.jpg"><br>此方程根据贝叶斯公式导出，并在此基础上取了对数并求反，因此我们要让全图像能量最大化的目标，转化为让能量方程最小化。</p><ul><li><p>前景背景x<br>图像中的每一个点被划分为两类，一类是前景，另一类是背景。这个分类由你的图割给出。通常来说我们规定源点归为前景，汇点归为背景，但其实反过来不影响结果。  </p></li><li><p>权重w<br>我们把两个像素之间的相似度记为两个像素之间的权重。注意，由于取对数后还取了反，所以<strong>两个点越相似，这两个点之间的权重应该越小</strong>。  </p></li><li><p>数据项D<br>数据项由所有像素到其对应类别的源点或汇点的权重表示，比如一个像素被你划分成前景，那么这个像素的数据项就是这个像素和源点的权重。<br>因为本应该属于前景的点和源点的权重更小，本应该属于背景的点和汇点的权重更小，所以，一个划分越准确，就有更多的像素被正确分类，他们的数据项也就会更小。其实，让数据项最小也隐含着让<strong>类内相似度更高</strong>的含义。  </p></li><li><p>平滑项<br>平滑项由所有不同类别的像素之间的权重之和构成，这一项构成了一种对错误划分的惩罚。<br>比如有两个像素之间的权重很小，本应该划分成一类，这时如果你把他们划分成两类，那么平滑项求和就会多出一项，这样就会使能量函数增大，违背目标。<br>反过来，如果两个像素之间的权重很大，本不应该划分成一类，这时如果你把他们归为一类，表面上平滑项少了一项，能量函数会变小，但是实际上，其中一个被错误分类的那个像素的数据项的权值会变大（假设一个像素点实际类别为前景，那么它和源点的权重会小于和汇点的权重，假设为1，和背景的权重假设为10，你把它划分为背景，那么它的数据项的值就从1变道10），总体上能量函数还是会增大，违背目标。<br>其实，让平滑项最小也隐含着让<strong>类间相似度更低</strong>的含义。  </p></li><li><p>最大流和图割的联系<br>实际上，最大流问题是一个单独的问题，和图像分割本没有什么联系，但是这个能量方程很难化简，于是有人将最大流问题应用到图割的方程中，就得到了Graphcut算法。在Graphcut算法中，源点汇点一般由人指定，比如前景取一些点作为源点，背景取一些点作为汇点，然后就可以计算这幅图片的N-link权重和T-link权重。</p></li></ul><hr><h2 id="2020-10-31"><a href="#2020-10-31" class="headerlink" title="2020.10.31"></a>2020.10.31</h2><h3 id="一、什么是Graphcut算法"><a href="#一、什么是Graphcut算法" class="headerlink" title="一、什么是Graphcut算法"></a>一、什么是Graphcut算法</h3><p>首先得知道，名字里的graph的意思是图，和前几篇的博客讲解的图是一个概念，而不是什么图片或照片。</p><p>然后，我们还要知道一个概念——最大流。</p><p>我们把一张带权图看成一张公路网，每一个节点都是一个城市，每一条边就是一条公路，每条边的权重是这条路所能承载的最大车流量。现在有一个非常庞大的车队，从节点S出发，要到达节点T，这些车充满了整个公路网，由于有些城市进城最大车流量小于出城最大车流量，于是这些节点的出城公路就没有堵塞，反之，有些城市的进城车流量大于出城车流量，那么这些城市的出城公路就出现了堵塞。  </p><p>将上述问题转换成图表示，就出现了从节点S出发到节点T的最大流量问题——maxflow问题。具体问题解析参考<a href="https://blog.csdn.net/G1011/article/details/89786489" target="_blank" rel="noopener">这篇博客</a>，这里以后再了解。  </p><p>还有一个重要结论，这里复述一下：<a href="https://blog.csdn.net/ccblogger/article/details/77658166" target="_blank" rel="noopener">福特-富克森定理表明，网路的最大流max flow与最小割min cut相等</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;2020-11-13&quot;&gt;&lt;a href=&quot;#2020-11-13&quot; class=&quot;headerlink&quot; title=&quot;2020.11.13&quot;&gt;&lt;/a&gt;2020.11.13&lt;/h2&gt;&lt;h3 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; cl
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像处理:四种分割算法对比</title>
    <link href="http://jiahaohong.github.io/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://jiahaohong.github.io/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</id>
    <published>2020-10-30T05:52:54.000Z</published>
    <updated>2020-10-31T03:06:45.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、实验结果"><a href="#一、实验结果" class="headerlink" title="一、实验结果"></a>一、实验结果</h3><h4 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h4><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1origin.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1watershed.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1meanshift.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1ncut.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1graphcut.jpg"><h4 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h4><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2origin.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2watershed.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2meanshift.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2ncut.jpg"><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2graphcut.jpg"><h3 id="二、实验结果分析"><a href="#二、实验结果分析" class="headerlink" title="二、实验结果分析"></a>二、实验结果分析</h3><ol><li>Watershed算法相对于Meanshift算法有较严重的过分割现象，但是Ncut算法效果也不太理想。</li><li>Graphcut算法对前景背景的选取要求较高。</li></ol><h3 id="三、Graphcut前景背景选取对结果的影响"><a href="#三、Graphcut前景背景选取对结果的影响" class="headerlink" title="三、Graphcut前景背景选取对结果的影响"></a>三、Graphcut前景背景选取对结果的影响</h3><p>接下来我们通过控制变量的方式，每次仅改变前景或背景的标注方式，看看标注方式对实验结果有什么影响。图片中绿色的线条为选取的前景，粉红色的线条为选区的背景。  </p><hr><p>第一次标注，前景用一条线标注，背景分成三块标注：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1biaozhu.jpg"><br>第一次标注结果：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/1res.jpg"></p><hr><p>第二次标注，前景用一个圈标注，背景还是分成三块标注：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2biaozhu.jpg"><br>第二次标注结果：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2res.jpg"></p><hr><p>第三次标注，前景用一条线标注，背景圈出来标注：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/3biaozhu.jpg"><br>第三次标注结果：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/3res.jpg"></p><hr><p>第四次标注，前景用一个圈标注，背景圈出来标注：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/4biaozhu.jpg"><br>第四次标注结果：<br><img src="/2020/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%9B%E7%A7%8D%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/4res.jpg"></p><p>可以看出来使用圈圈出来的前景分割效果比直线标注效果好，而背景如何标注对实验结果没有太大影响。具体原因还需研究。</p><h3 id="三、原码下载地址"><a href="#三、原码下载地址" class="headerlink" title="三、原码下载地址"></a>三、原码下载地址</h3><p><strong>1号连接使用Opencv自带函数实现，2号和3号连接使用他人开源代码，由于找不到其源码地址了，就放到自己的github上了，如有好心人知道代码地址，敬请留言告诉我，谢谢!</strong><br><strong>2020/10/31更新，Normalizedcut代码原地址已找到，链接已更新！</strong></p><ol><li><a href="https://github.com/Jiahaohong/Watershed-Meanshift.git" target="_blank" rel="noopener">Watershed-and-Meanshift</a></li><li><a href="https://www.cnblogs.com/c-happy/p/6422766.html" target="_blank" rel="noopener">Normalizedcut</a></li><li><a href="https://github.com/Jiahaohong/Graphcut.git" target="_blank" rel="noopener">Graphcut</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、实验结果&quot;&gt;&lt;a href=&quot;#一、实验结果&quot; class=&quot;headerlink&quot; title=&quot;一、实验结果&quot;&gt;&lt;/a&gt;一、实验结果&lt;/h3&gt;&lt;h4 id=&quot;图1&quot;&gt;&lt;a href=&quot;#图1&quot; class=&quot;headerlink&quot; title=&quot;图1&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像处理:NoramlizedCuts算法</title>
    <link href="http://jiahaohong.github.io/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong.github.io/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-29T12:35:23.000Z</published>
    <updated>2020-11-13T05:57:16.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是NormalizedCuts算法"><a href="#一、什么是NormalizedCuts算法" class="headerlink" title="一、什么是NormalizedCuts算法"></a>一、什么是NormalizedCuts算法</h3><hr><p>要理解Normalized算法，我们先要熟悉一下这个算法所解决的问题的模型。  </p><ul><li><h4 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h4><p>  NormalizedCuts是定义在带权无向图上的分割问题，这里给出这种图的定义：  </p><ul><li><p>图用G表示  </p></li><li><p>图中的节点用V表示  </p></li><li><p>节点与节点之间的连线（图像的边）用E表示  </p><p>带权图表示图像的每一条边都有一个确定的权重，而无向图表示图像的边没有方向性，类似于双行线，即边所连接的节点可以互相访问到对方。比如下图就是一个典型的带权无向图：  </p><img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/G.jpg">  </li></ul></li></ul><hr><p>知道模型之后，我们来看看NormalizedCuts算法是要解决什么问题。</p><ul><li><h4 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h4>  把一张图中关系密切的节点作为一类分割出来。直觉上来说，关系越密切的节点，两节点之间的权重也越大，<strong>但是用什么指标衡量关系是否密切还需考量</strong>。还有怎样分割能够将种类准确的分割出来，这是接下来的目标。  </li></ul><hr><p>怎么分割一张图呢？我们以二分类为例介绍一下图的分割和最小割。  </p><ul><li><h4 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h4>  我们的图有两类节点，分别组成子图A和子图B，两个子图满足如下条件：    <img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/condition.jpg" width="90">    形象地说就是把一块饼掰成两块，而且不掉任何碎屑，这就是分割。为了衡量一个分割是否准确，我们把子图A和子图B中的节点两两配对，然后将权重相加，得到的值为图像的能量或损失，不同的分割情况有不同的损失，这样形成一个函数，称为能量函数或损失函数：    <img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/cut.jpg" width="200">    如果我们再加一点限制条件，通过修改两个子图包含的节点，使得算出的准确度指标最小，那么此时得到的分割就是这张图的最小分割。比如第一幅图的最小割如下所示：    <img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/Gmincut.jpg"></li></ul><hr><p>但是最小割往往有缺陷，容易把边缘的单独一个节点割出来，所以我们引入<strong>归一化分割</strong>，即NormalizedCut。</p><ul><li><h4 id="归一化分割-Normalized-Cut"><a href="#归一化分割-Normalized-Cut" class="headerlink" title="归一化分割(Normalized Cut)"></a>归一化分割(Normalized Cut)</h4><p>  分割可以理解成：子图A的节点对子图B的节点的权重，加上子图B的节点对子图A的节点的权重（其实这两者是相等的，但是除不除2只是一个系数问题，我们比较只用相对大小），公式如下：  </p>  <img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/cut2.jpg" width="300">    这种直接相比较鲁莽，我们稍微修改一下，等式右边两项都除以各自子图与全部图的能量函数：    <img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/assoc.jpg" width="200">    然后就得到归一化后的分割能量函数：    <img src="/2020/10/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-NoramlizedCuts%E7%AE%97%E6%B3%95/Ncut.jpg" width="300">  <p>  可以看出，<strong>Ncut在追求不同子集间点的权重最小值的同时也追求同一子集间点的权重最大值</strong><sup>[1]</sup></p></li></ul><h3 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h3><p>Normalizedcut算法的优化十分复杂，这里我给出一些整理的文献资料，有时间和兴趣的话可以看看如何实现。</p><ol><li><a href="https://blog.csdn.net/qq_38476684/article/details/80553850" target="_blank" rel="noopener">图像处理–归一化切割–(normalized cut)–Python实现</a></li><li><a href="https://people.eecs.berkeley.edu/~malik/papers/SM-ncut.pdf" target="_blank" rel="noopener">Normalized Cuts and Image Segmentation</a></li><li><a href="https://github.com/SatyabratSrikumar/Normalized-Cuts-and-Image-Segmentation-Matlab-Implementation" target="_blank" rel="noopener">Jitendra Malik, Jianbo Shi UC Berkeley, Normalized-Cuts-and-Image-Segmentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是NormalizedCuts算法&quot;&gt;&lt;a href=&quot;#一、什么是NormalizedCuts算法&quot; class=&quot;headerlink&quot; title=&quot;一、什么是NormalizedCuts算法&quot;&gt;&lt;/a&gt;一、什么是NormalizedCuts算法&lt;/
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像处理:Watershed算法</title>
    <link href="http://jiahaohong.github.io/2020/10/27/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-Watershed%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong.github.io/2020/10/27/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-Watershed%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-27T07:18:34.000Z</published>
    <updated>2020-11-13T08:31:27.396Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="2020-11-13"><a href="#2020-11-13" class="headerlink" title="2020.11.13"></a>2020.11.13</h2><h3 id="一、新的方法"><a href="#一、新的方法" class="headerlink" title="一、新的方法"></a>一、新的方法</h3><p>在此之前，我的想法是让每个极小值发展出来的水域通过堤坝的阻挡互不相通，所以堤坝是真实存在的，现在有一个不用建立堤坝的方法——Meyer分水岭算法。  </p><ul><li>1.遍历图像找到所有极小值点，给每个极小值点打上不同的标记；  </li><li>2.找到所有极小值点的邻域点，然后按照灰度值从小到大的顺序进入队列；  </li><li>3.出队，获得当前像素H；  <ul><li>3.1 搜索H的邻域，如果邻域中所有<strong>有标记的像素</strong>标记都一样（边界标记不参与统计），即H周围只有一种水域边界，那么给H也打上这个标记；如果邻域中所有<strong>有标记的像素</strong>标记不同（边界标记不参与统计），即H周围有多个水域边界，那么给H打上边界（堤坝）标记；</li><li>3.2 将H的邻域中，没有标记的点按灰度值从小到大的顺序进入队列；</li></ul></li><li>4.重复步骤三直至队列为空。</li></ul><hr><h2 id="2020-10-27"><a href="#2020-10-27" class="headerlink" title="2020.10.27"></a>2020.10.27</h2><h3 id="一、什么是Watershed算法"><a href="#一、什么是Watershed算法" class="headerlink" title="一、什么是Watershed算法"></a>一、什么是Watershed算法</h3><p>将每幅图片看成一个三维空间里的直方图，x、y坐标是原来图片每个像素的坐标，z坐标代表这个像素点的灰度值，这样形成的一个三维图像就像地形等高图一样，灰度值大的地方直方图就高一些，反之，灰度值小的地方直方图就低一些。  </p><p>现在，在所有局部极小值里，选择一个灰度值最小的点开始灌水，刚开始，每个局部极小值都是不连通的，随着水位的上升，每个局部极小值所处位置的水域范围逐渐扩大，当两个水域要连在一起时，就在两个水域之间建筑一个堤坝分开他们，重复灌水、筑坝的过程，直到水位达到全局最大灰度值，剩下的堤坝就是图像边界。  </p><h3 id="二、对于watershed算法的一些思考"><a href="#二、对于watershed算法的一些思考" class="headerlink" title="二、对于watershed算法的一些思考"></a>二、对于watershed算法的一些思考</h3><h4 id="如何判断两片水域是否连通？"><a href="#如何判断两片水域是否连通？" class="headerlink" title="如何判断两片水域是否连通？"></a>如何判断两片水域是否连通？</h4><p>在每次灌水之前，每一个水域都会有一个自己的标记，即这个水域里所有像素的标记都一样。灌水后，把新淹没的像素点用一个特殊标记表示出来，然后寻找新淹没的像素点的邻域，将这些新淹没的像素划分到不同的水域里，如果有一个新淹没像素被分到多个水域里，那么这像素位置将会连通多个水域，这就是要找的图像边界。</p><h4 id="水位上涨会改变已有边界位置吗？"><a href="#水位上涨会改变已有边界位置吗？" class="headerlink" title="水位上涨会改变已有边界位置吗？"></a>水位上涨会改变已有边界位置吗？</h4><p>因为水位和已经建立的堤坝一样高，所以如果水位上涨，已经建立的堤坝只能在原位置上增高，因此一旦找到一个边界，那么不论之后水位如何增长，这个边界位置不会改变。</p><hr><p>如果有新想法…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;2020-11-13&quot;&gt;&lt;a href=&quot;#2020-11-13&quot; class=&quot;headerlink&quot; title=&quot;2020.11.13&quot;&gt;&lt;/a&gt;2020.11.13&lt;/h2&gt;&lt;h3 id=&quot;一、新的方法&quot;&gt;&lt;a href=&quot;#一、新的方法&quot; cl
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像处理:MeanShift算法</title>
    <link href="http://jiahaohong.github.io/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong.github.io/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-25T12:27:49.000Z</published>
    <updated>2020-10-27T07:29:09.100Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：D. Comaniciu and P. Meer, Mean Shift: A Robust Approach toward Feature Space Analysis, PAMI 2002. </p><h3 id="一、什么是MeanShift算法"><a href="#一、什么是MeanShift算法" class="headerlink" title="一、什么是MeanShift算法"></a>一、什么是MeanShift算法</h3><p>Meanshift算法大致思路是，通过寻找一个小范围内的密度<strong>最大值</strong>，通过迭代的方法，最终收敛到一个全局范围内的密度<strong>极大值</strong>。  </p><h3 id="二、MeanShift算法的严格数学推导"><a href="#二、MeanShift算法的严格数学推导" class="headerlink" title="二、MeanShift算法的严格数学推导"></a>二、MeanShift算法的严格数学推导</h3><ul><li><p>区域中某一位置的密度估计函数<br>  MeanShift算法的目标是找到样本点中某一个密度最大的位置，首先得知道如何定义一个位置的密度，公式如下：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/rou.jpg" width="200">  <p>  稍微解释一下这个公式，f(X)代表在这个区域内，x位置的密度，n代表这个区域内有n个样本点，KH表示一种概率密度函数，可以看作和x距离不同的地方对x位置的密度的贡献程度，常见的有高斯分布。  </p><p>  这个公式还不完全，需要归一化，因为x可以看成d维空间中的点，区域可以看成d维空间中半径为h的高维球体，归一化后的公式是这样：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/normalized.jpg" width="200">  </li><li><p>区域中密度估计函数的最大值<br>  MeanShift算法需要沿着梯度方向移动，而当前区域内，密度最大的地方就是下一步要移动的方向。如何求得使f(x)取最大值的x呢？求导：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/derivative.jpg" width="300">  <p>  我们稍微变形一下，将KH’的求和提出来，得到如下公式：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/final.jpg" width="450">  <p>  令上式等于零，由于概率密度函数恒大于零，所以第二项等于零，得出密度最大点的公式：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/x.jpg" width="200">  </li></ul><h3 id="三、MeanShift算法的直观物理推导"><a href="#三、MeanShift算法的直观物理推导" class="headerlink" title="三、MeanShift算法的直观物理推导"></a>三、MeanShift算法的直观物理推导</h3><p>你可以这样想象，每一个样本点都是一个质点，而样本点的参数就是质点的质量，你用一个固定大小的圆随机圈中一些质点，这些质点的质心有很大概率不在你的圆的中心，那么你下一步就需要把圆的中心移到这些点的质心。当你移完之后，你的圆会圈中和上次不完全一样的点，这时就又有一个新的质心，你仍然需要将圆的中心移到这个新的质心上。如此反复，由于质心总是向密度大的方向偏离，最终你的圆会落到所有质点里密度最大的地方。由此得出，每一次移动的位置和权重的样本点关系如下（一维质心公式为例）：  </p><center><img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/physic.jpg" width="90"></center><h3 id="四、MeanShift算法应用到图像分割"><a href="#四、MeanShift算法应用到图像分割" class="headerlink" title="四、MeanShift算法应用到图像分割"></a>四、MeanShift算法应用到图像分割</h3><p>MeanShift算法整体思想，是每一步都向密度更大的地方走，直到走不动为止，然后在所有走到同一个终点的出发点归为一类。但是在图像中属于一类的物体哪些参数是比较接近的？根据上网查阅资料得知，一个物体的各个部分在RGB图像中关联度不高，但是在HSV图像中相关度比较高，因此之后的实验在HSV颜色空间中进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文献：D. Comaniciu and P. Meer, Mean Shift: A Robust Approach toward Feature Space Analysis, PAMI 2002. &lt;/p&gt;
&lt;h3 id=&quot;一、什么是MeanShift算法&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux:ssh免密登录服务器</title>
    <link href="http://jiahaohong.github.io/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://jiahaohong.github.io/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-10-20T04:24:38.000Z</published>
    <updated>2020-10-20T12:17:09.348Z</updated>
    
    <content type="html"><![CDATA[<p>今年二月份在阿里云领了一个免费服务器，当时学了学服务器操作的相关知识，感觉ssh登录确实很方便。前不久8月份免费的服务器到期了，所以我又开了一个一年的低配服务器，现在记录一下我对这个服务器的操作，纯属乐趣。本期话题是“ssh免密登录”。</p><p>我的硬件配置如下：<br><em>本地电脑：Windows10</em><br><em>服务器：阿里云云服务器</em><br><em>本地远程登录软件：gitbash</em></p><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><h4 id="一个服务器"><a href="#一个服务器" class="headerlink" title="一个服务器"></a>一个服务器</h4><ul><li>说明一下，其一，一台服务器的概念很宽泛，可以是另一台电脑，也可以是一个云端的电脑，但总归一点你要知道它的IP地址。  </li><li>其二，这个服务器上已经有注册了用户，有个用户名和对应的密码，这类似于你用于登陆Windows的账户。  </li><li>其三，有一个区别是Windows的管理员是administrator，Linux的管理员是root。</li></ul><h4 id="一台本地电脑"><a href="#一台本地电脑" class="headerlink" title="一台本地电脑"></a>一台本地电脑</h4><ul><li>Windows电脑可以下载一些软件来连接，比如Putty和XShell</li><li>Linux电脑需要安装ssh服务。</li></ul><h4 id="核心登录指令"><a href="#核心登录指令" class="headerlink" title="核心登录指令"></a>核心登录指令</h4><p><strong>ssh <a href="mailto:username@xxx.xxx.xxx.xxx">username@xxx.xxx.xxx.xxx</a></strong>  </p><ul><li>username 用你自己的用户名替换  </li><li>xxx.xxx.xxx.xxx 用你自己的服务器ip地址替换</li></ul><h3 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h3><h4 id="阿里云远程连接配置服务器"><a href="#阿里云远程连接配置服务器" class="headerlink" title="阿里云远程连接配置服务器"></a>阿里云远程连接配置服务器</h4><p><em>这一步操作需要通过本地电脑远程连接服务器后，在服务器上执行。</em><br>在用自己的电脑远程连接服务器之前，我们需要使用阿里云平台提供的工具连接到自己的服务器，这个工具在哪？登录阿里云官网，控制台里就有。<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/aliyun.jpg"><br>点击远程连接进入到终端后，找到/etc/ssh文件夹，我们要修改该文件夹里的<strong>sshd_config</strong>文件，配置一下远程登陆，一般来说文件里都已经写好了，只不过被注释掉了（或开启状态写的是no），这时你只需要找到被注释的行取消注释就行（或把no改成yes）；如果你没有找到相应的配置，那么就要手动添加，写在文件里任何位置都是可以的，但建议最后一行，方便以后修改。需要修改的配置如下两图：<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/aliyun_cfg1.jpg"><br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/aliyun_cfg2.jpg"><br>这里稍微解释一下这四个配置的意思（如果不想看尽情跳过）：</p><ul><li>第一个<strong>PermitRootLogin</strong>表示允许用root用户进行远程登陆。如果不开启这一项，那么你的远程登陆只能使用其他的普通用户名登录。比如你在服务器上注册了一个darcy账户，而你没有开启这一项，那么你只能用darcy作为远程登录的用户名，这种情况下你用root登录会拒绝你的登录请求。  </li><li>第二个<strong>PasswordAuthentication</strong>表示允许密码远程登录。这是最基础的远程登陆认证方式，其实和你在电脑开机时输入登陆密码一样。  </li><li>第三个<strong>PubkeyAuthentication</strong>表示允许公钥远程登陆。<strong>注意</strong>这一项是本篇博客的重要内容。ssh登录需要开启这个命令。</li><li>第四个是保存公钥的文件，你在你的ssh文件夹里找一找，一般来说第一个就是（因为开头字母是a），如果没有就自己在ssh文件夹里新建一个文件，名字是authoriz_keys，后面那个authoriz_keys2没有用到。  </li></ul><h4 id="生成公钥密钥"><a href="#生成公钥密钥" class="headerlink" title="生成公钥密钥"></a>生成公钥密钥</h4><p><em>这一步操作需要在本地电脑的远程连接软件的终端上执行。</em><br>在gitbash里输入如下命令<strong>ssh-keygen -t rsa</strong>，之后按他的提示来就行，最终会在你的Windows当前用户的主文件夹的.ssh文件夹里生成两个文件，一个是公钥id_rsa.pub，另一个是私钥id_rsa，其中私钥要保管好，公钥要传到服务器上去。注意，如果是Linux用户，这个文件在~/.ssh文件夹里，如果是Windows用户，这个文件在如下图的路径里：<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/key.jpg"></p><h4 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h4><p><em>这一步操作需要在本地电脑的远程连接软件的终端上执行。</em><br>在本地远程连接软件终端里输入如下指令<strong>ssh-copy-id -i ~/.ssh/id_rsa.pub <a href="mailto:root@xxx.xxx.xxx.xxx">root@xxx.xxx.xxx.xxx</a></strong>，之后会让你输入root用户的密码，之后会提示让你用<strong>ssh <a href="mailto:root@xxx.xxx.xxx.xxx">root@xxx.xxx.xxx.xxx</a></strong>命令远程登陆服务器（如下图）。OK，你可以免密登陆了！<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/upload.jpg"></p><h3 id="三、题外话：第一次连接服务器（密码登录）"><a href="#三、题外话：第一次连接服务器（密码登录）" class="headerlink" title="三、题外话：第一次连接服务器（密码登录）"></a>三、题外话：第一次连接服务器（密码登录）</h3><p><em>这一步操作需要在本地电脑的远程连接软件的终端上执行。</em><br>在第一次远程连接服务器的时候，会出现如下警告：<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/norm3.jpg"><br>这是正常的，ssh为了防止中间人攻击会在你第一次连接一个远程服务器时提醒你一下。敲上yes按回车确认即可。然后他会让你输入密码，你输入root用户的密码即可，这里没有显示是正常的，因为他会隐藏你输入的密码。<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/norm1.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年二月份在阿里云领了一个免费服务器，当时学了学服务器操作的相关知识，感觉ssh登录确实很方便。前不久8月份免费的服务器到期了，所以我又开了一个一年的低配服务器，现在记录一下我对这个服务器的操作，纯属乐趣。本期话题是“ssh免密登录”。&lt;/p&gt;
&lt;p&gt;我的硬件配置如下：&lt;b
      
    
    </summary>
    
    
      <category term="Linux学习之路" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="http://Jiahaohong.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:直方图均衡化vs同态滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-19T00:11:06.000Z</published>
    <updated>2020-10-24T10:05:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>上个星期做完直方图均衡化和同态滤波的图像处理实验，才发现没有进行过对比，现在那原来的代码进行一次处理效果对比实验。</p><h4 id="原图片"><a href="#原图片" class="headerlink" title="原图片"></a>原图片</h4><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/1.jpg"><h4 id="灰度图片及其傅里叶变换"><a href="#灰度图片及其傅里叶变换" class="headerlink" title="灰度图片及其傅里叶变换"></a>灰度图片及其傅里叶变换</h4><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/gray.jpg"><h4 id="傅里叶变换对比"><a href="#傅里叶变换对比" class="headerlink" title="傅里叶变换对比"></a>傅里叶变换对比</h4><p>左边是直方图均衡化后的傅里叶变换图像，右边是同态滤波后的傅里叶变换图像。第二行是他们与原灰度图像的傅里叶变换图之差，黑色部分表示几乎没有差异，白色部分表示差异很大。<br><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/ft_compared.jpg"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从傅里叶变换对比可以看出，同态滤波和直方图均衡化的低频成分都被很大的抑制了，中间十字形部分几乎为白，但是同态滤波的高频成分和原图像基本保持一致，二直方图均衡化丢失了一部分高频成分信息。  </p><center><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个星期做完直方图均衡化和同态滤波的图像处理实验，才发现没有进行过对比，现在那原来的代码进行一次处理效果对比实验。&lt;/p&gt;
&lt;h4 id=&quot;原图片&quot;&gt;&lt;a href=&quot;#原图片&quot; class=&quot;headerlink&quot; title=&quot;原图片&quot;&gt;&lt;/a&gt;原图片&lt;/h4&gt;&lt;img
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>C/C++:一维熵阈值分割</title>
    <link href="http://jiahaohong.github.io/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <id>http://jiahaohong.github.io/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</id>
    <published>2020-10-17T10:45:06.000Z</published>
    <updated>2020-10-25T14:26:49.579Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/OTSU-and-Entropy.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是一维熵阈值分割"><a href="#一、什么是一维熵阈值分割" class="headerlink" title="一、什么是一维熵阈值分割"></a>一、什么是一维熵阈值分割</h3><p>信息熵表示从信号中可能获得的信息的多少。<br>就比如投硬币，出席那正反两面的概率都是0.5，那么根据信息熵的公式得出，“硬币是正面”这个预测所携带的信息熵是：<br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/p05.jpg" width="300"><br>如果投出正面的概率是0.9，那么“硬币是正面”这个预测所携带的信息熵是：<br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/p09.jpg" width="300"><br>如果投出正面的概率是0.1，那么“硬币是正面”这个预测所携带的信息熵是：<br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/p01.jpg" width="300"><br>可以看到，当硬币出现正反面的概率一样的时候，“硬币是正面”这个预测所携带的信息熵最大，也就是信息量最大。同理可以推广至更多种预测结果的情况，比如投正二十面体，当“出现任意一个面朝上的概率相同”时，“第13号面朝上”这个预测所携带的信息量最大。  </p><p>回到图像上，图像有256个灰度级，若“一个像素是0到255中的任意一个的概率相同”，那么这张图象所携带的信息量最大。但不用多想，这种图就像黑白电视机没信号时候的图像一样，没有可解读的含义。至于为什么如此，还需要更深刻的理解，我暂时解释不清。 </p><p>上面讲到了整幅图像的信息，现在更进一步，将图像分成两部分，其一是目标区域，其二是背景区域。如果二者都大致符合正态分布，那么图像的熵可以表示为目标区域的熵和背景区域的熵之和。基于此，一维熵阈值分割的目标就是，寻找一个分割灰度t，使得目标区域和背景区域的熵之和最大。</p><h3 id="二、一维熵阈值分割公式"><a href="#二、一维熵阈值分割公式" class="headerlink" title="二、一维熵阈值分割公式"></a>二、一维熵阈值分割公式</h3><h4 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h4><p>像素分成两类，一类是目标区域，一类是背景区域，每一类像素各自有两个基本变量：</p><ul><li>w 像素总个数</li><li>e 区域的一维熵（用像素个数代替像素概率密度，并且不加负号）<br>由于不知道小于阈值t的像素属于目标还是背景，所以将小于阈值t的像素集设定为0。下面以小于阈值t的像素为例：  <center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/definition.jpg" width="150"></center></li></ul><h4 id="指标变量"><a href="#指标变量" class="headerlink" title="指标变量"></a>指标变量</h4><p>指标变量有两个，一个是目标区域的一维熵，另一个是背景区域的一维熵，同样由于不知道背景和目标谁比较亮，所以Ho和HB都是相对来说的，一个为目标，一个为背景，二者等价。假设目标的灰度级小于背景，则定义如下：  </p><center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/index.jpg" width="300"></center><h4 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h4><p>总体的一维熵表示为目标区域一维熵和背景一维熵之和，化简之后结果如下（使用数学上的定义，pi代表第i各灰度级的概率密度）：  </p><center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/res1.jpg" width="300"></center>  为了提高程序效率，我们进一步将该公式变换成利于编程的形式，采用我们定义的基本变量表示，将该公式的三个部分分别化简成如下公式：  <center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/res2.jpg" width="300"></center>  <h3 id="三、程序思路"><a href="#三、程序思路" class="headerlink" title="三、程序思路"></a>三、程序思路</h3><p>设置一个变量t作为待定的阈值，然后t遍历整个灰度级（实际上1-254即可），每一个t算一个一维熵，如果这个一维熵比最大一维熵大，那么更新最大一维熵，并将这次的t作为待定阈值。</p><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">entropy</span><span class="params">(cv::Mat &amp;input_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> M = input_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = input_img.cols;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = M * N;</span><br><span class="line"><span class="keyword">double</span> log_size = <span class="built_in">std</span>::<span class="built_in">log</span>(M*N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a, b, c; <span class="comment">//公式里相加的三项</span></span><br><span class="line"><span class="keyword">double</span> phi, phiMax = <span class="number">0.0</span>; <span class="comment">//phi公式最大值</span></span><br><span class="line"><span class="keyword">int</span> w0;    <span class="comment">//小于阈值t的像素的个数</span></span><br><span class="line"><span class="keyword">double</span> e0; <span class="comment">//小于阈值t的像素一维熵（用像素个数代替概率）</span></span><br><span class="line"><span class="keyword">int</span> w1;   <span class="comment">//大于阈值t的像素的个数</span></span><br><span class="line"><span class="keyword">double</span> e1; <span class="comment">//大于阈值t的像素一维熵（用像素个数代替概率）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gray_level, gray_num, gray_arr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> t, t_optm = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; M; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = <span class="number">0</span>; cnt2 &lt; N; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">gray_level = input_img.at&lt;uchar&gt;(cnt1, cnt2);</span><br><span class="line">gray_arr[gray_level] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (t = <span class="number">1</span>; t &lt; <span class="number">254</span>; ++t)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = <span class="number">0</span>;</span><br><span class="line">e0 = e1 = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小于阈值t的像素的参数</span></span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; t; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line">gray_num = gray_arr[cnt1];</span><br><span class="line">w0 += gray_num;</span><br><span class="line"><span class="keyword">if</span> (gray_num != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e0 += gray_num * <span class="built_in">std</span>::<span class="built_in">log</span>(gray_num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大于阈值t像素的参数</span></span><br><span class="line"><span class="keyword">for</span> (cnt2 = t; cnt2 &lt; <span class="number">256</span>; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">gray_num = gray_arr[cnt2];</span><br><span class="line"><span class="comment">//w1 += gray_arr[cnt2]; //（不用累加）</span></span><br><span class="line"><span class="keyword">if</span> (gray_num != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e1 += gray_num * <span class="built_in">std</span>::<span class="built_in">log</span>(gray_num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w1 = <span class="built_in">size</span> - w0;</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">std</span>::<span class="built_in">log</span>(w0) + <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="built_in">size</span> - w0) - <span class="number">2</span> * log_size;</span><br><span class="line">b = log_size - e0 / w0;</span><br><span class="line">c = (log_size*w1 - e1) / w1;</span><br><span class="line"></span><br><span class="line">phi = a + b + c;</span><br><span class="line"><span class="keyword">if</span> (phi &gt; phiMax)</span><br><span class="line">&#123;</span><br><span class="line">t_optm = t;</span><br><span class="line">phiMax = phi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t_optm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>阈值120</strong><br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/entropy_res.png"></p><h3 id="六、失误和总结"><a href="#六、失误和总结" class="headerlink" title="六、失误和总结"></a>六、失误和总结</h3><h4 id="std-log-函数输入范围"><a href="#std-log-函数输入范围" class="headerlink" title="std::log()函数输入范围"></a>std::log()函数输入范围</h4><p>由于没考虑到一个灰度级的像素个数可能为0的情况，导致输入std::log()函数的值为0，输出为nan，后续程序无法运行，后来增加了对某个灰度级像素个数的判断，只有当其不为0时才继续输入std::log()函数，进行基本变量的累加。  </p><div align="center"><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/debug1.jpg">  <p>错误代码   </p><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/debug2.jpg">   <p>考虑0输入代码</p></div><center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/OTSU-and-Entropy.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么是一维熵阈值分割&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C/C++" scheme="http://Jiahaohong.github.io/tags/C-C/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C/C++:OTSU阈值分割</title>
    <link href="http://jiahaohong.github.io/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <id>http://jiahaohong.github.io/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</id>
    <published>2020-10-16T12:50:34.000Z</published>
    <updated>2020-10-25T14:38:44.934Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/OTSU-and-Entropy.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是OTSU阈值分割"><a href="#一、什么是OTSU阈值分割" class="headerlink" title="一、什么是OTSU阈值分割"></a>一、什么是OTSU阈值分割</h3><p>OTSU分割的基本思想是：选择一个阈值分割图像后，两部分的类间方差最大（两个类差异最大），两部分各自的类内方差最小（每个部分比较集中）。  </p><h3 id="二、OTSU公式"><a href="#二、OTSU公式" class="headerlink" title="二、OTSU公式"></a>二、OTSU公式</h3><p><em>注意，为了程序的运行速度，下面的公式和纯数学公式的变量含义稍有差别。</em></p><h4 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h4><p>像素分成两类，每一类像素各自有三个基本变量：</p><ul><li>w 像素总个数</li><li>u 像素加权和（权重为像素灰度）</li><li>v 像素加平方权和（权重为像素灰度的平方）<br>现在给出三个参数的定义，以小于待定阈值t的参数为例，大于阈值t的参数只是修改求和符号的累加范围：  <center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/definition.jpg" width="100"></center></li></ul><h4 id="指标变量"><a href="#指标变量" class="headerlink" title="指标变量"></a>指标变量</h4><p>两类像素各自有衡量自身离散程度的指标：</p><ul><li>delta 方差</li><li>deltaB 类间方差</li><li>deltaW 类内方差</li><li>deltaT 总方差<br>这里给出这些指标变量的表达式：  <center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/index.jpg" width="300"></center></li></ul><h4 id="判决准则"><a href="#判决准则" class="headerlink" title="判决准则"></a>判决准则</h4><p>数学上一共有三个判别准则，这三个准则等价：  </p><center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/res.jpg" width="100"></center>由于总方差和待定阈值无关，所以我们选择第二个判别准则，使第二个公式值最大的阈值t作为最终结果。<h3 id="三、算法思路"><a href="#三、算法思路" class="headerlink" title="三、算法思路"></a>三、算法思路</h3><p>设置一个变量t作为待定的阈值，然后t遍历整个灰度级（实际上1-254即可），每一个t算一个类间方差值，如果这个类间方差值比最大类间方差值大，那么更新最大类间方差值，并将这次的t作为待定阈值。 </p><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">otsu</span><span class="params">(cv::Mat &amp;input_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> M = input_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = input_img.cols;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = M * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> deltaB, deltaW, etaMax = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> w0; <span class="comment">//灰度小于t的像素个数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> w1; <span class="comment">//灰度大于t的像素个数</span></span><br><span class="line"><span class="keyword">double</span> u0; <span class="comment">//灰度小于t的像素的加权和，权重为灰度值（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> u1; <span class="comment">//灰度大于t的像素的加权和，权重为灰度值（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> v0; <span class="comment">//灰度大于t的像素的加权和，权重为灰度值的平方（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> v1; <span class="comment">//灰度大于t的像素的加权和，权重为灰度值的平方（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> u0_2;</span><br><span class="line"><span class="keyword">double</span> u1_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gray_level, gray_arr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> t, t_optm = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计灰度</span></span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; M; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = <span class="number">0</span>; cnt2 &lt; N; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">gray_level = input_img.at&lt;uchar&gt;(cnt1, cnt2);</span><br><span class="line">gray_arr[gray_level] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算最佳阈值t</span></span><br><span class="line"><span class="keyword">for</span> (t = <span class="number">1</span>; t &lt; <span class="number">254</span>; ++t)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = <span class="number">0</span>;</span><br><span class="line">u0 = u1 = v0 = v1 = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; t; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line">w0 += gray_arr[cnt1];</span><br><span class="line">u0 += cnt1 * gray_arr[cnt1];</span><br><span class="line">v0 += cnt1^<span class="number">2</span> * gray_arr[cnt1]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = t; cnt2 &lt; <span class="number">256</span>; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//w1 += gray_arr[cnt2]; //（不用累加）</span></span><br><span class="line">u1 += cnt2 * gray_arr[cnt2];</span><br><span class="line">v1 += cnt2^<span class="number">2</span> * gray_arr[cnt2];</span><br><span class="line">&#125;</span><br><span class="line">w1 = <span class="built_in">size</span> - w0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u0_2 = <span class="built_in">pow</span>(u0, <span class="number">2</span>);</span><br><span class="line">u1_2 = <span class="built_in">pow</span>(u1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//deltaB计算公式</span></span><br><span class="line"><span class="comment">//                     u0   u1            1</span></span><br><span class="line"><span class="comment">//deltaB = w0 * w1 * ( —— - —— )^2 * ——————————</span></span><br><span class="line"><span class="comment">//                     w0   w1       (M * N) ^2</span></span><br><span class="line"></span><br><span class="line">deltaB = w0 * w1 * <span class="built_in">pow</span>( (u0 / w0 - u1 / w1), <span class="number">2</span> ) / <span class="built_in">size</span> / <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delta0计算公式（不用计算） </span></span><br><span class="line"><span class="comment">//         v0     u0</span></span><br><span class="line"><span class="comment">//delta0 = —— - ( —— )^2</span></span><br><span class="line"><span class="comment">//         w0     w0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deltaW计算公式（不用计算）</span></span><br><span class="line"><span class="comment">//            1                u0^2   u1^2</span></span><br><span class="line"><span class="comment">//deltaW  = ————— * ( v0 + v1 - ———— - ———— )</span></span><br><span class="line"><span class="comment">//          M * N                w0     w1</span></span><br><span class="line"><span class="comment">//deltaW = (v0 + v1 - u0_2 / w0 - u1_2 / w1) / size;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deltaB &gt; etaMax)</span><br><span class="line">&#123;</span><br><span class="line">t_optm = t;</span><br><span class="line">etaMax = deltaB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t_optm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>阈值116</strong><br><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/otsu_res.png"></p><h3 id="六、失误和总结"><a href="#六、失误和总结" class="headerlink" title="六、失误和总结"></a>六、失误和总结</h3><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>写完程序后，测试结果总是1，即deltaB运算结果一直为0，调试过程中查看了很多变量也没发现问题，最后鼠标一个个查声明的变量时发现问题：因为<strong>数字1</strong>和<strong>变量size</strong>都是<strong>int类型</strong>的，在进行除法时结果是0，所以之后的计算结果一直为0，达不到预期效果。<br><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/debug1.jpg"></p><h4 id="double类型的表示范围"><a href="#double类型的表示范围" class="headerlink" title="double类型的表示范围"></a>double类型的表示范围</h4><p>最初采用的判别标准是namda公式，在计算deltaW的时候由于u0和u1变量中有一个会很大，导致其平方会超出double表示范围，体现的结果就是deltaW出现负值，而在数学上这个值应该恒为正（两个平方数相加）。之后考虑到计算量，采用了eta公式，并且只用计算deltaB，简化了计算。  </p><center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/OTSU-and-Entropy.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么是OTSU阈值分割&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C/C++" scheme="http://Jiahaohong.github.io/tags/C-C/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C/C++:中值滤波和均值滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-16T08:35:07.000Z</published>
    <updated>2020-10-25T14:26:47.781Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、中值滤波"><a href="#一、中值滤波" class="headerlink" title="一、中值滤波"></a>一、中值滤波</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h4><p>针对椒盐噪声设计。因为椒盐噪声的幅值和原图像差异很大，所以在模板中一半分布在最大或最小值附近，而原图像的灰度分布相对接近，通过取模板中间值，可以滤掉椒盐噪声。</p><h4 id="2-文件结构"><a href="#2-文件结构" class="headerlink" title="2.文件结构"></a>2.文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-read orig img</span><br><span class="line">|</span><br><span class="line">|-convert gray img</span><br><span class="line">|</span><br><span class="line">|-add impulse noise</span><br><span class="line">|</span><br><span class="line">|-middle filt</span><br><span class="line">|</span><br><span class="line">|-result output</span><br></pre></td></tr></table></figure><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">middle_filter</span><span class="params">(cv::Mat &amp;input_img, <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat output_img = input_img.clone();</span><br><span class="line">cv::Mat filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line">cv::Mat sorted_filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line"><span class="keyword">int</span> M = output_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = output_img.cols;</span><br><span class="line"><span class="keyword">int</span> offset = (<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, cnt3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (cnt1 = offset; cnt1 &lt; M-offset; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = offset; cnt2 &lt; N-offset; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//将模板所在位置的图像灰度取出</span></span><br><span class="line"><span class="keyword">for</span> (cnt3 = <span class="number">0</span>; cnt3 &lt; <span class="built_in">size</span>*<span class="built_in">size</span>; ++cnt3)</span><br><span class="line">&#123;</span><br><span class="line">filter.at&lt;uchar&gt;(<span class="number">0</span>, cnt3)</span><br><span class="line">                    = input_img.at&lt;uchar&gt;</span><br><span class="line">                        ( cnt1+(cnt3/<span class="built_in">size</span><span class="number">-1</span>), cnt2+(cnt3%<span class="built_in">size</span><span class="number">-1</span>) );<span class="comment">//位置换算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择排序</span></span><br><span class="line">sorted_filter = seek_sort(filter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模板中心图像灰度取模板中间值</span></span><br><span class="line">output_img.at&lt;uchar&gt;(cnt1, cnt2)</span><br><span class="line">                = sorted_filter.at&lt;uchar&gt;(<span class="number">0</span>, (<span class="built_in">size</span>*<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> output_img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4.实验结果"></a>4.实验结果</h4><p>实验结果如下，可以看到椒盐噪声被很好的滤除了（图像边沿保留了原值）。但同时图像也变得模糊，随着模板的增大这一现象更加明显。<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/middle.png">  </p><h3 id="二、均值滤波"><a href="#二、均值滤波" class="headerlink" title="二、均值滤波"></a>二、均值滤波</h3><h4 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h4><p>针对高斯噪声设计。滤波器取均值。由于高斯噪声满足高斯分布，所以噪声在每个灰度级上都会存在，但是平均值是一个定值，因此采用平均值滤波可以有效滤除高斯噪声。  </p><h4 id="2-文件结构-1"><a href="#2-文件结构-1" class="headerlink" title="2.文件结构"></a>2.文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-read orig img</span><br><span class="line">|</span><br><span class="line">|-convert gray img</span><br><span class="line">|</span><br><span class="line">|-add gauss noise</span><br><span class="line">|</span><br><span class="line">|-average filt</span><br><span class="line">|</span><br><span class="line">|-result output</span><br></pre></td></tr></table></figure><h4 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">avrg_filter</span><span class="params">(cv::Mat &amp;input_img, <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat output_img = input_img.clone();</span><br><span class="line">cv::Mat filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line">cv::Mat sorted_filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line"><span class="keyword">int</span> M = output_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = output_img.cols;</span><br><span class="line"><span class="keyword">int</span> offset = (<span class="built_in">size</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, cnt3;</span><br><span class="line"><span class="keyword">double</span> avg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (cnt1 = offset; cnt1 &lt; M - offset; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = offset; cnt2 &lt; N - offset; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">avg = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将模板所在位置的图像灰度取出</span></span><br><span class="line"><span class="keyword">for</span> (cnt3 = <span class="number">0</span>; cnt3 &lt; <span class="built_in">size</span>*<span class="built_in">size</span>; ++cnt3)</span><br><span class="line">&#123;</span><br><span class="line">avg += input_img.at&lt;uchar&gt;</span><br><span class="line">                    (cnt1 + (cnt3 / <span class="built_in">size</span> - offset), </span><br><span class="line">                     cnt2 + (cnt3%<span class="built_in">size</span> - offset));</span><br><span class="line">&#125;</span><br><span class="line">avg /= <span class="built_in">size</span> * <span class="built_in">size</span>;</span><br><span class="line">output_img.at&lt;uchar&gt;(cnt1, cnt2) = (uchar)avg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> output_img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实验结果-1"><a href="#4-实验结果-1" class="headerlink" title="4.实验结果"></a>4.实验结果</h4><p>实验结果如下，也存在随着模板的增大图像变模糊的现象。<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/average.png"> </p><h3 id="三、滤波效果对比"><a href="#三、滤波效果对比" class="headerlink" title="三、滤波效果对比"></a>三、滤波效果对比</h3><h4 id="1-中值滤波对高斯噪声"><a href="#1-中值滤波对高斯噪声" class="headerlink" title="1.中值滤波对高斯噪声"></a>1.中值滤波对高斯噪声</h4><p>高斯分布均值：0<br>高斯分布方差：10<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/middle_gauss.png"></p><h4 id="2-均值滤波对椒盐噪声"><a href="#2-均值滤波对椒盐噪声" class="headerlink" title="2.均值滤波对椒盐噪声"></a>2.均值滤波对椒盐噪声</h4><p>椒盐噪声信噪比：0.95<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/average_impulse.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由上实验结果可知，中值滤波和均值滤波都有自己的特殊作用，都不是两全其美的滤波方法。  </p><center><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、中值
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C/C++" scheme="http://Jiahaohong.github.io/tags/C-C/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Opencv:在VisualStudio里配置Opencv</title>
    <link href="http://jiahaohong.github.io/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/"/>
    <id>http://jiahaohong.github.io/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/</id>
    <published>2020-10-14T08:32:46.000Z</published>
    <updated>2020-10-14T11:54:33.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一年前学数据结构时配置过Opencv，现在有新工程需要使用Opencv，索性写一篇博客记录下配置过程，希望以后不会忘记。</p><h3 id="1-下载Opencv"><a href="#1-下载Opencv" class="headerlink" title="1.下载Opencv"></a>1.下载Opencv</h3><p>首先得确定你的设备的系统位数，32位还是64位，还要确定你的VisualStudio的版本。我的电脑是x64系统，VisualStudio是2017版。所以我下了4.1.1版本x64平台的Opencv，下载之后将那个exe跑起来，解压Opencv你想要的位置，记住这个位置。</p><h3 id="2-新建工程"><a href="#2-新建工程" class="headerlink" title="2.新建工程"></a>2.新建工程</h3><p>Visual Studio新建空工程文件，OK。</p><h3 id="3-配置工程属性"><a href="#3-配置工程属性" class="headerlink" title="3.配置工程属性"></a>3.配置工程属性</h3><p>在左侧的“解决方案资源管理器”中右键单击你的工程名字，选择弹出选项的最后一个“属性”进行配置。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/0.jpg">  </p><h4 id="3-1“配置和平台”的选择"><a href="#3-1“配置和平台”的选择" class="headerlink" title="3.1“配置和平台”的选择"></a>3.1“配置和平台”的选择</h4><p>我的选择的是“所有配置”和“x64”平台。配置选项也可以选择“Debug”。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/1-1.jpg">  </p><h4 id="3-2“C-C-常规”项的配置"><a href="#3-2“C-C-常规”项的配置" class="headerlink" title="3.2“C\C++常规”项的配置"></a>3.2“C\C++常规”项的配置</h4><p>编辑附加包含目录，将你的Opencv里的<strong>include</strong>文件夹的绝对路径填写进去。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/1.jpg"></p><h4 id="3-3“链接器常规”项的配置"><a href="#3-3“链接器常规”项的配置" class="headerlink" title="3.3“链接器常规”项的配置"></a>3.3“链接器常规”项的配置</h4><p>编辑附加库目录，如图。我的VisualStudio是2017版的，选择v14和v15都可以。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/2.jpg"></p><h4 id="3-4“链接器输入”项的配置"><a href="#3-4“链接器输入”项的配置" class="headerlink" title="3.4“链接器输入”项的配置"></a>3.4“链接器输入”项的配置</h4><p>编辑附加依赖项，将v15\bin文件夹里的opencv_worldxxx.dll和opencv_worldxxx<strong>d</strong>.dll两个文件名字写进去。注意，这个xxx代表的是你下的opencv版本号，比如4.1.1版就是411。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/3.jpg"></p><h3 id="4-移动-dll文件"><a href="#4-移动-dll文件" class="headerlink" title="4.移动.dll文件"></a>4.移动.dll文件</h3><p>最后一步，还记得之前v15\bin文件夹里的两个dll文件吗？将他们复制粘贴到C:\Windows\System32文件夹里，OK。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/4.jpg"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一年前我还配置过系统环境变量，但是这次没有配置也成功了，仔细检查过系统PATH和用户Path变量后也没有发现一年前配置过的那个变量。所以环境变量可能不是必须的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一年前学数据结构时配置过Opencv，现在有新工程需要使用Opencv，索性写一篇博客记录下配置过程，希望以后不会忘记。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Opencv" scheme="http://Jiahaohong.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:同态滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-06T02:51:54.000Z</published>
    <updated>2020-10-25T14:26:28.778Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是同态滤波"><a href="#一、什么是同态滤波" class="headerlink" title="一、什么是同态滤波"></a>一、什么是同态滤波</h3><p>根据成像原理，一幅图像可以分成两种成分的乘积叠加，一种成分是入射的光强<strong>L(x,y)</strong>，另一种是反射到人眼中的光强<strong>R(x,y)</strong>，二者是乘性叠加，所以一幅图像可以表示为<strong>F(x,y)=L(x,y)*R(x,Y)</strong>。<br>同态滤波通过将图像取对数，<strong>ln(F(x,y))=ln(L(x,y))+ln(R(x,y))</strong>，将乘性耦合的入射光和反射光成分解耦，变成加性耦合，这样就可以利用线性性分别对两种成分进行滤波处理。由于反射光强一般是高频成分，而入射光强是低频成分，所以用高通滤波器可以将入射光成分滤掉，得到更加清楚的细节。同态滤波是通过物理规律将图像进行分解操作，滤波器是在滤波过程中的一种频率选择方法，同态滤波并没有设计一种新的滤波器。</p><h3 id="二、同态滤波实现"><a href="#二、同态滤波实现" class="headerlink" title="二、同态滤波实现"></a>二、同态滤波实现</h3><h4 id="同态滤波结构"><a href="#同态滤波结构" class="headerlink" title="同态滤波结构"></a>同态滤波结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">homomophic filter</span><br><span class="line">|</span><br><span class="line">|-log_img &#x3D; log(img + 1)</span><br><span class="line">|</span><br><span class="line">|-ft_img &#x3D; fft(img)</span><br><span class="line">|</span><br><span class="line">|-h_img &#x3D; ft_img.*H</span><br><span class="line">|</span><br><span class="line">|-ift_img &#x3D; ifft(h_img)</span><br><span class="line">|</span><br><span class="line">|-res_img &#x3D; exp(ift_img) - 1</span><br></pre></td></tr></table></figure><h4 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">homomorphic_filt</span><span class="params">( input_img, rL, rH, c, d )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%同态滤波参数设置</span></span><br><span class="line">    <span class="comment">%rL = 0.1; %低频放大系数</span></span><br><span class="line">    <span class="comment">%rH = 5; %高频放大系数</span></span><br><span class="line">    <span class="comment">%c = 0.2; %高斯变换常数系数</span></span><br><span class="line">    <span class="comment">%d = 8000; %高斯变换系数</span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    input_img = double(input_img);</span><br><span class="line"></span><br><span class="line">    log_img = <span class="built_in">log</span>(input_img+<span class="number">1</span>);</span><br><span class="line">    ft_img = fft2(log_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%构造高斯滤波器</span></span><br><span class="line">    H = <span class="built_in">zeros</span>(M,N);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            D = (<span class="built_in">i</span>.^<span class="number">2</span>+<span class="built_in">j</span>.^<span class="number">2</span>);</span><br><span class="line">            H(<span class="built_in">i</span>,<span class="built_in">j</span>) = (rH-rL).*(<span class="number">1</span>-<span class="built_in">exp</span>(-c.*(D./(d^<span class="number">2</span>))))+rL;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    filted_img = H.*ft_img;</span><br><span class="line">    ift_img = ifft2(filted_img);</span><br><span class="line">    exp_img = <span class="built_in">exp</span>(ift_img)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    output_img = uint8(<span class="built_in">abs</span>(exp_img));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="有关中心化的处理"><a href="#有关中心化的处理" class="headerlink" title="有关中心化的处理"></a>有关中心化的处理</h4><p>参考了许多CSDN网站上的博客，发现他们都有将高斯滤波器中心化的操作，但是我个人认为这是不必要的操作，仅仅是坐标轴的变换而已。<br>我们来分类讨论一下，如果图像的傅里叶变换没有进行平移操作（fftshift），那么结果的左上角是低频成分，沿着x、y轴坐标增加的方向，频率逐渐增高，那么高通滤波器应该如何设置呢？以左上角为原点，到远点的距离为变量即可构造高斯高通滤波器。但是如果以图片中心点为原点，这时候H需要进行平移，将它和图像的傅里叶变换结果的高低频区域对齐。</p><h3 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h3><center>原图</center>  <img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/1.jpg">  <center>灰度图</center>  <img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/gray.jpg">  <center>变换后的图</center>  <img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/0_2-2-0_2-1000.jpg">  <p>可以看出变换后的图像有明显的二值化现象，图片的展现效果不好。</p><h3 id="四、失误与总结"><a href="#四、失误与总结" class="headerlink" title="四、失误与总结"></a>四、失误与总结</h3><h4 id="图像二值化的原因及改进"><a href="#图像二值化的原因及改进" class="headerlink" title="图像二值化的原因及改进"></a>图像二值化的原因及改进</h4><p>在调试过程中，发现取指数后的矩阵元素的值非常小，所以在之后的取整等操作无法反映图像的真实灰度，因此需要将取对数后的图像的灰度拓展到0到255。改进策略是将指数图像的最大最小值取出，然后将指数图像与最小值的差按比例放大到0到255。<br><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/error1.jpg">  </p><center>取指数后的图像矩阵部分元素</center>  <ul><li>改进后的代码 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">homomorphic_filt</span><span class="params">( input_img, rL, rH, c, d )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%同态滤波参数设置</span></span><br><span class="line">    <span class="comment">%rL = 0.1; %低频放大系数</span></span><br><span class="line">    <span class="comment">%rH = 5; %高频放大系数</span></span><br><span class="line">    <span class="comment">%c = 0.2; %高斯变换常数系数</span></span><br><span class="line">    <span class="comment">%d = 8000; %高斯变换系数</span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    input_img = double(input_img);</span><br><span class="line"></span><br><span class="line">    log_img = <span class="built_in">log</span>(input_img+<span class="number">1</span>);</span><br><span class="line">    ft_img = fft2(log_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%构造高斯滤波器</span></span><br><span class="line">    H = <span class="built_in">zeros</span>(M,N);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            D = (<span class="built_in">i</span>.^<span class="number">2</span>+<span class="built_in">j</span>.^<span class="number">2</span>);</span><br><span class="line">            H(<span class="built_in">i</span>,<span class="built_in">j</span>) = (rH-rL).*(<span class="number">1</span>-<span class="built_in">exp</span>(-c.*(D./(d^<span class="number">2</span>))))+rL;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    filted_img = H.*ft_img;</span><br><span class="line">    ift_img = ifft2(filted_img);</span><br><span class="line">    exp_img = <span class="built_in">exp</span>(ift_img);</span><br><span class="line">    output_img = </span><br><span class="line">        uint8( <span class="number">255</span> * ( exp_img - <span class="built_in">ones</span>(M,N)*<span class="built_in">min</span>(<span class="built_in">min</span>(exp_img)) ) </span><br><span class="line">                / ( <span class="built_in">max</span>(<span class="built_in">max</span>(exp_img)) - <span class="built_in">min</span>(<span class="built_in">min</span>(exp_img)) ) );</span><br><span class="line">    <span class="comment">%output_img = uint8(abs(exp_img));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>改进后实验结果<img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/homofilt.jpg">  <center>改进后变换后的图</center></li></ul><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><p>这次的实验参数较多，调参的过程比设计算法的过程还要长，但是通过调参也能够理解各个参数的对图像的影响。比如d和rH的作用又互相抵消的效果，c参数会让图片整体明暗发生变化。至于为什么会出现这些现象，还是要从原理入手，这里还需研究。如果有可能的话，之后会制作四个参数在一定范围内变化的图像效果变化动图，更加直观的显示四个参数的影响。  </p><center><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:直方图均衡化</title>
    <link href="http://jiahaohong.github.io/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/"/>
    <id>http://jiahaohong.github.io/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</id>
    <published>2020-10-05T10:37:57.000Z</published>
    <updated>2020-10-25T14:26:31.356Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是直方图均衡化"><a href="#一、什么是直方图均衡化" class="headerlink" title="一、什么是直方图均衡化"></a>一、什么是直方图均衡化</h3><h4 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h4><p>原图的灰度直方图形象的反映了图片整体的明暗程度，横轴为像素灰度级，范围是0到255，纵轴是各个灰度的像素个数占总像素的比。当图片偏亮时，灰度级高的像素占比大，当图片偏暗时，灰度级低的像素占比大。  </p><h4 id="均衡化"><a href="#均衡化" class="headerlink" title="均衡化"></a>均衡化</h4><p>均衡化的意义是将所有灰度级的像素出现概率调整成一致的，但是这只在连续情况下有效，一般来说，离散的图像灰度级均衡化后各级的概率是不一样的。</p><h4 id="为什么要均衡化"><a href="#为什么要均衡化" class="headerlink" title="为什么要均衡化"></a>为什么要均衡化</h4><p>根据香农信息的定义，图像在灰度均匀出现时所携带的信息量最大，因此，过亮或过暗的图片携带的信息都很少，不利于人眼等的分辨，直方图均衡化可以尽可能的增加图像的信息量。</p><h3 id="二、直方图均衡化的实现"><a href="#二、直方图均衡化的实现" class="headerlink" title="二、直方图均衡化的实现"></a>二、直方图均衡化的实现</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-histogram_equalize %直方图均衡化</span><br><span class="line">| |</span><br><span class="line">| |-count_gray %统计灰度直方图</span><br><span class="line">| |-acc_gray   %计算累计直方图</span><br></pre></td></tr></table></figure><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">histogram_equalize</span><span class="params">( input_img )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    output_img = <span class="built_in">zeros</span>(M,N); <span class="comment">%初始化输出图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%统计原图像灰度直方图</span></span><br><span class="line">    gray_histogram = count_gray(input_img);</span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">25565</span>);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    bar(gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'orig gray histogram'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%计算累计直方图</span></span><br><span class="line">    acc_gray_histogram = acc_gray(gray_histogram);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    bar(acc_gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'acc gray histogram'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%灰度转换</span></span><br><span class="line">    gray_trans = acc_gray_histogram*<span class="number">255</span>;</span><br><span class="line">    gray_trans = uint8(<span class="built_in">round</span>(gray_trans));</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    bar(gray_trans);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'gray trans'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            gray_level = input_img(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">            output_img(<span class="built_in">i</span>,<span class="built_in">j</span>) = gray_trans(gray_level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    output_img = uint8(output_img);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%统计转换后图像的灰度直方图</span></span><br><span class="line">    new_gray_histogram = count_gray(output_img);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    bar(new_gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'new gray histogram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="统计灰度直方图"><a href="#统计灰度直方图" class="headerlink" title="统计灰度直方图"></a>统计灰度直方图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ gray_histogram ]</span> = <span class="title">count_gray</span><span class="params">( input_img )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%建立和灰度级登场的数组，数组下标就是灰度级，数组内容为该灰度级的像素出现概率</span></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    gray_histogram = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            gray_level = input_img(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">            gray_histogram(gray_level+<span class="number">1</span>) = gray_histogram(gray_level+<span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    gray_histogram = gray_histogram / M / N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="计算累计直方图"><a href="#计算累计直方图" class="headerlink" title="计算累计直方图"></a>计算累计直方图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ acc_gray_histogram ]</span> = <span class="title">acc_gray</span><span class="params">( gray_histogram )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(gray_histogram);</span><br><span class="line">    acc_gray_histogram = <span class="built_in">zeros</span>(M,N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%将每个灰度级加上前一个灰度级和本灰度级的概率</span></span><br><span class="line">    acc_gray_histogram(<span class="number">1</span>) = gray_histogram(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:N</span><br><span class="line">        acc_gray_histogram(<span class="built_in">i</span>) = gray_histogram(<span class="built_in">i</span>)+acc_gray_histogram(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h3><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/hw_all.jpg" width="800"><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/hw_all_data.jpg" width="800"><center>图1</center><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/dark_all.jpg" width="800"><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/dark_all_data.jpg" width="800"><center>图2</center><h3 id="四、失误与总结"><a href="#四、失误与总结" class="headerlink" title="四、失误与总结"></a>四、失误与总结</h3><h4 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h4><p>由于对matlab的数组下表还是不太熟悉，统计灰度图那里一直报错索引问题，后来查出是图像中有灰度为0的像素，但是数组下标没有0，而是从1开始，所以统计灰度的时候图片像素大小都加了1，转换的时候也是。</p><h4 id="figure覆盖"><a href="#figure覆盖" class="headerlink" title="figure覆盖"></a>figure覆盖</h4><p>由于以前显示的时候总会覆盖之前的figure，所以我索性把函数里的figure值设得非常大，就不会出现覆盖的问题，后来查到代码<strong>hold on</strong>也有同样的效果。</p><h4 id="bar柱状图"><a href="#bar柱状图" class="headerlink" title="bar柱状图"></a>bar柱状图</h4><p>柱状图的命名，限制范围和普通plot图一样，输入可以是x数组和有数组，x、y一一对应，也可以是一个一维数组，这样数组下标作为x轴。    </p><center><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Linux:Ubuntu18.04小白安装教程</title>
    <link href="http://jiahaohong.github.io/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://jiahaohong.github.io/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2020-09-25T23:38:59.000Z</published>
    <updated>2020-11-05T04:50:45.329Z</updated>
    
    <content type="html"><![CDATA[<p><em>本教程原系统Windows10</em><br><em>安装Ubuntu18.04.3版本</em><br><em>电脑联想Y7000</em><br><em>手机华为P10</em> </p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p><a href="https://releases.ubuntu.com/18.04.5/ubuntu-18.04.5-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu18.05下载</a>  </p></li><li><p>8G U盘一个</p></li><li><p>能上网的手机一个</p></li></ul><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p><em><strong>注意之后提到的按键以平台为准，可能和你的电脑或手机不一样</strong></em></p><h4 id="0-分配一块磁盘空间"><a href="#0-分配一块磁盘空间" class="headerlink" title="0.分配一块磁盘空间"></a>0.分配一块磁盘空间</h4><p>首先我们需要从WIN10管理下的磁盘里分出一块空间给Ubuntu。注意这不是新建一个分区，而是压缩出一个未分配的空间。</p><h4 id="1-制作启动盘"><a href="#1-制作启动盘" class="headerlink" title="1. 制作启动盘"></a>1. 制作启动盘</h4><p>WIN10下用文件资源管理器打开上面下载的ISO文件，把里面的文件全部复制粘贴到U盘里。<strong>接下来的操作不要拔下U盘</strong>。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ISO.jpg"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ISO2.jpg"></p><h4 id="2-重启电脑进入BIOS"><a href="#2-重启电脑进入BIOS" class="headerlink" title="2. 重启电脑进入BIOS"></a>2. 重启电脑进入BIOS</h4><p>重启电脑，在<strong>电脑重新开启之前</strong>按住F2键不放，然后进入BIOS界面。<strong>注意每个厂家生产的电脑进入BIOS的键不一样</strong>，我的联想Y7000是F2键，其他电脑的快捷键可以去网上查。  </p><h4 id="3-修改安全启动项SecurityBoot"><a href="#3-修改安全启动项SecurityBoot" class="headerlink" title="3. 修改安全启动项SecurityBoot"></a>3. 修改安全启动项SecurityBoot</h4><p>左右键切换页面到Security界面，上下键选择到SecurityBoot项，按下F5键将其改为Disable。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/SecurityBoot.jpg">  </p><h4 id="4-将启动盘（U盘）启动优先级调到第一"><a href="#4-将启动盘（U盘）启动优先级调到第一" class="headerlink" title="4. 将启动盘（U盘）启动优先级调到第一"></a>4. 将启动盘（U盘）启动优先级调到第一</h4><p>左右键切换页面到Boot界面，上下键选择到U盘启动项，一般来说后面<strong>括号</strong>里显示的是你<strong>U盘的型号</strong>那个就是启动盘，按F6键将其上移到第一个。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Boot.jpg"></p><h4 id="5-保存修改并重启"><a href="#5-保存修改并重启" class="headerlink" title="5. 保存修改并重启"></a>5. 保存修改并重启</h4><p>按F10键保存BIOS修改，弹出确认框，左右键选择Yes后回车，系统自动关机，重新打开电脑即可进入U盘里的启动项。</p><h4 id="6-选择安装Ubuntu项"><a href="#6-选择安装Ubuntu项" class="headerlink" title="6. 选择安装Ubuntu项"></a>6. 选择安装Ubuntu项</h4><p>进入U盘里的启动项后，选择Install Ubuntu选项安装Ubuntu系统。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Install.jpg"></p><h4 id="7-连接手机"><a href="#7-连接手机" class="headerlink" title="7. 连接手机"></a>7. <strong>连接手机</strong></h4><p>注意，这是很重要的一步，之后的自动更新需要用到手机的网络。用USB线连接手机和电脑，这时手机上会显示几个选项，选择传输文件（点了之后弹窗就没了）。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone1.jpg" width="200" height="200"><br>找到设置-&gt;移动网络-&gt;移动网络共享，打开USB共享网络。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone4.jpg" width="200" height="400"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone2.jpg" width="200" height="400"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone3.jpg" width="200" height="400"><br>这时候，Ubuntu安装界面右上角出现一个图标就表示电脑已经连上网了。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Wireless.png"></p><p>现在万事俱备，进入Ubuntu安装程序后，跟着他的步骤一步一步来。</p><h4 id="8-键盘布局"><a href="#8-键盘布局" class="headerlink" title="8. 键盘布局"></a>8. 键盘布局</h4><p>键盘布局选择汉语。</p><h4 id="9-连接wifi无线网络"><a href="#9-连接wifi无线网络" class="headerlink" title="9. 连接wifi无线网络"></a>9. 连接wifi无线网络</h4><p>选择不想连接，因为手机已经共享了。  </p><h4 id="10-更新和其他软件"><a href="#10-更新和其他软件" class="headerlink" title="10. 更新和其他软件"></a>10. 更新和其他软件</h4><p>选择最小安装，并且安装第三方软件。安装第三方软件需要之前手机的网络，大概两三百MB。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/update.jpg"></p><h4 id="11-安装类型"><a href="#11-安装类型" class="headerlink" title="11. 安装类型"></a>11. 安装类型</h4><p>选择和Win10Boot共存的那个选项。<strong>WARNING:如果你不清楚Ubuntu系统准备安装在哪个磁盘上，千万不要选择“删除整个磁盘文件后安装”哪个选项！如果你只有这一个“删除整个磁盘文件后安装”选项，那么请不要继续安装！！！</strong></p><h4 id="12-等待安装完成！"><a href="#12-等待安装完成！" class="headerlink" title="12. 等待安装完成！"></a>12. 等待安装完成！</h4><p>这个安装方式十分方便，安装完成后可以直接用，不需要自己再配置什么驱动，独立显卡驱动除外，之后可能会有一篇博客讲解Nvidia独显驱动安装。总结：见文章内容导航！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本教程原系统Windows10&lt;/em&gt;&lt;br&gt;&lt;em&gt;安装Ubuntu18.04.3版本&lt;/em&gt;&lt;br&gt;&lt;em&gt;电脑联想Y7000&lt;/em&gt;&lt;br&gt;&lt;em&gt;手机华为P10&lt;/em&gt; &lt;/p&gt;
&lt;h3 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class
      
    
    </summary>
    
    
      <category term="Linux学习之路" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://Jiahaohong.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:快速傅里叶变换实现</title>
    <link href="http://jiahaohong.github.io/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jiahaohong.github.io/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-19T19:13:55.000Z</published>
    <updated>2020-10-25T13:49:32.849Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/FFT.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是傅里叶变换"><a href="#一、什么是傅里叶变换" class="headerlink" title="一、什么是傅里叶变换"></a>一、什么是傅里叶变换</h3><p>简单来说，傅里叶变换将一个函数分解为一组三角函数的和，通过将这个函数分别和这组三角函数中的每一个进行内积运算，可以求得每个三角函数前面的系数。  </p><h4 id="正交函数集"><a href="#正交函数集" class="headerlink" title="正交函数集"></a>正交函数集</h4><p>正交函数集满足如下两条性质：  </p><ol><li>正交函数集中的任意两个不相同函数的内积为0；  </li><li>如果某函数集中存在一个函数可以由函数集中除它以外的函数表示，则这个函数集不是正交函数集。  </li></ol><p>用类比的角度看，这个定义和线性代数中的基向量组的定义一致。说明正交函数集其实相当于函数空间中的一组基向量，函数空间中的一个函数对应向量空间中的一个向量，任何向量可以由基向量表示，同样的，任何函数可以由正交函数集表示。基向量可以写成矩阵的形式，同理，正交函数集也可以写成向量的形式。如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  这是一个1维向量，当前乘一个函数时就可以利用矩阵的乘法将函数分解到这个正交函数集上。  <center>[f(x)] * [1, sin(wx), cos(wx), ..., sin(nwx), cos(nwx), ...] =</center>  <center>[a0, b1*sin(wx), a1*cos(wx), ..., bn*sin(nwx), an*cos(nwx), ...]</center>  注意这些系数通过原函数f(x)和基函数内积等运算得到的。  <h4 id="内积运算"><a href="#内积运算" class="headerlink" title="内积运算"></a>内积运算</h4><p>内积定义为向量a在向量b上的投影向量，当内积运算后的结果除以向量b的模长，就可以计算出向量a在向量b上投影占向量b的比例，这个比例就是基函数前面的系数。内积是反映两个向量相似度的重要指标，当两个向量完全相等时，它们的内积取得最大值。因此正交函数集的系数的含义，可以理解为原函数和基函数的相似度，相似度越大，这个基函数的系数越大。</p><p>因此，总体上来看，正交函数集构成了一个无穷维数的函数空间，这个空间里的任何函数都可以由这些基函数的加权求和表示，权重就是原函数和积函数的内积，及将原函数投影到这些正交函数上。当然可以用欧拉公式将这些三角基函数合并指数基函数，只不过这些基函数建立在复数域内了，后面的快速傅里叶实现也采用复数域内的正交函数集。  </p><h3 id="二、离散傅里叶变换"><a href="#二、离散傅里叶变换" class="headerlink" title="二、离散傅里叶变换"></a>二、离散傅里叶变换</h3><p>第一部分中讲到傅里叶变换是连续函数空间里的，如果处理的函数是一个离散的函数，那么就要用到离散傅里叶变换。离散傅里叶变换与来连续傅里叶变换的最大区别是求系数时的积分运算变成了求和运算。将正交函数集的向量形式抄写如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  注意，这里的每一列都是一个连续函数，如果用离散的x坐标将其离散化，就可以获得离散傅里叶变换的正交函数集矩阵，如下：<div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/DMat.jpg" width="500" height="280"></div><p>这是一个二维矩阵，每一列代表一个正交函数，每一行坐标代表一个离散坐标x。将离散函数写成向量的形式后就可以用矩阵的乘法求出变换后的函数。这时有人会注意到，这个离散的矩阵两个维度都是无穷的，如果离散信号不一定是无穷的，那怎么运算呢？我们分别讨论一下：  </p><ol><li>变换矩阵的行数<br>如果要满足矩阵乘法定义，那么变换矩阵的行的个数必须和输入信号的变量取值范围相同，及与x的取值范围一致。如果输入信号的取值范围是无穷的，那么变换矩阵的行也有无数个。</li><li>变换矩阵的列数<br>由于变换矩阵的列数没有严格的定义，可多可少，但是由于每一列代表一种基函数，基函数的个数决定了表达的误差，一般来说和输入变量的x取值范围相同即可。</li></ol><h3 id="三、一维快速傅里叶变换的原理"><a href="#三、一维快速傅里叶变换的原理" class="headerlink" title="三、一维快速傅里叶变换的原理"></a>三、一维快速傅里叶变换的原理</h3><p>快速傅里叶变换有许多种，这里介绍的快速傅里叶变换通过将冗余的指数运算记录下来，以此减少乘法次数，加快运算速度。一维离散傅里叶公式如下：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1D.jpg" width="290" height="55"></div>  能否找到冗余计算？看样子很难，这里直接给出简化算法的核心公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo.jpg" width="280" height="50"></div>  这个公式其实很简单，本质就是一个约分，但是这个约分给我们提供了分离傅里叶变换的思路——奇偶分离。当一维傅里叶变换的输入信号的变量取值范围是2的整数倍，那么一维傅里叶变换的求和可以分为奇数部分求和、偶数部分求和，如下公式所示：<div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo2.jpg" width="500" height="200"></div>  看出来了吗？这里奇数部分和偶数部分有相同的分量，取值范围都是从0到M-1，你能看出来它也是傅里叶变换公式吗？下面这个公式将更加清晰：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo3.jpg" width="450" height="100"></div>    其中g(x)部分是原函数中自变量x取偶数时组成的新函数，h(x)是原函数自变量取奇数时组成的函数，将他们看成新的原函数，那么奇数部分和偶数部分就都是新的一维离散傅里叶变换了。这说明，原函数自变量取值范围是偶数时，原函数的傅里叶变换可以由自变量是偶数部分的傅里叶变换和自变量是奇数部分的傅里叶变换组合而成，并且这两部分互不影响。这是一个重要的结论，为后面的递归提供依据。为了方便书写，我们将偶数部分的傅里叶变换记作F<sub>even</sub>(u)，将奇数部分的傅里叶变换记作F<sub>odd</sub>(u)，那么一维傅里叶变换可以写成如下公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo4.jpg" width="290" height="55"></div>  必须要注意的是，上述公式的奇数部分和偶数部分都是N/2个，那么根据一般变换后自变量取值范围和原函数相同，可以知道u的取值范围从原来的N变成了N/2，那么后面一半怎么补全呢？我们再来看两个核心公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo5.jpg" width="200" height="110"></div>   将这两个公式带入F(u+M)，就可以算出后半部分其表达式。<h3 id="四、二维傅里叶变换的性质"><a href="#四、二维傅里叶变换的性质" class="headerlink" title="四、二维傅里叶变换的性质"></a>四、二维傅里叶变换的性质</h3><p>第三部分讲到一维离散傅里叶快速变换的基本原理，但对于二维快速傅里叶变换这还不够，我们需要探讨一下二维傅里叶变换的基本性质，才能将一维的变换应用到二维的求解中。在讨论二维傅里叶变换的性质之前，我们给出其定义公式：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2D.png" width="290" height="55"></div>   <h4 id="可分离性"><a href="#可分离性" class="headerlink" title="可分离性"></a>可分离性</h4><p>根据二维傅里叶变换的公式，可以比较轻松地看出，中括号里的计算是不涉及变量x的，换句话说，中括号里的计算是需要事先给定x的值，然后再计算，x在这里相当于一个常数，因此可以将中括号里面和外面的计算分离。这样，一个二维的傅里叶变换就变成了两个一维傅里叶变换：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2DCoreAlgo.jpg" width="420" height="95"></div>  <h4 id="平移性"><a href="#平移性" class="headerlink" title="平移性"></a>平移性</h4><p>二维傅里叶变换的平移性质和一维傅里叶变换的平移性质一脉相承，只不过一维中讲的是时域的平移，二维中讲的是空域的平移。这个性质在之后对图像的二维傅里叶变换中将要用到。    </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2DCoreAlgo2.jpg" width="400" height="160"></div>  <h3 id="五、二维快速傅里叶变换的实现"><a href="#五、二维快速傅里叶变换的实现" class="headerlink" title="五、二维快速傅里叶变换的实现"></a>五、二维快速傅里叶变换的实现</h3><p>原理和性质都讲完了，接下来讲讲如何实现二维快速傅里叶变换。<br><em>本次使用软件MATLAB R2017a</em></p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-image input</span><br><span class="line">|</span><br><span class="line">|-myft3</span><br><span class="line">| |</span><br><span class="line">| |-myfft</span><br><span class="line">| |(recursion)</span><br><span class="line">|</span><br><span class="line">|-shift myft3</span><br><span class="line">|</span><br><span class="line">|-ifft2</span><br></pre></td></tr></table></figure><h4 id="图像输入"><a href="#图像输入" class="headerlink" title="图像输入"></a>图像输入</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origImg = imread(<span class="string">'2.jpg'</span>);</span><br><span class="line">grayImg = rgb2gray(origImg); <span class="comment">%将图像转变成灰度图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">imshow(grayImg);</span><br></pre></td></tr></table></figure><h4 id="二维快速傅里叶变换"><a href="#二维快速傅里叶变换" class="headerlink" title="二维快速傅里叶变换"></a>二维快速傅里叶变换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ftImg = myft3(grayImg);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">imshow(<span class="built_in">abs</span>(<span class="built_in">log</span>(ftImg)+<span class="number">1</span>),[]);</span><br></pre></td></tr></table></figure><p>由于傅里叶变换的结果是一个<strong>complex double</strong>类型的矩阵，直接使用imshow函数的化将会造成无法正确输出的情况，所以需要对傅里叶变换后的矩阵进行<strong>log(x)+1</strong>的灰度变换，将矩阵的取值范围限制在合理范围，并且取模长使第二个参数[]可以自动调整输出灰度范围。<br>接下来详细介绍一下快速傅里叶变换的具体实现。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ outputMat ]</span> = <span class="title">myft3</span><span class="params">( inputMat )</span></span></span><br><span class="line"></span><br><span class="line">    [M0,N0] = <span class="built_in">size</span>(inputMat); <span class="comment">%获得输入图像的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%找到最接近输入图像大小（并且大于图像大小）的2^n，并将图片padding补零</span></span><br><span class="line">    M1 = find_upper_2n(M0);</span><br><span class="line">    N1 = find_upper_2n(N0);</span><br><span class="line">    outputMat = double(<span class="built_in">zeros</span>(M1,N1)); </span><br><span class="line">    tempMat = double(<span class="built_in">zeros</span>(M1,N1));</span><br><span class="line">    inputMat(M1,N1) = <span class="number">0</span>;</span><br><span class="line">    inputMat = double(inputMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%行列分开计算</span></span><br><span class="line">    <span class="keyword">for</span> x = <span class="number">1</span>:N1</span><br><span class="line">        tempMat(:,x) = myfft( inputMat(:,x).' ).'; <span class="comment">%输入是行向量，所以列向量转置再转置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:M1</span><br><span class="line">        outputMat(y,:) = myfft( tempMat(y,:) );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上一段是进入快速傅里叶变换的铺垫步骤，利用padding补零，使得后续一维傅里叶快速变换可以最大限度地递归进行，最大限度地减少重复计算。而padding补上的零值在傅里叶变换的求和中是没有起作用的，因此不影响原图片的傅里叶变换的值。  </p><h4 id="一维快速傅里叶变换"><a href="#一维快速傅里叶变换" class="headerlink" title="一维快速傅里叶变换"></a>一维快速傅里叶变换</h4><p>由第三部分可知，当输入函数的自变量取值范围是偶数时，输入函数的傅里叶变换可以由偶数部分和奇数部分各自的傅里叶变换通过简单组合得到，因此，我们采取递归的方式不断拆分输入函数，直到输入函数的自变量只能取1个值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ outputMat ]</span> = <span class="title">myfft</span><span class="params">( inputMat )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(inputMat);  <span class="comment">%获得输入一维矩阵（向量）的列数N，行数M没有用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(N,<span class="number">2</span>)==<span class="number">0</span>  <span class="comment">%当输入向量的长度可以拆分时进行递归</span></span><br><span class="line">        oddMat = myfft( inputMat(<span class="number">1</span>:<span class="number">2</span>:<span class="keyword">end</span>) );</span><br><span class="line">        evenMat = myfft( inputMat(<span class="number">2</span>:<span class="number">2</span>:<span class="keyword">end</span>) );</span><br><span class="line">        <span class="keyword">for</span> u=<span class="number">1</span>:N/<span class="number">2</span></span><br><span class="line">            evenMat(u) = evenMat(u)*<span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(u<span class="number">-1</span>)/N);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        foreMat = (oddMat + evenMat);</span><br><span class="line">        backMat = (oddMat - evenMat);</span><br><span class="line">        outputMat = <span class="built_in">cat</span>(<span class="number">2</span>,foreMat,backMat);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">%当输入向量长度为1时停止递归，返回单点傅里叶变换的值，及自身</span></span><br><span class="line">        outputMat = inputMat;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实不需要完全分到1个点再进行傅里叶变换，可以适当提前结束递归。</p><h4 id="二维快速傅里叶反变换"><a href="#二维快速傅里叶反变换" class="headerlink" title="二维快速傅里叶反变换"></a>二维快速傅里叶反变换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iftImg = <span class="built_in">abs</span>(ifft2(ftImg));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">imshow(iftImg,[]);</span><br></pre></td></tr></table></figure><p>这里反变换是利用Matlab提供的函数<strong>ifft2</strong>进行验证，如果正确的话，结果应该是原图片加上黑色边框。这里的验证完全可以用自己写的函数进行，将傅里叶变换后的矩阵进行共轭，再次进行傅里叶变换就可以得到原图像。如下代码所示：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftImg2 = <span class="built_in">conj</span>(ftImg);</span><br><span class="line">iftImg = <span class="built_in">abs</span>(myft3(ftImg2));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">imshow(iftImg,[]);</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/orig.jpg">  原图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/ft.jpg">  原傅里叶变换图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/shiftFt.jpg">  平移后的傅里叶变换图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/check.jpg">  iff2反变换结果图像</div><h3 id="六、失误与总结"><a href="#六、失误与总结" class="headerlink" title="六、失误与总结"></a>六、失误与总结</h3><h4 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标"></a>数组下标</h4><p>习惯了0作为初始下标，但是matlab的下标从1开始，有些地方需要转换。</p><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>matlab力有两种转置，<strong>.’</strong>是普通转置，<strong>‘</strong>是共轭转置，要分清楚。  </p><center><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/FFT.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么是傅里叶变换&quot;&gt;&lt;a href=&quot;#一、什么是傅里叶变换&quot; c
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Keil5安装芯片包</title>
    <link href="http://jiahaohong.github.io/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/"/>
    <id>http://jiahaohong.github.io/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/</id>
    <published>2020-07-29T06:03:03.000Z</published>
    <updated>2020-07-29T06:54:41.016Z</updated>
    
    <content type="html"><![CDATA[<p>如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：</p><ul><li><p>打开下载芯片包的界面</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/1.png"> </li><li><p>在左侧双击你需要的芯片</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/2.png"></li><li><p>点击右侧你需要的芯片包的Install按钮</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/3.png"></li><li><p>单击选中下方报错的行</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/4.png"></li><li><p>复制后粘贴到浏览器网址栏</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/5.png"></li><li><p>去掉头尾留下地址，按回车即可下载</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/6.png">  <img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/7.png"></li><li><p>下载完毕后回到下载芯片包界面，点击file里的import选项</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/8.png"></li><li><p>在弹出窗口里找到之前下载的文件导入</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/9.png"></li></ul><p>完成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开下载芯片包的界面&lt;/p&gt;
&lt;img src=&quot;/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E
      
    
    </summary>
    
    
    
      <category term="Keil5" scheme="http://Jiahaohong.github.io/tags/Keil5/"/>
    
  </entry>
  
</feed>
