<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darcy&#39;s Blog</title>
  
  <subtitle>Hope is something as precious as dimond.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong.github.io/"/>
  <updated>2020-10-26T11:24:33.372Z</updated>
  <id>http://jiahaohong.github.io/</id>
  
  <author>
    <name>Darcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图像处理:MeanShift算法</title>
    <link href="http://jiahaohong.github.io/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong.github.io/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-25T12:27:49.000Z</published>
    <updated>2020-10-26T11:24:33.372Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：D. Comaniciu and P. Meer, Mean Shift: A Robust Approach toward Feature Space Analysis, PAMI 2002. </p><h3 id="一、什么是MeanShift算法"><a href="#一、什么是MeanShift算法" class="headerlink" title="一、什么是MeanShift算法"></a>一、什么是MeanShift算法</h3><p>Meanshift算法大致思路是，通过寻找一个小范围内的密度<strong>最大值</strong>，通过迭代的方法，最终收敛到一个全局范围内的密度<strong>极大值</strong>。  </p><h4 id="MeanShift算法的严格数学推导"><a href="#MeanShift算法的严格数学推导" class="headerlink" title="MeanShift算法的严格数学推导"></a>MeanShift算法的严格数学推导</h4><ul><li><p>区域中某一位置的密度估计函数<br>  MeanShift算法的目标是找到样本点中某一个密度最大的位置，首先得知道如何定义一个位置的密度，公式如下：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/rou.jpg" width="200">  <p>  稍微解释一下这个公式，f(X)代表在这个区域内，x位置的密度，n代表这个区域内有n个样本点，KH表示一种概率密度函数，可以看作和x距离不同的地方对x位置的密度的贡献程度，常见的有高斯分布。  </p><p>  这个公式还不完全，需要归一化，因为x可以看成d维空间中的点，区域可以看成d维空间中半径为h的高维球体，归一化后的公式是这样：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/normalized.jpg" width="200">  </li><li><p>区域中密度估计函数的最大值<br>  MeanShift算法需要沿着梯度方向移动，而当前区域内，密度最大的地方就是下一步要移动的方向。如何求得使f(x)取最大值的x呢？求导：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/derivative.jpg" width="300">  <p>  我们稍微变形一下，将KH’的求和提出来，得到如下公式：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/final.jpg" width="450">  <p>  令上式等于零，由于概率密度函数恒大于零，所以第二项等于零，得出密度最大点的公式：  </p>  <img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/x.jpg" width="200">  </li></ul><h4 id="MeanShift算法的直观物理推导"><a href="#MeanShift算法的直观物理推导" class="headerlink" title="MeanShift算法的直观物理推导"></a>MeanShift算法的直观物理推导</h4><p>你可以这样想象，每一个样本点都是一个质点，而样本点的参数就是质点的质量，你用一个固定大小的圆随机圈中一些质点，这些质点的质心有很大概率不在你的圆的中心，那么你下一步就需要把圆的中心移到这些点的质心。当你移完之后，你的圆会圈中和上次不完全一样的点，这时就又有一个新的质心，你仍然需要将圆的中心移到这个新的质心上。如此反复，由于质心总是向密度大的方向偏离，最终你的圆会落到所有质点里密度最大的地方。由此得出，每一次移动的位置和权重的样本点关系如下（一维质心公式为例）：  </p><center><img src="/2020/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-MeanShift%E7%AE%97%E6%B3%95/physic.jpg" width="90"></center><h3 id="二、MeanShift算法应用到图像分割"><a href="#二、MeanShift算法应用到图像分割" class="headerlink" title="二、MeanShift算法应用到图像分割"></a>二、MeanShift算法应用到图像分割</h3><p>MeanShift算法整体思想，是每一步都向密度更大的地方走，直到走不动为止，然后在所有走到同一个终点的出发点归为一类。但是在图像中属于一类的物体哪些参数是比较接近的？根据上网查阅资料得知，一个物体的各个部分在RGB图像中关联度不高，但是在HSV图像中相关度比较高，因此之后的实验在HSV颜色空间中进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文献：D. Comaniciu and P. Meer, Mean Shift: A Robust Approach toward Feature Space Analysis, PAMI 2002. &lt;/p&gt;
&lt;h3 id=&quot;一、什么是MeanShift算法&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SeedCup:log20201020</title>
    <link href="http://jiahaohong.github.io/2020/10/20/SeedCup-log20201020/"/>
    <id>http://jiahaohong.github.io/2020/10/20/SeedCup-log20201020/</id>
    <published>2020-10-20T12:14:36.000Z</published>
    <updated>2020-10-20T12:20:08.088Z</updated>
    
    <content type="html"><![CDATA[<p>2020-10-20</p><p>Finish:迷宫路径算法完成</p><p>Error:组内坐标定义不兼容</p><p>Task:移动函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020-10-20&lt;/p&gt;
&lt;p&gt;Finish:迷宫路径算法完成&lt;/p&gt;
&lt;p&gt;Error:组内坐标定义不兼容&lt;/p&gt;
&lt;p&gt;Task:移动函数&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="2020种子杯日志" scheme="http://Jiahaohong.github.io/categories/2020%E7%A7%8D%E5%AD%90%E6%9D%AF%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Python" scheme="http://Jiahaohong.github.io/tags/Python/"/>
    
      <category term="SeedCup" scheme="http://Jiahaohong.github.io/tags/SeedCup/"/>
    
  </entry>
  
  <entry>
    <title>Linux:ssh免密登录服务器</title>
    <link href="http://jiahaohong.github.io/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://jiahaohong.github.io/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-10-20T04:24:38.000Z</published>
    <updated>2020-10-20T12:17:09.348Z</updated>
    
    <content type="html"><![CDATA[<p>今年二月份在阿里云领了一个免费服务器，当时学了学服务器操作的相关知识，感觉ssh登录确实很方便。前不久8月份免费的服务器到期了，所以我又开了一个一年的低配服务器，现在记录一下我对这个服务器的操作，纯属乐趣。本期话题是“ssh免密登录”。</p><p>我的硬件配置如下：<br><em>本地电脑：Windows10</em><br><em>服务器：阿里云云服务器</em><br><em>本地远程登录软件：gitbash</em></p><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><h4 id="一个服务器"><a href="#一个服务器" class="headerlink" title="一个服务器"></a>一个服务器</h4><ul><li>说明一下，其一，一台服务器的概念很宽泛，可以是另一台电脑，也可以是一个云端的电脑，但总归一点你要知道它的IP地址。  </li><li>其二，这个服务器上已经有注册了用户，有个用户名和对应的密码，这类似于你用于登陆Windows的账户。  </li><li>其三，有一个区别是Windows的管理员是administrator，Linux的管理员是root。</li></ul><h4 id="一台本地电脑"><a href="#一台本地电脑" class="headerlink" title="一台本地电脑"></a>一台本地电脑</h4><ul><li>Windows电脑可以下载一些软件来连接，比如Putty和XShell</li><li>Linux电脑需要安装ssh服务。</li></ul><h4 id="核心登录指令"><a href="#核心登录指令" class="headerlink" title="核心登录指令"></a>核心登录指令</h4><p><strong>ssh <a href="mailto:username@xxx.xxx.xxx.xxx">username@xxx.xxx.xxx.xxx</a></strong>  </p><ul><li>username 用你自己的用户名替换  </li><li>xxx.xxx.xxx.xxx 用你自己的服务器ip地址替换</li></ul><h3 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h3><h4 id="阿里云远程连接配置服务器"><a href="#阿里云远程连接配置服务器" class="headerlink" title="阿里云远程连接配置服务器"></a>阿里云远程连接配置服务器</h4><p><em>这一步操作需要通过本地电脑远程连接服务器后，在服务器上执行。</em><br>在用自己的电脑远程连接服务器之前，我们需要使用阿里云平台提供的工具连接到自己的服务器，这个工具在哪？登录阿里云官网，控制台里就有。<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/aliyun.jpg"><br>点击远程连接进入到终端后，找到/etc/ssh文件夹，我们要修改该文件夹里的<strong>sshd_config</strong>文件，配置一下远程登陆，一般来说文件里都已经写好了，只不过被注释掉了（或开启状态写的是no），这时你只需要找到被注释的行取消注释就行（或把no改成yes）；如果你没有找到相应的配置，那么就要手动添加，写在文件里任何位置都是可以的，但建议最后一行，方便以后修改。需要修改的配置如下两图：<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/aliyun_cfg1.jpg"><br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/aliyun_cfg2.jpg"><br>这里稍微解释一下这四个配置的意思（如果不想看尽情跳过）：</p><ul><li>第一个<strong>PermitRootLogin</strong>表示允许用root用户进行远程登陆。如果不开启这一项，那么你的远程登陆只能使用其他的普通用户名登录。比如你在服务器上注册了一个darcy账户，而你没有开启这一项，那么你只能用darcy作为远程登录的用户名，这种情况下你用root登录会拒绝你的登录请求。  </li><li>第二个<strong>PasswordAuthentication</strong>表示允许密码远程登录。这是最基础的远程登陆认证方式，其实和你在电脑开机时输入登陆密码一样。  </li><li>第三个<strong>PubkeyAuthentication</strong>表示允许公钥远程登陆。<strong>注意</strong>这一项是本篇博客的重要内容。ssh登录需要开启这个命令。</li><li>第四个是保存公钥的文件，你在你的ssh文件夹里找一找，一般来说第一个就是（因为开头字母是a），如果没有就自己在ssh文件夹里新建一个文件，名字是authoriz_keys，后面那个authoriz_keys2没有用到。  </li></ul><h4 id="生成公钥密钥"><a href="#生成公钥密钥" class="headerlink" title="生成公钥密钥"></a>生成公钥密钥</h4><p><em>这一步操作需要在本地电脑的远程连接软件的终端上执行。</em><br>在gitbash里输入如下命令<strong>ssh-keygen -t rsa</strong>，之后按他的提示来就行，最终会在你的Windows当前用户的主文件夹的.ssh文件夹里生成两个文件，一个是公钥id_rsa.pub，另一个是私钥id_rsa，其中私钥要保管好，公钥要传到服务器上去。注意，如果是Linux用户，这个文件在~/.ssh文件夹里，如果是Windows用户，这个文件在如下图的路径里：<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/key.jpg"></p><h4 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h4><p><em>这一步操作需要在本地电脑的远程连接软件的终端上执行。</em><br>在本地远程连接软件终端里输入如下指令<strong>ssh-copy-id -i ~/.ssh/id_rsa.pub <a href="mailto:root@xxx.xxx.xxx.xxx">root@xxx.xxx.xxx.xxx</a></strong>，之后会让你输入root用户的密码，之后会提示让你用<strong>ssh <a href="mailto:root@xxx.xxx.xxx.xxx">root@xxx.xxx.xxx.xxx</a></strong>命令远程登陆服务器（如下图）。OK，你可以免密登陆了！<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/upload.jpg"></p><h3 id="三、题外话：第一次连接服务器（密码登录）"><a href="#三、题外话：第一次连接服务器（密码登录）" class="headerlink" title="三、题外话：第一次连接服务器（密码登录）"></a>三、题外话：第一次连接服务器（密码登录）</h3><p><em>这一步操作需要在本地电脑的远程连接软件的终端上执行。</em><br>在第一次远程连接服务器的时候，会出现如下警告：<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/norm3.jpg"><br>这是正常的，ssh为了防止中间人攻击会在你第一次连接一个远程服务器时提醒你一下。敲上yes按回车确认即可。然后他会让你输入密码，你输入root用户的密码即可，这里没有显示是正常的，因为他会隐藏你输入的密码。<br><img src="/2020/10/20/Linux-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/norm1.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年二月份在阿里云领了一个免费服务器，当时学了学服务器操作的相关知识，感觉ssh登录确实很方便。前不久8月份免费的服务器到期了，所以我又开了一个一年的低配服务器，现在记录一下我对这个服务器的操作，纯属乐趣。本期话题是“ssh免密登录”。&lt;/p&gt;
&lt;p&gt;我的硬件配置如下：&lt;b
      
    
    </summary>
    
    
      <category term="Linux学习之路" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="http://Jiahaohong.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:直方图均衡化vs同态滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-19T00:11:06.000Z</published>
    <updated>2020-10-24T10:05:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>上个星期做完直方图均衡化和同态滤波的图像处理实验，才发现没有进行过对比，现在那原来的代码进行一次处理效果对比实验。</p><h4 id="原图片"><a href="#原图片" class="headerlink" title="原图片"></a>原图片</h4><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/1.jpg"><h4 id="灰度图片及其傅里叶变换"><a href="#灰度图片及其傅里叶变换" class="headerlink" title="灰度图片及其傅里叶变换"></a>灰度图片及其傅里叶变换</h4><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/gray.jpg"><h4 id="傅里叶变换对比"><a href="#傅里叶变换对比" class="headerlink" title="傅里叶变换对比"></a>傅里叶变换对比</h4><p>左边是直方图均衡化后的傅里叶变换图像，右边是同态滤波后的傅里叶变换图像。第二行是他们与原灰度图像的傅里叶变换图之差，黑色部分表示几乎没有差异，白色部分表示差异很大。<br><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/ft_compared.jpg"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从傅里叶变换对比可以看出，同态滤波和直方图均衡化的低频成分都被很大的抑制了，中间十字形部分几乎为白，但是同态滤波的高频成分和原图像基本保持一致，二直方图均衡化丢失了一部分高频成分信息。  </p><center><img src="/2020/10/19/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96vvs%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个星期做完直方图均衡化和同态滤波的图像处理实验，才发现没有进行过对比，现在那原来的代码进行一次处理效果对比实验。&lt;/p&gt;
&lt;h4 id=&quot;原图片&quot;&gt;&lt;a href=&quot;#原图片&quot; class=&quot;headerlink&quot; title=&quot;原图片&quot;&gt;&lt;/a&gt;原图片&lt;/h4&gt;&lt;img
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>C/C++:一维熵阈值分割</title>
    <link href="http://jiahaohong.github.io/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <id>http://jiahaohong.github.io/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</id>
    <published>2020-10-17T10:45:06.000Z</published>
    <updated>2020-10-25T14:26:49.579Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/OTSU-and-Entropy.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是一维熵阈值分割"><a href="#一、什么是一维熵阈值分割" class="headerlink" title="一、什么是一维熵阈值分割"></a>一、什么是一维熵阈值分割</h3><p>信息熵表示从信号中可能获得的信息的多少。<br>就比如投硬币，出席那正反两面的概率都是0.5，那么根据信息熵的公式得出，“硬币是正面”这个预测所携带的信息熵是：<br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/p05.jpg" width="300"><br>如果投出正面的概率是0.9，那么“硬币是正面”这个预测所携带的信息熵是：<br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/p09.jpg" width="300"><br>如果投出正面的概率是0.1，那么“硬币是正面”这个预测所携带的信息熵是：<br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/p01.jpg" width="300"><br>可以看到，当硬币出现正反面的概率一样的时候，“硬币是正面”这个预测所携带的信息熵最大，也就是信息量最大。同理可以推广至更多种预测结果的情况，比如投正二十面体，当“出现任意一个面朝上的概率相同”时，“第13号面朝上”这个预测所携带的信息量最大。  </p><p>回到图像上，图像有256个灰度级，若“一个像素是0到255中的任意一个的概率相同”，那么这张图象所携带的信息量最大。但不用多想，这种图就像黑白电视机没信号时候的图像一样，没有可解读的含义。至于为什么如此，还需要更深刻的理解，我暂时解释不清。 </p><p>上面讲到了整幅图像的信息，现在更进一步，将图像分成两部分，其一是目标区域，其二是背景区域。如果二者都大致符合正态分布，那么图像的熵可以表示为目标区域的熵和背景区域的熵之和。基于此，一维熵阈值分割的目标就是，寻找一个分割灰度t，使得目标区域和背景区域的熵之和最大。</p><h3 id="二、一维熵阈值分割公式"><a href="#二、一维熵阈值分割公式" class="headerlink" title="二、一维熵阈值分割公式"></a>二、一维熵阈值分割公式</h3><h4 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h4><p>像素分成两类，一类是目标区域，一类是背景区域，每一类像素各自有两个基本变量：</p><ul><li>w 像素总个数</li><li>e 区域的一维熵（用像素个数代替像素概率密度，并且不加负号）<br>由于不知道小于阈值t的像素属于目标还是背景，所以将小于阈值t的像素集设定为0。下面以小于阈值t的像素为例：  <center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/definition.jpg" width="150"></center></li></ul><h4 id="指标变量"><a href="#指标变量" class="headerlink" title="指标变量"></a>指标变量</h4><p>指标变量有两个，一个是目标区域的一维熵，另一个是背景区域的一维熵，同样由于不知道背景和目标谁比较亮，所以Ho和HB都是相对来说的，一个为目标，一个为背景，二者等价。假设目标的灰度级小于背景，则定义如下：  </p><center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/index.jpg" width="300"></center><h4 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h4><p>总体的一维熵表示为目标区域一维熵和背景一维熵之和，化简之后结果如下（使用数学上的定义，pi代表第i各灰度级的概率密度）：  </p><center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/res1.jpg" width="300"></center>  为了提高程序效率，我们进一步将该公式变换成利于编程的形式，采用我们定义的基本变量表示，将该公式的三个部分分别化简成如下公式：  <center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/res2.jpg" width="300"></center>  <h3 id="三、程序思路"><a href="#三、程序思路" class="headerlink" title="三、程序思路"></a>三、程序思路</h3><p>设置一个变量t作为待定的阈值，然后t遍历整个灰度级（实际上1-254即可），每一个t算一个一维熵，如果这个一维熵比最大一维熵大，那么更新最大一维熵，并将这次的t作为待定阈值。</p><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">entropy</span><span class="params">(cv::Mat &amp;input_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> M = input_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = input_img.cols;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = M * N;</span><br><span class="line"><span class="keyword">double</span> log_size = <span class="built_in">std</span>::<span class="built_in">log</span>(M*N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a, b, c; <span class="comment">//公式里相加的三项</span></span><br><span class="line"><span class="keyword">double</span> phi, phiMax = <span class="number">0.0</span>; <span class="comment">//phi公式最大值</span></span><br><span class="line"><span class="keyword">int</span> w0;    <span class="comment">//小于阈值t的像素的个数</span></span><br><span class="line"><span class="keyword">double</span> e0; <span class="comment">//小于阈值t的像素一维熵（用像素个数代替概率）</span></span><br><span class="line"><span class="keyword">int</span> w1;   <span class="comment">//大于阈值t的像素的个数</span></span><br><span class="line"><span class="keyword">double</span> e1; <span class="comment">//大于阈值t的像素一维熵（用像素个数代替概率）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gray_level, gray_num, gray_arr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> t, t_optm = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; M; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = <span class="number">0</span>; cnt2 &lt; N; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">gray_level = input_img.at&lt;uchar&gt;(cnt1, cnt2);</span><br><span class="line">gray_arr[gray_level] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (t = <span class="number">1</span>; t &lt; <span class="number">254</span>; ++t)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = <span class="number">0</span>;</span><br><span class="line">e0 = e1 = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小于阈值t的像素的参数</span></span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; t; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line">gray_num = gray_arr[cnt1];</span><br><span class="line">w0 += gray_num;</span><br><span class="line"><span class="keyword">if</span> (gray_num != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e0 += gray_num * <span class="built_in">std</span>::<span class="built_in">log</span>(gray_num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大于阈值t像素的参数</span></span><br><span class="line"><span class="keyword">for</span> (cnt2 = t; cnt2 &lt; <span class="number">256</span>; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">gray_num = gray_arr[cnt2];</span><br><span class="line"><span class="comment">//w1 += gray_arr[cnt2]; //（不用累加）</span></span><br><span class="line"><span class="keyword">if</span> (gray_num != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e1 += gray_num * <span class="built_in">std</span>::<span class="built_in">log</span>(gray_num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w1 = <span class="built_in">size</span> - w0;</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">std</span>::<span class="built_in">log</span>(w0) + <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="built_in">size</span> - w0) - <span class="number">2</span> * log_size;</span><br><span class="line">b = log_size - e0 / w0;</span><br><span class="line">c = (log_size*w1 - e1) / w1;</span><br><span class="line"></span><br><span class="line">phi = a + b + c;</span><br><span class="line"><span class="keyword">if</span> (phi &gt; phiMax)</span><br><span class="line">&#123;</span><br><span class="line">t_optm = t;</span><br><span class="line">phiMax = phi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t_optm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>阈值120</strong><br><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/entropy_res.png"></p><h3 id="六、失误和总结"><a href="#六、失误和总结" class="headerlink" title="六、失误和总结"></a>六、失误和总结</h3><h4 id="std-log-函数输入范围"><a href="#std-log-函数输入范围" class="headerlink" title="std::log()函数输入范围"></a>std::log()函数输入范围</h4><p>由于没考虑到一个灰度级的像素个数可能为0的情况，导致输入std::log()函数的值为0，输出为nan，后续程序无法运行，后来增加了对某个灰度级像素个数的判断，只有当其不为0时才继续输入std::log()函数，进行基本变量的累加。  </p><div align="center"><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/debug1.jpg">  <p>错误代码   </p><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/debug2.jpg">   <p>考虑0输入代码</p></div><center><img src="/2020/10/17/C-C-%E4%B8%80%E7%BB%B4%E7%86%B5%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/OTSU-and-Entropy.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么是一维熵阈值分割&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C/C++" scheme="http://Jiahaohong.github.io/tags/C-C/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C/C++:OTSU阈值分割</title>
    <link href="http://jiahaohong.github.io/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <id>http://jiahaohong.github.io/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</id>
    <published>2020-10-16T12:50:34.000Z</published>
    <updated>2020-10-25T14:38:44.934Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/OTSU-and-Entropy.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是OTSU阈值分割"><a href="#一、什么是OTSU阈值分割" class="headerlink" title="一、什么是OTSU阈值分割"></a>一、什么是OTSU阈值分割</h3><p>OTSU分割的基本思想是：选择一个阈值分割图像后，两部分的类间方差最大（两个类差异最大），两部分各自的类内方差最小（每个部分比较集中）。  </p><h3 id="二、OTSU公式"><a href="#二、OTSU公式" class="headerlink" title="二、OTSU公式"></a>二、OTSU公式</h3><p><em>注意，为了程序的运行速度，下面的公式和纯数学公式的变量含义稍有差别。</em></p><h4 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h4><p>像素分成两类，每一类像素各自有三个基本变量：</p><ul><li>w 像素总个数</li><li>u 像素加权和（权重为像素灰度）</li><li>v 像素加平方权和（权重为像素灰度的平方）<br>现在给出三个参数的定义，以小于待定阈值t的参数为例，大于阈值t的参数只是修改求和符号的累加范围：  <center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/definition.jpg" width="100"></center></li></ul><h4 id="指标变量"><a href="#指标变量" class="headerlink" title="指标变量"></a>指标变量</h4><p>两类像素各自有衡量自身离散程度的指标：</p><ul><li>delta 方差</li><li>deltaB 类间方差</li><li>deltaW 类内方差</li><li>deltaT 总方差<br>这里给出这些指标变量的表达式：  <center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/index.jpg" width="300"></center></li></ul><h4 id="判决准则"><a href="#判决准则" class="headerlink" title="判决准则"></a>判决准则</h4><p>数学上一共有三个判别准则，这三个准则等价：  </p><center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/res.jpg" width="100"></center>由于总方差和待定阈值无关，所以我们选择第二个判别准则，使第二个公式值最大的阈值t作为最终结果。<h3 id="三、算法思路"><a href="#三、算法思路" class="headerlink" title="三、算法思路"></a>三、算法思路</h3><p>设置一个变量t作为待定的阈值，然后t遍历整个灰度级（实际上1-254即可），每一个t算一个类间方差值，如果这个类间方差值比最大类间方差值大，那么更新最大类间方差值，并将这次的t作为待定阈值。 </p><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">otsu</span><span class="params">(cv::Mat &amp;input_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> M = input_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = input_img.cols;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = M * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> deltaB, deltaW, etaMax = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> w0; <span class="comment">//灰度小于t的像素个数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> w1; <span class="comment">//灰度大于t的像素个数</span></span><br><span class="line"><span class="keyword">double</span> u0; <span class="comment">//灰度小于t的像素的加权和，权重为灰度值（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> u1; <span class="comment">//灰度大于t的像素的加权和，权重为灰度值（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> v0; <span class="comment">//灰度大于t的像素的加权和，权重为灰度值的平方（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> v1; <span class="comment">//灰度大于t的像素的加权和，权重为灰度值的平方（不是灰度值/灰度范围，方便后续计算）</span></span><br><span class="line"><span class="keyword">double</span> u0_2;</span><br><span class="line"><span class="keyword">double</span> u1_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gray_level, gray_arr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> t, t_optm = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计灰度</span></span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; M; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = <span class="number">0</span>; cnt2 &lt; N; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">gray_level = input_img.at&lt;uchar&gt;(cnt1, cnt2);</span><br><span class="line">gray_arr[gray_level] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算最佳阈值t</span></span><br><span class="line"><span class="keyword">for</span> (t = <span class="number">1</span>; t &lt; <span class="number">254</span>; ++t)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = <span class="number">0</span>;</span><br><span class="line">u0 = u1 = v0 = v1 = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (cnt1 = <span class="number">0</span>; cnt1 &lt; t; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line">w0 += gray_arr[cnt1];</span><br><span class="line">u0 += cnt1 * gray_arr[cnt1];</span><br><span class="line">v0 += cnt1^<span class="number">2</span> * gray_arr[cnt1]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = t; cnt2 &lt; <span class="number">256</span>; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//w1 += gray_arr[cnt2]; //（不用累加）</span></span><br><span class="line">u1 += cnt2 * gray_arr[cnt2];</span><br><span class="line">v1 += cnt2^<span class="number">2</span> * gray_arr[cnt2];</span><br><span class="line">&#125;</span><br><span class="line">w1 = <span class="built_in">size</span> - w0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u0_2 = <span class="built_in">pow</span>(u0, <span class="number">2</span>);</span><br><span class="line">u1_2 = <span class="built_in">pow</span>(u1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//deltaB计算公式</span></span><br><span class="line"><span class="comment">//                     u0   u1            1</span></span><br><span class="line"><span class="comment">//deltaB = w0 * w1 * ( —— - —— )^2 * ——————————</span></span><br><span class="line"><span class="comment">//                     w0   w1       (M * N) ^2</span></span><br><span class="line"></span><br><span class="line">deltaB = w0 * w1 * <span class="built_in">pow</span>( (u0 / w0 - u1 / w1), <span class="number">2</span> ) / <span class="built_in">size</span> / <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delta0计算公式（不用计算） </span></span><br><span class="line"><span class="comment">//         v0     u0</span></span><br><span class="line"><span class="comment">//delta0 = —— - ( —— )^2</span></span><br><span class="line"><span class="comment">//         w0     w0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deltaW计算公式（不用计算）</span></span><br><span class="line"><span class="comment">//            1                u0^2   u1^2</span></span><br><span class="line"><span class="comment">//deltaW  = ————— * ( v0 + v1 - ———— - ———— )</span></span><br><span class="line"><span class="comment">//          M * N                w0     w1</span></span><br><span class="line"><span class="comment">//deltaW = (v0 + v1 - u0_2 / w0 - u1_2 / w1) / size;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deltaB &gt; etaMax)</span><br><span class="line">&#123;</span><br><span class="line">t_optm = t;</span><br><span class="line">etaMax = deltaB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t_optm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>阈值116</strong><br><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/otsu_res.png"></p><h3 id="六、失误和总结"><a href="#六、失误和总结" class="headerlink" title="六、失误和总结"></a>六、失误和总结</h3><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>写完程序后，测试结果总是1，即deltaB运算结果一直为0，调试过程中查看了很多变量也没发现问题，最后鼠标一个个查声明的变量时发现问题：因为<strong>数字1</strong>和<strong>变量size</strong>都是<strong>int类型</strong>的，在进行除法时结果是0，所以之后的计算结果一直为0，达不到预期效果。<br><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/debug1.jpg"></p><h4 id="double类型的表示范围"><a href="#double类型的表示范围" class="headerlink" title="double类型的表示范围"></a>double类型的表示范围</h4><p>最初采用的判别标准是namda公式，在计算deltaW的时候由于u0和u1变量中有一个会很大，导致其平方会超出double表示范围，体现的结果就是deltaW出现负值，而在数学上这个值应该恒为正（两个平方数相加）。之后考虑到计算量，采用了eta公式，并且只用计算deltaB，简化了计算。  </p><center><img src="/2020/10/16/C-C-OTSU%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/OTSU-and-Entropy.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么是OTSU阈值分割&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C/C++" scheme="http://Jiahaohong.github.io/tags/C-C/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C/C++:中值滤波和均值滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-16T08:35:07.000Z</published>
    <updated>2020-10-25T14:26:47.781Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、中值滤波"><a href="#一、中值滤波" class="headerlink" title="一、中值滤波"></a>一、中值滤波</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h4><p>针对椒盐噪声设计。因为椒盐噪声的幅值和原图像差异很大，所以在模板中一半分布在最大或最小值附近，而原图像的灰度分布相对接近，通过取模板中间值，可以滤掉椒盐噪声。</p><h4 id="2-文件结构"><a href="#2-文件结构" class="headerlink" title="2.文件结构"></a>2.文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-read orig img</span><br><span class="line">|</span><br><span class="line">|-convert gray img</span><br><span class="line">|</span><br><span class="line">|-add impulse noise</span><br><span class="line">|</span><br><span class="line">|-middle filt</span><br><span class="line">|</span><br><span class="line">|-result output</span><br></pre></td></tr></table></figure><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">middle_filter</span><span class="params">(cv::Mat &amp;input_img, <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat output_img = input_img.clone();</span><br><span class="line">cv::Mat filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line">cv::Mat sorted_filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line"><span class="keyword">int</span> M = output_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = output_img.cols;</span><br><span class="line"><span class="keyword">int</span> offset = (<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, cnt3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (cnt1 = offset; cnt1 &lt; M-offset; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = offset; cnt2 &lt; N-offset; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//将模板所在位置的图像灰度取出</span></span><br><span class="line"><span class="keyword">for</span> (cnt3 = <span class="number">0</span>; cnt3 &lt; <span class="built_in">size</span>*<span class="built_in">size</span>; ++cnt3)</span><br><span class="line">&#123;</span><br><span class="line">filter.at&lt;uchar&gt;(<span class="number">0</span>, cnt3)</span><br><span class="line">                    = input_img.at&lt;uchar&gt;</span><br><span class="line">                        ( cnt1+(cnt3/<span class="built_in">size</span><span class="number">-1</span>), cnt2+(cnt3%<span class="built_in">size</span><span class="number">-1</span>) );<span class="comment">//位置换算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择排序</span></span><br><span class="line">sorted_filter = seek_sort(filter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模板中心图像灰度取模板中间值</span></span><br><span class="line">output_img.at&lt;uchar&gt;(cnt1, cnt2)</span><br><span class="line">                = sorted_filter.at&lt;uchar&gt;(<span class="number">0</span>, (<span class="built_in">size</span>*<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> output_img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4.实验结果"></a>4.实验结果</h4><p>实验结果如下，可以看到椒盐噪声被很好的滤除了（图像边沿保留了原值）。但同时图像也变得模糊，随着模板的增大这一现象更加明显。<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/middle.png">  </p><h3 id="二、均值滤波"><a href="#二、均值滤波" class="headerlink" title="二、均值滤波"></a>二、均值滤波</h3><h4 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h4><p>针对高斯噪声设计。滤波器取均值。由于高斯噪声满足高斯分布，所以噪声在每个灰度级上都会存在，但是平均值是一个定值，因此采用平均值滤波可以有效滤除高斯噪声。  </p><h4 id="2-文件结构-1"><a href="#2-文件结构-1" class="headerlink" title="2.文件结构"></a>2.文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-read orig img</span><br><span class="line">|</span><br><span class="line">|-convert gray img</span><br><span class="line">|</span><br><span class="line">|-add gauss noise</span><br><span class="line">|</span><br><span class="line">|-average filt</span><br><span class="line">|</span><br><span class="line">|-result output</span><br></pre></td></tr></table></figure><h4 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">avrg_filter</span><span class="params">(cv::Mat &amp;input_img, <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat output_img = input_img.clone();</span><br><span class="line">cv::Mat filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line">cv::Mat sorted_filter = cv::Mat::zeros(<span class="number">1</span>, <span class="built_in">size</span>*<span class="built_in">size</span>, CV_8UC1);</span><br><span class="line"><span class="keyword">int</span> M = output_img.rows;</span><br><span class="line"><span class="keyword">int</span> N = output_img.cols;</span><br><span class="line"><span class="keyword">int</span> offset = (<span class="built_in">size</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, cnt3;</span><br><span class="line"><span class="keyword">double</span> avg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (cnt1 = offset; cnt1 &lt; M - offset; ++cnt1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt2 = offset; cnt2 &lt; N - offset; ++cnt2)</span><br><span class="line">&#123;</span><br><span class="line">avg = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将模板所在位置的图像灰度取出</span></span><br><span class="line"><span class="keyword">for</span> (cnt3 = <span class="number">0</span>; cnt3 &lt; <span class="built_in">size</span>*<span class="built_in">size</span>; ++cnt3)</span><br><span class="line">&#123;</span><br><span class="line">avg += input_img.at&lt;uchar&gt;</span><br><span class="line">                    (cnt1 + (cnt3 / <span class="built_in">size</span> - offset), </span><br><span class="line">                     cnt2 + (cnt3%<span class="built_in">size</span> - offset));</span><br><span class="line">&#125;</span><br><span class="line">avg /= <span class="built_in">size</span> * <span class="built_in">size</span>;</span><br><span class="line">output_img.at&lt;uchar&gt;(cnt1, cnt2) = (uchar)avg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> output_img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实验结果-1"><a href="#4-实验结果-1" class="headerlink" title="4.实验结果"></a>4.实验结果</h4><p>实验结果如下，也存在随着模板的增大图像变模糊的现象。<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/average.png"> </p><h3 id="三、滤波效果对比"><a href="#三、滤波效果对比" class="headerlink" title="三、滤波效果对比"></a>三、滤波效果对比</h3><h4 id="1-中值滤波对高斯噪声"><a href="#1-中值滤波对高斯噪声" class="headerlink" title="1.中值滤波对高斯噪声"></a>1.中值滤波对高斯噪声</h4><p>高斯分布均值：0<br>高斯分布方差：10<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/middle_gauss.png"></p><h4 id="2-均值滤波对椒盐噪声"><a href="#2-均值滤波对椒盐噪声" class="headerlink" title="2.均值滤波对椒盐噪声"></a>2.均值滤波对椒盐噪声</h4><p>椒盐噪声信噪比：0.95<br><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/average_impulse.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由上实验结果可知，中值滤波和均值滤波都有自己的特殊作用，都不是两全其美的滤波方法。  </p><center><img src="/2020/10/16/C-C-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%92%8C%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、中值
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C/C++" scheme="http://Jiahaohong.github.io/tags/C-C/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Opencv:在VisualStudio里配置Opencv</title>
    <link href="http://jiahaohong.github.io/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/"/>
    <id>http://jiahaohong.github.io/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/</id>
    <published>2020-10-14T08:32:46.000Z</published>
    <updated>2020-10-14T11:54:33.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一年前学数据结构时配置过Opencv，现在有新工程需要使用Opencv，索性写一篇博客记录下配置过程，希望以后不会忘记。</p><h3 id="1-下载Opencv"><a href="#1-下载Opencv" class="headerlink" title="1.下载Opencv"></a>1.下载Opencv</h3><p>首先得确定你的设备的系统位数，32位还是64位，还要确定你的VisualStudio的版本。我的电脑是x64系统，VisualStudio是2017版。所以我下了4.1.1版本x64平台的Opencv，下载之后将那个exe跑起来，解压Opencv你想要的位置，记住这个位置。</p><h3 id="2-新建工程"><a href="#2-新建工程" class="headerlink" title="2.新建工程"></a>2.新建工程</h3><p>Visual Studio新建空工程文件，OK。</p><h3 id="3-配置工程属性"><a href="#3-配置工程属性" class="headerlink" title="3.配置工程属性"></a>3.配置工程属性</h3><p>在左侧的“解决方案资源管理器”中右键单击你的工程名字，选择弹出选项的最后一个“属性”进行配置。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/0.jpg">  </p><h4 id="3-1“配置和平台”的选择"><a href="#3-1“配置和平台”的选择" class="headerlink" title="3.1“配置和平台”的选择"></a>3.1“配置和平台”的选择</h4><p>我的选择的是“所有配置”和“x64”平台。配置选项也可以选择“Debug”。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/1-1.jpg">  </p><h4 id="3-2“C-C-常规”项的配置"><a href="#3-2“C-C-常规”项的配置" class="headerlink" title="3.2“C\C++常规”项的配置"></a>3.2“C\C++常规”项的配置</h4><p>编辑附加包含目录，将你的Opencv里的<strong>include</strong>文件夹的绝对路径填写进去。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/1.jpg"></p><h4 id="3-3“链接器常规”项的配置"><a href="#3-3“链接器常规”项的配置" class="headerlink" title="3.3“链接器常规”项的配置"></a>3.3“链接器常规”项的配置</h4><p>编辑附加库目录，如图。我的VisualStudio是2017版的，选择v14和v15都可以。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/2.jpg"></p><h4 id="3-4“链接器输入”项的配置"><a href="#3-4“链接器输入”项的配置" class="headerlink" title="3.4“链接器输入”项的配置"></a>3.4“链接器输入”项的配置</h4><p>编辑附加依赖项，将v15\bin文件夹里的opencv_worldxxx.dll和opencv_worldxxx<strong>d</strong>.dll两个文件名字写进去。注意，这个xxx代表的是你下的opencv版本号，比如4.1.1版就是411。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/3.jpg"></p><h3 id="4-移动-dll文件"><a href="#4-移动-dll文件" class="headerlink" title="4.移动.dll文件"></a>4.移动.dll文件</h3><p>最后一步，还记得之前v15\bin文件夹里的两个dll文件吗？将他们复制粘贴到C:\Windows\System32文件夹里，OK。<br><img src="/2020/10/14/Opencv-%E5%9C%A8VisualStudio%E9%87%8C%E9%85%8D%E7%BD%AEOpencv/4.jpg"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一年前我还配置过系统环境变量，但是这次没有配置也成功了，仔细检查过系统PATH和用户Path变量后也没有发现一年前配置过的那个变量。所以环境变量可能不是必须的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一年前学数据结构时配置过Opencv，现在有新工程需要使用Opencv，索性写一篇博客记录下配置过程，希望以后不会忘记。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Opencv" scheme="http://Jiahaohong.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:同态滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-06T02:51:54.000Z</published>
    <updated>2020-10-25T14:26:28.778Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是同态滤波"><a href="#一、什么是同态滤波" class="headerlink" title="一、什么是同态滤波"></a>一、什么是同态滤波</h3><p>根据成像原理，一幅图像可以分成两种成分的乘积叠加，一种成分是入射的光强<strong>L(x,y)</strong>，另一种是反射到人眼中的光强<strong>R(x,y)</strong>，二者是乘性叠加，所以一幅图像可以表示为<strong>F(x,y)=L(x,y)*R(x,Y)</strong>。<br>同态滤波通过将图像取对数，<strong>ln(F(x,y))=ln(L(x,y))+ln(R(x,y))</strong>，将乘性耦合的入射光和反射光成分解耦，变成加性耦合，这样就可以利用线性性分别对两种成分进行滤波处理。由于反射光强一般是高频成分，而入射光强是低频成分，所以用高通滤波器可以将入射光成分滤掉，得到更加清楚的细节。同态滤波是通过物理规律将图像进行分解操作，滤波器是在滤波过程中的一种频率选择方法，同态滤波并没有设计一种新的滤波器。</p><h3 id="二、同态滤波实现"><a href="#二、同态滤波实现" class="headerlink" title="二、同态滤波实现"></a>二、同态滤波实现</h3><h4 id="同态滤波结构"><a href="#同态滤波结构" class="headerlink" title="同态滤波结构"></a>同态滤波结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">homomophic filter</span><br><span class="line">|</span><br><span class="line">|-log_img &#x3D; log(img + 1)</span><br><span class="line">|</span><br><span class="line">|-ft_img &#x3D; fft(img)</span><br><span class="line">|</span><br><span class="line">|-h_img &#x3D; ft_img.*H</span><br><span class="line">|</span><br><span class="line">|-ift_img &#x3D; ifft(h_img)</span><br><span class="line">|</span><br><span class="line">|-res_img &#x3D; exp(ift_img) - 1</span><br></pre></td></tr></table></figure><h4 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">homomorphic_filt</span><span class="params">( input_img, rL, rH, c, d )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%同态滤波参数设置</span></span><br><span class="line">    <span class="comment">%rL = 0.1; %低频放大系数</span></span><br><span class="line">    <span class="comment">%rH = 5; %高频放大系数</span></span><br><span class="line">    <span class="comment">%c = 0.2; %高斯变换常数系数</span></span><br><span class="line">    <span class="comment">%d = 8000; %高斯变换系数</span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    input_img = double(input_img);</span><br><span class="line"></span><br><span class="line">    log_img = <span class="built_in">log</span>(input_img+<span class="number">1</span>);</span><br><span class="line">    ft_img = fft2(log_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%构造高斯滤波器</span></span><br><span class="line">    H = <span class="built_in">zeros</span>(M,N);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            D = (<span class="built_in">i</span>.^<span class="number">2</span>+<span class="built_in">j</span>.^<span class="number">2</span>);</span><br><span class="line">            H(<span class="built_in">i</span>,<span class="built_in">j</span>) = (rH-rL).*(<span class="number">1</span>-<span class="built_in">exp</span>(-c.*(D./(d^<span class="number">2</span>))))+rL;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    filted_img = H.*ft_img;</span><br><span class="line">    ift_img = ifft2(filted_img);</span><br><span class="line">    exp_img = <span class="built_in">exp</span>(ift_img)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    output_img = uint8(<span class="built_in">abs</span>(exp_img));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="有关中心化的处理"><a href="#有关中心化的处理" class="headerlink" title="有关中心化的处理"></a>有关中心化的处理</h4><p>参考了许多CSDN网站上的博客，发现他们都有将高斯滤波器中心化的操作，但是我个人认为这是不必要的操作，仅仅是坐标轴的变换而已。<br>我们来分类讨论一下，如果图像的傅里叶变换没有进行平移操作（fftshift），那么结果的左上角是低频成分，沿着x、y轴坐标增加的方向，频率逐渐增高，那么高通滤波器应该如何设置呢？以左上角为原点，到远点的距离为变量即可构造高斯高通滤波器。但是如果以图片中心点为原点，这时候H需要进行平移，将它和图像的傅里叶变换结果的高低频区域对齐。</p><h3 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h3><center>原图</center>  <img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/1.jpg">  <center>灰度图</center>  <img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/gray.jpg">  <center>变换后的图</center>  <img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/0_2-2-0_2-1000.jpg">  <p>可以看出变换后的图像有明显的二值化现象，图片的展现效果不好。</p><h3 id="四、失误与总结"><a href="#四、失误与总结" class="headerlink" title="四、失误与总结"></a>四、失误与总结</h3><h4 id="图像二值化的原因及改进"><a href="#图像二值化的原因及改进" class="headerlink" title="图像二值化的原因及改进"></a>图像二值化的原因及改进</h4><p>在调试过程中，发现取指数后的矩阵元素的值非常小，所以在之后的取整等操作无法反映图像的真实灰度，因此需要将取对数后的图像的灰度拓展到0到255。改进策略是将指数图像的最大最小值取出，然后将指数图像与最小值的差按比例放大到0到255。<br><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/error1.jpg">  </p><center>取指数后的图像矩阵部分元素</center>  <ul><li>改进后的代码 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">homomorphic_filt</span><span class="params">( input_img, rL, rH, c, d )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%同态滤波参数设置</span></span><br><span class="line">    <span class="comment">%rL = 0.1; %低频放大系数</span></span><br><span class="line">    <span class="comment">%rH = 5; %高频放大系数</span></span><br><span class="line">    <span class="comment">%c = 0.2; %高斯变换常数系数</span></span><br><span class="line">    <span class="comment">%d = 8000; %高斯变换系数</span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    input_img = double(input_img);</span><br><span class="line"></span><br><span class="line">    log_img = <span class="built_in">log</span>(input_img+<span class="number">1</span>);</span><br><span class="line">    ft_img = fft2(log_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%构造高斯滤波器</span></span><br><span class="line">    H = <span class="built_in">zeros</span>(M,N);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            D = (<span class="built_in">i</span>.^<span class="number">2</span>+<span class="built_in">j</span>.^<span class="number">2</span>);</span><br><span class="line">            H(<span class="built_in">i</span>,<span class="built_in">j</span>) = (rH-rL).*(<span class="number">1</span>-<span class="built_in">exp</span>(-c.*(D./(d^<span class="number">2</span>))))+rL;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    filted_img = H.*ft_img;</span><br><span class="line">    ift_img = ifft2(filted_img);</span><br><span class="line">    exp_img = <span class="built_in">exp</span>(ift_img);</span><br><span class="line">    output_img = </span><br><span class="line">        uint8( <span class="number">255</span> * ( exp_img - <span class="built_in">ones</span>(M,N)*<span class="built_in">min</span>(<span class="built_in">min</span>(exp_img)) ) </span><br><span class="line">                / ( <span class="built_in">max</span>(<span class="built_in">max</span>(exp_img)) - <span class="built_in">min</span>(<span class="built_in">min</span>(exp_img)) ) );</span><br><span class="line">    <span class="comment">%output_img = uint8(abs(exp_img));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>改进后实验结果<img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/homofilt.jpg">  <center>改进后变换后的图</center></li></ul><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><p>这次的实验参数较多，调参的过程比设计算法的过程还要长，但是通过调参也能够理解各个参数的对图像的影响。比如d和rH的作用又互相抵消的效果，c参数会让图片整体明暗发生变化。至于为什么会出现这些现象，还是要从原理入手，这里还需研究。如果有可能的话，之后会制作四个参数在一定范围内变化的图像效果变化动图，更加直观的显示四个参数的影响。  </p><center><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:直方图均衡化</title>
    <link href="http://jiahaohong.github.io/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/"/>
    <id>http://jiahaohong.github.io/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</id>
    <published>2020-10-05T10:37:57.000Z</published>
    <updated>2020-10-25T14:26:31.356Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是直方图均衡化"><a href="#一、什么是直方图均衡化" class="headerlink" title="一、什么是直方图均衡化"></a>一、什么是直方图均衡化</h3><h4 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h4><p>原图的灰度直方图形象的反映了图片整体的明暗程度，横轴为像素灰度级，范围是0到255，纵轴是各个灰度的像素个数占总像素的比。当图片偏亮时，灰度级高的像素占比大，当图片偏暗时，灰度级低的像素占比大。  </p><h4 id="均衡化"><a href="#均衡化" class="headerlink" title="均衡化"></a>均衡化</h4><p>均衡化的意义是将所有灰度级的像素出现概率调整成一致的，但是这只在连续情况下有效，一般来说，离散的图像灰度级均衡化后各级的概率是不一样的。</p><h4 id="为什么要均衡化"><a href="#为什么要均衡化" class="headerlink" title="为什么要均衡化"></a>为什么要均衡化</h4><p>根据香农信息的定义，图像在灰度均匀出现时所携带的信息量最大，因此，过亮或过暗的图片携带的信息都很少，不利于人眼等的分辨，直方图均衡化可以尽可能的增加图像的信息量。</p><h3 id="二、直方图均衡化的实现"><a href="#二、直方图均衡化的实现" class="headerlink" title="二、直方图均衡化的实现"></a>二、直方图均衡化的实现</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-histogram_equalize %直方图均衡化</span><br><span class="line">| |</span><br><span class="line">| |-count_gray %统计灰度直方图</span><br><span class="line">| |-acc_gray   %计算累计直方图</span><br></pre></td></tr></table></figure><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">histogram_equalize</span><span class="params">( input_img )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    output_img = <span class="built_in">zeros</span>(M,N); <span class="comment">%初始化输出图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%统计原图像灰度直方图</span></span><br><span class="line">    gray_histogram = count_gray(input_img);</span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">25565</span>);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    bar(gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'orig gray histogram'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%计算累计直方图</span></span><br><span class="line">    acc_gray_histogram = acc_gray(gray_histogram);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    bar(acc_gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'acc gray histogram'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%灰度转换</span></span><br><span class="line">    gray_trans = acc_gray_histogram*<span class="number">255</span>;</span><br><span class="line">    gray_trans = uint8(<span class="built_in">round</span>(gray_trans));</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    bar(gray_trans);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'gray trans'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            gray_level = input_img(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">            output_img(<span class="built_in">i</span>,<span class="built_in">j</span>) = gray_trans(gray_level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    output_img = uint8(output_img);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%统计转换后图像的灰度直方图</span></span><br><span class="line">    new_gray_histogram = count_gray(output_img);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    bar(new_gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'new gray histogram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="统计灰度直方图"><a href="#统计灰度直方图" class="headerlink" title="统计灰度直方图"></a>统计灰度直方图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ gray_histogram ]</span> = <span class="title">count_gray</span><span class="params">( input_img )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%建立和灰度级登场的数组，数组下标就是灰度级，数组内容为该灰度级的像素出现概率</span></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    gray_histogram = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            gray_level = input_img(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">            gray_histogram(gray_level+<span class="number">1</span>) = gray_histogram(gray_level+<span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    gray_histogram = gray_histogram / M / N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="计算累计直方图"><a href="#计算累计直方图" class="headerlink" title="计算累计直方图"></a>计算累计直方图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ acc_gray_histogram ]</span> = <span class="title">acc_gray</span><span class="params">( gray_histogram )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(gray_histogram);</span><br><span class="line">    acc_gray_histogram = <span class="built_in">zeros</span>(M,N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%将每个灰度级加上前一个灰度级和本灰度级的概率</span></span><br><span class="line">    acc_gray_histogram(<span class="number">1</span>) = gray_histogram(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:N</span><br><span class="line">        acc_gray_histogram(<span class="built_in">i</span>) = gray_histogram(<span class="built_in">i</span>)+acc_gray_histogram(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h3><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/hw_all.jpg" width="800"><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/hw_all_data.jpg" width="800"><center>图1</center><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/dark_all.jpg" width="800"><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/dark_all_data.jpg" width="800"><center>图2</center><h3 id="四、失误与总结"><a href="#四、失误与总结" class="headerlink" title="四、失误与总结"></a>四、失误与总结</h3><h4 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h4><p>由于对matlab的数组下表还是不太熟悉，统计灰度图那里一直报错索引问题，后来查出是图像中有灰度为0的像素，但是数组下标没有0，而是从1开始，所以统计灰度的时候图片像素大小都加了1，转换的时候也是。</p><h4 id="figure覆盖"><a href="#figure覆盖" class="headerlink" title="figure覆盖"></a>figure覆盖</h4><p>由于以前显示的时候总会覆盖之前的figure，所以我索性把函数里的figure值设得非常大，就不会出现覆盖的问题，后来查到代码<strong>hold on</strong>也有同样的效果。</p><h4 id="bar柱状图"><a href="#bar柱状图" class="headerlink" title="bar柱状图"></a>bar柱状图</h4><p>柱状图的命名，限制范围和普通plot图一样，输入可以是x数组和有数组，x、y一一对应，也可以是一个一维数组，这样数组下标作为x轴。    </p><center><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/histogram-equalize-and-homo-filter.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Linux:Ubuntu18.04小白安装教程</title>
    <link href="http://jiahaohong.github.io/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://jiahaohong.github.io/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2020-09-25T23:38:59.000Z</published>
    <updated>2020-10-20T12:16:50.438Z</updated>
    
    <content type="html"><![CDATA[<p><em>本教程原系统Windows10</em><br><em>安装Ubuntu18.04.3版本</em><br><em>电脑联想Y7000</em><br><em>手机华为P10</em> </p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p><a href="https://releases.ubuntu.com/18.04.5/ubuntu-18.04.5-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu18.05下载</a>  </p></li><li><p>8G U盘一个</p></li><li><p>能上网的手机一个</p></li></ul><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p><em><strong>注意之后提到的按键以平台为准，可能和你的电脑或手机不一样</strong></em></p><h4 id="1-制作启动盘"><a href="#1-制作启动盘" class="headerlink" title="1. 制作启动盘"></a>1. 制作启动盘</h4><p>WIN10下用文件资源管理器打开上面下载的ISO文件，把里面的文件全部复制粘贴到U盘里。<strong>接下来的操作不要拔下U盘</strong>。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ISO.jpg"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ISO2.jpg"></p><h4 id="2-重启电脑进入BIOS"><a href="#2-重启电脑进入BIOS" class="headerlink" title="2. 重启电脑进入BIOS"></a>2. 重启电脑进入BIOS</h4><p>重启电脑，在<strong>电脑重新开启之前</strong>按住F2键不放，然后进入BIOS界面。<strong>注意每个厂家生产的电脑进入BIOS的键不一样</strong>，我的联想Y7000是F2键，其他电脑的快捷键可以去网上查。  </p><h4 id="3-修改安全启动项SecurityBoot"><a href="#3-修改安全启动项SecurityBoot" class="headerlink" title="3. 修改安全启动项SecurityBoot"></a>3. 修改安全启动项SecurityBoot</h4><p>左右键切换页面到Security界面，上下键选择到SecurityBoot项，按下F5键将其改为Disable。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/SecurityBoot.jpg">  </p><h4 id="4-将启动盘（U盘）启动优先级调到第一"><a href="#4-将启动盘（U盘）启动优先级调到第一" class="headerlink" title="4. 将启动盘（U盘）启动优先级调到第一"></a>4. 将启动盘（U盘）启动优先级调到第一</h4><p>左右键切换页面到Boot界面，上下键选择到U盘启动项，一般来说后面<strong>括号</strong>里显示的是你<strong>U盘的型号</strong>那个就是启动盘，按F6键将其上移到第一个。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Boot.jpg"></p><h4 id="5-保存修改并重启"><a href="#5-保存修改并重启" class="headerlink" title="5. 保存修改并重启"></a>5. 保存修改并重启</h4><p>按F10键保存BIOS修改，弹出确认框，左右键选择Yes后回车，系统自动关机，重新打开电脑即可进入U盘里的启动项。</p><h4 id="6-选择安装Ubuntu项"><a href="#6-选择安装Ubuntu项" class="headerlink" title="6. 选择安装Ubuntu项"></a>6. 选择安装Ubuntu项</h4><p>进入U盘里的启动项后，选择Install Ubuntu选项安装Ubuntu系统。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Install.jpg"></p><h4 id="7-连接手机"><a href="#7-连接手机" class="headerlink" title="7. 连接手机"></a>7. <strong>连接手机</strong></h4><p>注意，这是很重要的一步，之后的自动更新需要用到手机的网络。用USB线连接手机和电脑，这时手机上会显示几个选项，选择传输文件（点了之后弹窗就没了）。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone1.jpg" width="200" height="200"><br>找到设置-&gt;移动网络-&gt;移动网络共享，打开USB共享网络。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone4.jpg" width="200" height="400"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone2.jpg" width="200" height="400"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone3.jpg" width="200" height="400"><br>这时候，Ubuntu安装界面右上角出现一个图标就表示电脑已经连上网了。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Wireless.png"></p><p>现在万事俱备，进入Ubuntu安装程序后，跟着他的步骤一步一步来。</p><h4 id="8-键盘布局"><a href="#8-键盘布局" class="headerlink" title="8. 键盘布局"></a>8. 键盘布局</h4><p>键盘布局选择汉语。</p><h4 id="9-连接wifi无线网络"><a href="#9-连接wifi无线网络" class="headerlink" title="9. 连接wifi无线网络"></a>9. 连接wifi无线网络</h4><p>选择不想连接，因为手机已经共享了。  </p><h4 id="10-更新和其他软件"><a href="#10-更新和其他软件" class="headerlink" title="10. 更新和其他软件"></a>10. 更新和其他软件</h4><p>选择最小安装，并且安装第三方软件。安装第三方软件需要之前手机的网络，大概两三百MB。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/update.jpg"></p><h4 id="11-安装类型"><a href="#11-安装类型" class="headerlink" title="11. 安装类型"></a>11. 安装类型</h4><p>选择和Win10Boot共存的那个选项。</p><h4 id="12-等待安装完成！"><a href="#12-等待安装完成！" class="headerlink" title="12. 等待安装完成！"></a>12. 等待安装完成！</h4><p>这个安装方式十分方便，安装完成后可以直接用，不需要自己再配置什么驱动，独立显卡驱动除外，之后可能会有一篇博客讲解Nvidia独显驱动安装。总结：见文章内容导航！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本教程原系统Windows10&lt;/em&gt;&lt;br&gt;&lt;em&gt;安装Ubuntu18.04.3版本&lt;/em&gt;&lt;br&gt;&lt;em&gt;电脑联想Y7000&lt;/em&gt;&lt;br&gt;&lt;em&gt;手机华为P10&lt;/em&gt; &lt;/p&gt;
&lt;h3 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class
      
    
    </summary>
    
    
      <category term="Linux学习之路" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://Jiahaohong.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:快速傅里叶变换实现</title>
    <link href="http://jiahaohong.github.io/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jiahaohong.github.io/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-19T19:13:55.000Z</published>
    <updated>2020-10-25T13:49:32.849Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Jiahaohong/FFT.git" target="_blank" rel="noopener">原码下载地址</a></p><h3 id="一、什么是傅里叶变换"><a href="#一、什么是傅里叶变换" class="headerlink" title="一、什么是傅里叶变换"></a>一、什么是傅里叶变换</h3><p>简单来说，傅里叶变换将一个函数分解为一组三角函数的和，通过将这个函数分别和这组三角函数中的每一个进行内积运算，可以求得每个三角函数前面的系数。  </p><h4 id="正交函数集"><a href="#正交函数集" class="headerlink" title="正交函数集"></a>正交函数集</h4><p>正交函数集满足如下两条性质：  </p><ol><li>正交函数集中的任意两个不相同函数的内积为0；  </li><li>如果某函数集中存在一个函数可以由函数集中除它以外的函数表示，则这个函数集不是正交函数集。  </li></ol><p>用类比的角度看，这个定义和线性代数中的基向量组的定义一致。说明正交函数集其实相当于函数空间中的一组基向量，函数空间中的一个函数对应向量空间中的一个向量，任何向量可以由基向量表示，同样的，任何函数可以由正交函数集表示。基向量可以写成矩阵的形式，同理，正交函数集也可以写成向量的形式。如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  这是一个1维向量，当前乘一个函数时就可以利用矩阵的乘法将函数分解到这个正交函数集上。  <center>[f(x)] * [1, sin(wx), cos(wx), ..., sin(nwx), cos(nwx), ...] =</center>  <center>[a0, b1*sin(wx), a1*cos(wx), ..., bn*sin(nwx), an*cos(nwx), ...]</center>  注意这些系数通过原函数f(x)和基函数内积等运算得到的。  <h4 id="内积运算"><a href="#内积运算" class="headerlink" title="内积运算"></a>内积运算</h4><p>内积定义为向量a在向量b上的投影向量，当内积运算后的结果除以向量b的模长，就可以计算出向量a在向量b上投影占向量b的比例，这个比例就是基函数前面的系数。内积是反映两个向量相似度的重要指标，当两个向量完全相等时，它们的内积取得最大值。因此正交函数集的系数的含义，可以理解为原函数和基函数的相似度，相似度越大，这个基函数的系数越大。</p><p>因此，总体上来看，正交函数集构成了一个无穷维数的函数空间，这个空间里的任何函数都可以由这些基函数的加权求和表示，权重就是原函数和积函数的内积，及将原函数投影到这些正交函数上。当然可以用欧拉公式将这些三角基函数合并指数基函数，只不过这些基函数建立在复数域内了，后面的快速傅里叶实现也采用复数域内的正交函数集。  </p><h3 id="二、离散傅里叶变换"><a href="#二、离散傅里叶变换" class="headerlink" title="二、离散傅里叶变换"></a>二、离散傅里叶变换</h3><p>第一部分中讲到傅里叶变换是连续函数空间里的，如果处理的函数是一个离散的函数，那么就要用到离散傅里叶变换。离散傅里叶变换与来连续傅里叶变换的最大区别是求系数时的积分运算变成了求和运算。将正交函数集的向量形式抄写如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  注意，这里的每一列都是一个连续函数，如果用离散的x坐标将其离散化，就可以获得离散傅里叶变换的正交函数集矩阵，如下：<div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/DMat.jpg" width="500" height="280"></div><p>这是一个二维矩阵，每一列代表一个正交函数，每一行坐标代表一个离散坐标x。将离散函数写成向量的形式后就可以用矩阵的乘法求出变换后的函数。这时有人会注意到，这个离散的矩阵两个维度都是无穷的，如果离散信号不一定是无穷的，那怎么运算呢？我们分别讨论一下：  </p><ol><li>变换矩阵的行数<br>如果要满足矩阵乘法定义，那么变换矩阵的行的个数必须和输入信号的变量取值范围相同，及与x的取值范围一致。如果输入信号的取值范围是无穷的，那么变换矩阵的行也有无数个。</li><li>变换矩阵的列数<br>由于变换矩阵的列数没有严格的定义，可多可少，但是由于每一列代表一种基函数，基函数的个数决定了表达的误差，一般来说和输入变量的x取值范围相同即可。</li></ol><h3 id="三、一维快速傅里叶变换的原理"><a href="#三、一维快速傅里叶变换的原理" class="headerlink" title="三、一维快速傅里叶变换的原理"></a>三、一维快速傅里叶变换的原理</h3><p>快速傅里叶变换有许多种，这里介绍的快速傅里叶变换通过将冗余的指数运算记录下来，以此减少乘法次数，加快运算速度。一维离散傅里叶公式如下：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1D.jpg" width="290" height="55"></div>  能否找到冗余计算？看样子很难，这里直接给出简化算法的核心公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo.jpg" width="280" height="50"></div>  这个公式其实很简单，本质就是一个约分，但是这个约分给我们提供了分离傅里叶变换的思路——奇偶分离。当一维傅里叶变换的输入信号的变量取值范围是2的整数倍，那么一维傅里叶变换的求和可以分为奇数部分求和、偶数部分求和，如下公式所示：<div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo2.jpg" width="500" height="200"></div>  看出来了吗？这里奇数部分和偶数部分有相同的分量，取值范围都是从0到M-1，你能看出来它也是傅里叶变换公式吗？下面这个公式将更加清晰：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo3.jpg" width="450" height="100"></div>    其中g(x)部分是原函数中自变量x取偶数时组成的新函数，h(x)是原函数自变量取奇数时组成的函数，将他们看成新的原函数，那么奇数部分和偶数部分就都是新的一维离散傅里叶变换了。这说明，原函数自变量取值范围是偶数时，原函数的傅里叶变换可以由自变量是偶数部分的傅里叶变换和自变量是奇数部分的傅里叶变换组合而成，并且这两部分互不影响。这是一个重要的结论，为后面的递归提供依据。为了方便书写，我们将偶数部分的傅里叶变换记作F<sub>even</sub>(u)，将奇数部分的傅里叶变换记作F<sub>odd</sub>(u)，那么一维傅里叶变换可以写成如下公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo4.jpg" width="290" height="55"></div>  必须要注意的是，上述公式的奇数部分和偶数部分都是N/2个，那么根据一般变换后自变量取值范围和原函数相同，可以知道u的取值范围从原来的N变成了N/2，那么后面一半怎么补全呢？我们再来看两个核心公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo5.jpg" width="200" height="110"></div>   将这两个公式带入F(u+M)，就可以算出后半部分其表达式。<h3 id="四、二维傅里叶变换的性质"><a href="#四、二维傅里叶变换的性质" class="headerlink" title="四、二维傅里叶变换的性质"></a>四、二维傅里叶变换的性质</h3><p>第三部分讲到一维离散傅里叶快速变换的基本原理，但对于二维快速傅里叶变换这还不够，我们需要探讨一下二维傅里叶变换的基本性质，才能将一维的变换应用到二维的求解中。在讨论二维傅里叶变换的性质之前，我们给出其定义公式：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2D.png" width="290" height="55"></div>   <h4 id="可分离性"><a href="#可分离性" class="headerlink" title="可分离性"></a>可分离性</h4><p>根据二维傅里叶变换的公式，可以比较轻松地看出，中括号里的计算是不涉及变量x的，换句话说，中括号里的计算是需要事先给定x的值，然后再计算，x在这里相当于一个常数，因此可以将中括号里面和外面的计算分离。这样，一个二维的傅里叶变换就变成了两个一维傅里叶变换：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2DCoreAlgo.jpg" width="420" height="95"></div>  <h4 id="平移性"><a href="#平移性" class="headerlink" title="平移性"></a>平移性</h4><p>二维傅里叶变换的平移性质和一维傅里叶变换的平移性质一脉相承，只不过一维中讲的是时域的平移，二维中讲的是空域的平移。这个性质在之后对图像的二维傅里叶变换中将要用到。    </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2DCoreAlgo2.jpg" width="400" height="160"></div>  <h3 id="五、二维快速傅里叶变换的实现"><a href="#五、二维快速傅里叶变换的实现" class="headerlink" title="五、二维快速傅里叶变换的实现"></a>五、二维快速傅里叶变换的实现</h3><p>原理和性质都讲完了，接下来讲讲如何实现二维快速傅里叶变换。<br><em>本次使用软件MATLAB R2017a</em></p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-image input</span><br><span class="line">|</span><br><span class="line">|-myft3</span><br><span class="line">| |</span><br><span class="line">| |-myfft</span><br><span class="line">| |(recursion)</span><br><span class="line">|</span><br><span class="line">|-shift myft3</span><br><span class="line">|</span><br><span class="line">|-ifft2</span><br></pre></td></tr></table></figure><h4 id="图像输入"><a href="#图像输入" class="headerlink" title="图像输入"></a>图像输入</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origImg = imread(<span class="string">'2.jpg'</span>);</span><br><span class="line">grayImg = rgb2gray(origImg); <span class="comment">%将图像转变成灰度图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">imshow(grayImg);</span><br></pre></td></tr></table></figure><h4 id="二维快速傅里叶变换"><a href="#二维快速傅里叶变换" class="headerlink" title="二维快速傅里叶变换"></a>二维快速傅里叶变换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ftImg = myft3(grayImg);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">imshow(<span class="built_in">abs</span>(<span class="built_in">log</span>(ftImg)+<span class="number">1</span>),[]);</span><br></pre></td></tr></table></figure><p>由于傅里叶变换的结果是一个<strong>complex double</strong>类型的矩阵，直接使用imshow函数的化将会造成无法正确输出的情况，所以需要对傅里叶变换后的矩阵进行<strong>log(x)+1</strong>的灰度变换，将矩阵的取值范围限制在合理范围，并且取模长使第二个参数[]可以自动调整输出灰度范围。<br>接下来详细介绍一下快速傅里叶变换的具体实现。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ outputMat ]</span> = <span class="title">myft3</span><span class="params">( inputMat )</span></span></span><br><span class="line"></span><br><span class="line">    [M0,N0] = <span class="built_in">size</span>(inputMat); <span class="comment">%获得输入图像的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%找到最接近输入图像大小（并且大于图像大小）的2^n，并将图片padding补零</span></span><br><span class="line">    M1 = find_upper_2n(M0);</span><br><span class="line">    N1 = find_upper_2n(N0);</span><br><span class="line">    outputMat = double(<span class="built_in">zeros</span>(M1,N1)); </span><br><span class="line">    tempMat = double(<span class="built_in">zeros</span>(M1,N1));</span><br><span class="line">    inputMat(M1,N1) = <span class="number">0</span>;</span><br><span class="line">    inputMat = double(inputMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%行列分开计算</span></span><br><span class="line">    <span class="keyword">for</span> x = <span class="number">1</span>:N1</span><br><span class="line">        tempMat(:,x) = myfft( inputMat(:,x).' ).'; <span class="comment">%输入是行向量，所以列向量转置再转置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:M1</span><br><span class="line">        outputMat(y,:) = myfft( tempMat(y,:) );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上一段是进入快速傅里叶变换的铺垫步骤，利用padding补零，使得后续一维傅里叶快速变换可以最大限度地递归进行，最大限度地减少重复计算。而padding补上的零值在傅里叶变换的求和中是没有起作用的，因此不影响原图片的傅里叶变换的值。  </p><h4 id="一维快速傅里叶变换"><a href="#一维快速傅里叶变换" class="headerlink" title="一维快速傅里叶变换"></a>一维快速傅里叶变换</h4><p>由第三部分可知，当输入函数的自变量取值范围是偶数时，输入函数的傅里叶变换可以由偶数部分和奇数部分各自的傅里叶变换通过简单组合得到，因此，我们采取递归的方式不断拆分输入函数，直到输入函数的自变量只能取1个值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ outputMat ]</span> = <span class="title">myfft</span><span class="params">( inputMat )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(inputMat);  <span class="comment">%获得输入一维矩阵（向量）的列数N，行数M没有用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(N,<span class="number">2</span>)==<span class="number">0</span>  <span class="comment">%当输入向量的长度可以拆分时进行递归</span></span><br><span class="line">        oddMat = myfft( inputMat(<span class="number">1</span>:<span class="number">2</span>:<span class="keyword">end</span>) );</span><br><span class="line">        evenMat = myfft( inputMat(<span class="number">2</span>:<span class="number">2</span>:<span class="keyword">end</span>) );</span><br><span class="line">        <span class="keyword">for</span> u=<span class="number">1</span>:N/<span class="number">2</span></span><br><span class="line">            evenMat(u) = evenMat(u)*<span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(u<span class="number">-1</span>)/N);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        foreMat = (oddMat + evenMat);</span><br><span class="line">        backMat = (oddMat - evenMat);</span><br><span class="line">        outputMat = <span class="built_in">cat</span>(<span class="number">2</span>,foreMat,backMat);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">%当输入向量长度为1时停止递归，返回单点傅里叶变换的值，及自身</span></span><br><span class="line">        outputMat = inputMat;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实不需要完全分到1个点再进行傅里叶变换，可以适当提前结束递归。</p><h4 id="二维快速傅里叶反变换"><a href="#二维快速傅里叶反变换" class="headerlink" title="二维快速傅里叶反变换"></a>二维快速傅里叶反变换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iftImg = <span class="built_in">abs</span>(ifft2(ftImg));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">imshow(iftImg,[]);</span><br></pre></td></tr></table></figure><p>这里反变换是利用Matlab提供的函数<strong>ifft2</strong>进行验证，如果正确的话，结果应该是原图片加上黑色边框。这里的验证完全可以用自己写的函数进行，将傅里叶变换后的矩阵进行共轭，再次进行傅里叶变换就可以得到原图像。如下代码所示：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftImg2 = <span class="built_in">conj</span>(ftImg);</span><br><span class="line">iftImg = <span class="built_in">abs</span>(myft3(ftImg2));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">imshow(iftImg,[]);</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/orig.jpg">  原图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/ft.jpg">  原傅里叶变换图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/shiftFt.jpg">  平移后的傅里叶变换图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/check.jpg">  iff2反变换结果图像</div><h3 id="六、失误与总结"><a href="#六、失误与总结" class="headerlink" title="六、失误与总结"></a>六、失误与总结</h3><h4 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标"></a>数组下标</h4><p>习惯了0作为初始下标，但是matlab的下标从1开始，有些地方需要转换。</p><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>matlab力有两种转置，<strong>.’</strong>是普通转置，<strong>‘</strong>是共轭转置，要分清楚。  </p><center><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/signH.jpg"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Jiahaohong/FFT.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原码下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、什么是傅里叶变换&quot;&gt;&lt;a href=&quot;#一、什么是傅里叶变换&quot; c
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Keil5安装芯片包</title>
    <link href="http://jiahaohong.github.io/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/"/>
    <id>http://jiahaohong.github.io/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/</id>
    <published>2020-07-29T06:03:03.000Z</published>
    <updated>2020-07-29T06:54:41.016Z</updated>
    
    <content type="html"><![CDATA[<p>如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：</p><ul><li><p>打开下载芯片包的界面</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/1.png"> </li><li><p>在左侧双击你需要的芯片</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/2.png"></li><li><p>点击右侧你需要的芯片包的Install按钮</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/3.png"></li><li><p>单击选中下方报错的行</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/4.png"></li><li><p>复制后粘贴到浏览器网址栏</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/5.png"></li><li><p>去掉头尾留下地址，按回车即可下载</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/6.png">  <img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/7.png"></li><li><p>下载完毕后回到下载芯片包界面，点击file里的import选项</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/8.png"></li><li><p>在弹出窗口里找到之前下载的文件导入</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/9.png"></li></ul><p>完成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开下载芯片包的界面&lt;/p&gt;
&lt;img src=&quot;/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E
      
    
    </summary>
    
    
    
      <category term="Keil5" scheme="http://Jiahaohong.github.io/tags/Keil5/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:制作数据集</title>
    <link href="http://jiahaohong.github.io/2020/07/22/Tensrflow-%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://jiahaohong.github.io/2020/07/22/Tensrflow-%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-07-22T13:45:51.000Z</published>
    <updated>2020-07-22T13:48:29.221Z</updated>
    
    <content type="html"><![CDATA[<p>tf.data.Dataset.from_tensor_slice(tensor)<br>将输入tensor按照第一个维度拆分</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tf.data.Dataset.from_tensor_slice(tensor)&lt;br&gt;将输入tensor按照第一个维度拆分&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令（重制版）</title>
    <link href="http://jiahaohong.github.io/2020/07/18/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://jiahaohong.github.io/2020/07/18/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-07-18T13:55:57.000Z</published>
    <updated>2020-10-20T12:17:21.150Z</updated>
    
    <content type="html"><![CDATA[<p><em>系统使用Ubuntu18.04，无图形界面，本地系统为Windows10</em></p><h3 id="一、Linux系统指令"><a href="#一、Linux系统指令" class="headerlink" title="一、Linux系统指令"></a>一、Linux系统指令</h3><ul><li>进入指定文件夹<br>cd /root/mygit/project1</li><li>进入上层文件夹<br>cd ..</li><li>进入根目录文件夹(root)<br>cd ~</li><li>显示当前文件夹路径<br>pwd</li><li>显示当前文件夹里的文件和文件夹<br>ls -l</li><li>在当前文件夹下创建文件夹<br>mkdir project2</li><li>在当前文件夹下创建文件<br>touch readme.txt<br>touch gitCommand.md<br>touch go.sh</li><li>删除文件或文件夹<br>sudo rm -r readme.txt<br>sudo rm -r project2</li><li>重命名文件或文件夹<br>mv readme.txt README.txt  </li><li>将上述指令结合起来使用，你就可以非常方便的解决一些文件操作的小问题了。比如进入某个文件夹，新建一个子文件夹用来存放自己的markdown笔记，就可以在命令窗口里输入如下命令：<br>cd /usr/note &amp;&amp; mkdir LinuxNotes &amp;&amp; touch day1.md</li></ul><h3 id="二、常用软件指令"><a href="#二、常用软件指令" class="headerlink" title="二、常用软件指令"></a>二、常用软件指令</h3><ul><li>screen<ul><li>新建一个新窗口<br>screen -S name<br>注意S是大写</li><li>将当前窗口挂起（后台运行）<br>ctrl + A + D<br>注意这是快捷键，按后面的键时不要松开前面的键</li><li>显示当前已经开启的窗口<br>screen -ls<br>显示的时候会显示窗口ID和名字，以及是否挂起</li><li>进入挂起窗口<br>screen -r name<br>注意r是小写</li><li>关闭窗口<br>kill ID<br>注意ID可以用screen -ls指令查看</li></ul></li><li>zip  <ul><li>解压文件到当前目录<br>unzip file.zip</li><li>压缩文件<br>zip -r file_name.zip file.txt<br>注意是将file.txt文件压缩为file_name.zip文件，不要弄反了 </li></ul></li></ul><h3 id="三、上传下载文件"><a href="#三、上传下载文件" class="headerlink" title="三、上传下载文件"></a>三、上传下载文件</h3><ul><li>rz/sz  <ul><li>从服务器下载文件<br>sz file.zip</li><li>从本地上传文件<br>rz<br>注意本地需要相应软件，比如Xshell</li></ul></li><li>windows命令窗口上传文件  <ul><li>pscp C:/fold1/fold1_2/file.txt <a href="mailto:root@xx.xxx.xxx.xxx">root@xx.xxx.xxx.xxx</a>:/usr/folderA  </li></ul></li></ul><h3 id="四、anaconda使用指令"><a href="#四、anaconda使用指令" class="headerlink" title="四、anaconda使用指令"></a>四、anaconda使用指令</h3><ul><li>查看虚拟环境列表<br>conda info -e</li><li>创建虚拟环境<br>conda create -n env_name</li><li>进入虚拟环境<br>conda activate env_name</li><li>退出虚拟环境<br>conda deactivate</li><li>在当前虚拟环境下安装 包<br>conda install appname<br>conda install URL</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;系统使用Ubuntu18.04，无图形界面，本地系统为Windows10&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、Linux系统指令&quot;&gt;&lt;a href=&quot;#一、Linux系统指令&quot; class=&quot;headerlink&quot; title=&quot;一、Linux系统指令&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux学习之路" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="http://Jiahaohong.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深度学习：卷积神经网络</title>
    <link href="http://jiahaohong.github.io/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://jiahaohong.github.io/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-17T13:57:15.000Z</published>
    <updated>2020-09-25T23:29:00.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、卷积神经网络符号说明"><a href="#一、卷积神经网络符号说明" class="headerlink" title="一、卷积神经网络符号说明"></a>一、卷积神经网络符号说明</h3><p><em>这里将卷积层和池化层看作一层神经网络，但分开描述</em><br><em>这里手的图像可以是抽象的多维矩阵</em></p><ol><li><p>图像n  </p><ul><li>图像数量：m  </li><li>图像高度：n<sub>H</sub>  </li><li>图像宽度：n<sub>W</sub>  </li><li>图像信道：n<sub>C</sub></li></ul></li><li><p>过滤器Filter  </p><ul><li>形状：f<sub>H</sub><sup>[l]</sup> * f<sub>W</sub><sup>[l]</sup>，指一个过滤器的一层矩阵的高和宽，大多数的时候，f<sub>H</sub><sup>[l]</sup> =  f<sub>W</sub><sup>[l]</sup> = 3  </li><li>边沿padding：p<sup>[l]</sup>，用来将过滤器要过滤的图像填充成指定形状</li><li>步长step：s<sup>[l]</sup>，表示过滤器在输入图像上移动一次所经过的像素个数</li><li>信道channel：n<sub>C</sub><sup>[l-1]</sup>，注意，第l层的过滤器的信道数量和上一层的输出图像信道数量相同，这是卷积运算的前提条件  </li></ul></li><li><p>池化层Pooling  </p><ul><li>形状：f<sub>H</sub><sup>[l]</sup> * f<sub>W</sub><sup>[l]</sup></li><li>边沿padding：p<sup>[l]</sup>，用来将池化层要池化的图像填充成指定形状</li><li>步长step：s<sup>[l]</sup>，表示池在输入图像上移动一次所经过的像素个数</li><li>信道channel：n<sub>C</sub><sup>[l]</sup> = f<sub>m</sub>，注意，第l层的池的信道数量和这一层过滤器的个数相同。</li></ul></li><li><p>全连接FullConnection</p><ul><li>普通的神经网络连接层</li></ul></li></ol><h3 id="二、卷积神经网络的基本模块"><a href="#二、卷积神经网络的基本模块" class="headerlink" title="二、卷积神经网络的基本模块"></a>二、卷积神经网络的基本模块</h3><ol><li>卷积层<br>卷积操作是由过滤器和上一层的输出完成的。首先来看看卷积操作是如何完成的，然后再研究其中的数据维数等细节。  <ul><li>卷积操作<br>图像的形状为n<sub>H</sub> * n<sub>W</sub>，过滤器的形状为f<sub>H</sub> * f<sub>W</sub>，假设图像没有加边沿padding，过滤器的步长为1，那么将过滤器矩阵和图像矩阵左上角对齐，重叠的格子中的数据相乘，将得到的结果相加作为输出矩阵的第一个元素，然后将过滤器矩阵右移一个像素（一个步长），重复上述操作得到输出矩阵的第二个元素，以此类推，直到右移超出图像边界时，向下移动一个像素，再从最左边开始重复上述操作。</li><li>数据维数<br>由于过滤器所操作的图像可能有多层通道，那么过滤器的通道数和图像必须对应，相同通道的过滤器和图像矩阵进行卷积操作，得到的结果相加作为输出矩阵的一个通道。因此，过滤器有几个，输出矩阵的通道数就有几个。</li></ul></li><li>池化层<br>池化操作简单来说是将图片分为几个区域，从中挑选出符合要求的数据组成新的图像。池和过滤器的结构和定义相似，只不过池中矩阵的每一位上没有权重，只是用来区分图像区域。池化操作和卷积的操作流程相似，但不是将池中的数据加权求和，而是取最大值或平均值作为输出。</li><li>全连接层<br>全连接层时普通的DNN网络，通过将之前网络提取出来的特征展平，再连接，最后输出结果</li></ol><h3 id="三、卷积神经网络的前向传播和反向传播算法"><a href="#三、卷积神经网络的前向传播和反向传播算法" class="headerlink" title="三、卷积神经网络的前向传播和反向传播算法"></a>三、卷积神经网络的前向传播和反向传播算法</h3><p>。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、卷积神经网络符号说明&quot;&gt;&lt;a href=&quot;#一、卷积神经网络符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、卷积神经网络符号说明&quot;&gt;&lt;/a&gt;一、卷积神经网络符号说明&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这里将卷积层和池化层看作一层神经网络，但分开描述&lt;/
      
    
    </summary>
    
    
      <category term="深度学习学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://Jiahaohong.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Python:Numpy</title>
    <link href="http://jiahaohong.github.io/2020/07/11/Python-Numpy/"/>
    <id>http://jiahaohong.github.io/2020/07/11/Python-Numpy/</id>
    <published>2020-07-11T09:39:51.000Z</published>
    <updated>2020-07-19T11:56:49.614Z</updated>
    
    <content type="html"><![CDATA[<ul><li>np.zeros(shape, dtype=float)  </li><li>np.random.rand()<br>括号里为矩阵维数，获得数值在0~1之间的随机数矩阵</li><li>np.random.randn()<br>括号里为矩阵维数，获得数值为正态分布的随机数矩阵</li><li>np.sum(A,axis=None)<br>把axis对应的维度的数相加，变成0维</li><li>np.squeeze(X)<br>把X中只有1个元素的维度去掉</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;np.zeros(shape, dtype=float)  &lt;/li&gt;
&lt;li&gt;np.random.rand()&lt;br&gt;括号里为矩阵维数，获得数值在0~1之间的随机数矩阵&lt;/li&gt;
&lt;li&gt;np.random.randn()&lt;br&gt;括号里为矩阵维数，获得数值为正
      
    
    </summary>
    
    
    
      <category term="Python" scheme="http://Jiahaohong.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习：逻辑回归的符号和公式</title>
    <link href="http://jiahaohong.github.io/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <id>http://jiahaohong.github.io/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F/</id>
    <published>2020-07-07T01:48:36.000Z</published>
    <updated>2020-10-14T07:02:02.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、符号说明"><a href="#一、符号说明" class="headerlink" title="一、符号说明"></a>一、符号说明</h3><p>一个样本包含两个部分，特征x和标签y</p><ul><li>x<br>表示某一个样本的特征的集合，通常是一个列向量，其中每一个维度表示一个特征</li><li>x<sub>j</sub><br>表示第j个特征</li><li>x<sup>(i)</sup><br>表示第i个样本的特征数据，注意上标是小括号</li><li>x<sup>(i)</sup><sub>j</sub><br>表示第i个样本的第j个特征，注意上标是小括号</li><li>y<br>表示一个样本的真实标签，通常时一个列向量，其中每一个维度代表一个种类，如果该样本这一个维度为0，表示该样本不属于该种类；如果该样本的这一维度为1，表示该样本属于该种类</li><li>y<sup>(i)</sup><br>表示第i个样本的标签，注意上标是小括号  </li></ul><p>一层神经网络由三部分组成，第一部分是与上一层神经网络连接的权重矩阵，第二部分是权重矩阵的输出，第三部分是权重矩阵的输出经过该层神经元的激活函数后的输出结果</p><ul><li>n<sub>i</sub><br>表示第i层神经网络的神经元个数，通常输入层（第0层）写作n<sub>x</sub>，输出层（最后一层）写作n<sub>L</sub></li><li>W<sup>[i]</sup><br>表示连接第i-1层和第i层神经元的权重矩阵，矩阵形状为(n<sub>i</sub>,n<sub>i-1</sub>)，n<sub>i</sub>是第i层的神经元个数</li><li>Z<sup>[i]</sup><br>表示第i层神经元的输入</li><li>A<sup>[i]</sup><br>表示Z<sup>[i]</sup>经过第i层神经元的激活函数后的输出，之后要输入到下一层的权重矩阵W<sup>[i+1]</sup>里；特别的，输入的样本特征可以看作是A<sup>[0]</sup>  </li></ul><p>偏导数部分的符号是程序里的变量标识符，不是数学里的微分字符</p><ul><li>dW<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li><li>dZ<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li><li>dA<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li></ul><h3 id="二、公式"><a href="#二、公式" class="headerlink" title="二、公式"></a>二、公式</h3><ol><li>前向传播公式<br>(1) Z<sup>[i]</sup> = W<sup>[i]</sup> · A<sup>[i-1]</sup> + b<sup>[i]</sup><br>(2) A<sup>[i]</sup> = g<sup>[i]</sup>(Z<sup>[i]</sup>)</li><li>反向传播公式<br>(1) dW<sup>[i]</sup> = (1/m)·dZ<sup>[i]</sup>·A<sup>[i-1]T</sup><br>(2) db<sup>[i]</sup> = (1/m)·sum(dZ<sup>[i]</sup>)<br>(3) dZ<sup>[i-1]</sup> = W<sup>[i]T</sup>·dZ<sup>[i]</sup>*g<sup>[i-1]’</sup>(Z<sup>[i-1]</sup>)</li><li>公示推导的简单说明<br>对于公式1，根据矩阵求导公式d( f(X) ) = d( A·X )/dX = A<sup>T</sup>，再由矩阵相等时维度相同，可得1个样本时的偏导数为dZ<sup>[i]</sup>·A<sup>[i-1]T</sup>，如果有m个样本，则取平均值1/m。<br>对于公式3，类似公式1的求导公式得出下一层网络的输入Z<sup>[i]</sup>对上一层网络的输出A<sup>[i-1]</sup>的偏导函数为W<sup>[i]T</sup>,同样根据矩阵相等时维度必须相同可得公式3，注意后面的g<sup>[i-1]’</sup>(Z<sup>[i-1]</sup>)只不过是A<sup>[i-1]</sup>对Z<sup>[i-1]</sup>的偏导函数，因为A<sup>[i-1]</sup> = g<sup>[i-1]</sup>(Z<sup>[i-1]</sup>)。</li></ol><h3 id="三、常用激活函数导数"><a href="#三、常用激活函数导数" class="headerlink" title="三、常用激活函数导数"></a>三、常用激活函数导数</h3><ul><li>S(x) = sigmoid(X)<br> S<sup>‘</sup>(x) = S(x)·(1-S(x))</li><li>f(x) = tanh(x)<br> f<sup>‘</sup>(x) = 1-(f(x))<sup>2</sup></li><li>f(x) = ReLU(x)<br> f<sup>‘</sup>(x) = max{0,a}</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、符号说明&quot;&gt;&lt;a href=&quot;#一、符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、符号说明&quot;&gt;&lt;/a&gt;一、符号说明&lt;/h3&gt;&lt;p&gt;一个样本包含两个部分，特征x和标签y&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x&lt;br&gt;表示某一个样本的特征的集合，通常是
      
    
    </summary>
    
    
      <category term="深度学习学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://Jiahaohong.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：竞争与冒险</title>
    <link href="http://jiahaohong.github.io/2020/05/29/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%86%92%E9%99%A9/"/>
    <id>http://jiahaohong.github.io/2020/05/29/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%86%92%E9%99%A9/</id>
    <published>2020-05-29T08:35:53.000Z</published>
    <updated>2020-09-29T08:55:36.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、竞争与冒险的定义"><a href="#一、竞争与冒险的定义" class="headerlink" title="一、竞争与冒险的定义"></a>一、竞争与冒险的定义</h3><p>当一个逻辑门的两个输入变量在同一时刻发生翻转，而变化的时间有差异的现象，称为竞争。<br>由竞争产生输出干扰脉冲的现象称为冒险。</p><h3 id="二、竞争与冒险的判别"><a href="#二、竞争与冒险的判别" class="headerlink" title="二、竞争与冒险的判别"></a>二、竞争与冒险的判别</h3><p>已知一个逻辑表达式，如何判别由该逻辑表达式设计的电路会不会产生竞争与冒险？<br>首先我们需要找到在该表达式中同时出现有原变量和反变量的输入变量，然后我们将所有其他变量选择合适的值，看逻辑表达式是否能成为该输入变量的原变量和反变量的组合，若是那么就会有竞争与冒险现象。</p><h3 id="三、如何消除竞争与冒险现象"><a href="#三、如何消除竞争与冒险现象" class="headerlink" title="三、如何消除竞争与冒险现象"></a>三、如何消除竞争与冒险现象</h3><ol><li>发现并消去互补相乘项<br>如果互补项没有直接的相乘，尝试拆括号将互补项乘到一起消去。</li><li>增加乘积项避免互补项相加<br>从原表达式中增加一些不改变结果的乘积项，使得原来满足互补项相加的条件作用下，多出一些其他表达式，避免互补项相加。   </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、竞争与冒险的定义&quot;&gt;&lt;a href=&quot;#一、竞争与冒险的定义&quot; class=&quot;headerlink&quot; title=&quot;一、竞争与冒险的定义&quot;&gt;&lt;/a&gt;一、竞争与冒险的定义&lt;/h3&gt;&lt;p&gt;当一个逻辑门的两个输入变量在同一时刻发生翻转，而变化的时间有差异的现象，称为
      
    
    </summary>
    
    
      <category term="数电学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%95%B0%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数字电路" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:搭建网络步骤</title>
    <link href="http://jiahaohong.github.io/2020/05/20/Tensorflow-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E6%AD%A5%E9%AA%A4/"/>
    <id>http://jiahaohong.github.io/2020/05/20/Tensorflow-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E6%AD%A5%E9%AA%A4/</id>
    <published>2020-05-20T01:50:21.000Z</published>
    <updated>2020-07-22T08:46:55.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、六步法"><a href="#一、六步法" class="headerlink" title="一、六步法"></a>一、六步法</h3><ol><li>import   </li><li>train,test  </li><li>model = tf.keras.models.Seque ntial  </li><li>model.compile<br>配置训练方法，比如优化器、损失函数   </li><li>model.fit  </li><li>model.summary</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、六步法&quot;&gt;&lt;a href=&quot;#一、六步法&quot; class=&quot;headerlink&quot; title=&quot;一、六步法&quot;&gt;&lt;/a&gt;一、六步法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;import   &lt;/li&gt;
&lt;li&gt;train,test  &lt;/li&gt;
&lt;li&gt;model = tf.
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
</feed>
