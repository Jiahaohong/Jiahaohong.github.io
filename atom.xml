<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darcy&#39;s Blog</title>
  
  <subtitle>Hope is something as precious as dimond.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong.github.io/"/>
  <updated>2020-10-06T11:51:09.607Z</updated>
  <id>http://jiahaohong.github.io/</id>
  
  <author>
    <name>Darcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matlab:同态滤波</title>
    <link href="http://jiahaohong.github.io/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/"/>
    <id>http://jiahaohong.github.io/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-06T02:51:54.000Z</published>
    <updated>2020-10-06T11:51:09.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是同态滤波"><a href="#一、什么是同态滤波" class="headerlink" title="一、什么是同态滤波"></a>一、什么是同态滤波</h3><p>根据成像原理，一幅图像可以分成两种成分的乘积叠加，一种成分是入射的光强<strong>L(x,y)</strong>，另一种是反射到人眼中的光强<strong>R(x,y)</strong>，二者是乘性叠加，所以一幅图像可以表示为<strong>F(x,y)=L(x,y)*R(x,Y)</strong>。<br>同态滤波通过将图像取对数，<strong>ln(F(x,y))=ln(L(x,y))+ln(R(x,y))</strong>，将乘性耦合的入射光和反射光成分解耦，变成加性耦合，这样就可以利用线性性分别对两种成分进行滤波处理。由于反射光强一般是高频成分，而入射光强是低频成分，所以用高通滤波器可以将入射光成分滤掉，得到更加清楚的细节。同态滤波是通过物理规律将图像进行分解操作，滤波器是在滤波过程中的一种频率选择方法，同态滤波并没有设计一种新的滤波器。</p><h3 id="二、同态滤波实现"><a href="#二、同态滤波实现" class="headerlink" title="二、同态滤波实现"></a>二、同态滤波实现</h3><h4 id="同态滤波结构"><a href="#同态滤波结构" class="headerlink" title="同态滤波结构"></a>同态滤波结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">homomophic filter</span><br><span class="line">|</span><br><span class="line">|-log_img &#x3D; log(img + 1)</span><br><span class="line">|</span><br><span class="line">|-ft_img &#x3D; fft(img)</span><br><span class="line">|</span><br><span class="line">|-h_img &#x3D; ft_img.*H</span><br><span class="line">|</span><br><span class="line">|-exp_img &#x3D; exp(h_img) - 1</span><br><span class="line">|</span><br><span class="line">|-res_img &#x3D; ifft(h_img)</span><br></pre></td></tr></table></figure><h4 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">homomorphic_filt</span><span class="params">( input_img, rL, rH, c, d )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%同态滤波参数设置</span></span><br><span class="line">    <span class="comment">%rL = 0.4; %低频放大系数</span></span><br><span class="line">    <span class="comment">%rH = 10; %高频放大系数</span></span><br><span class="line">    <span class="comment">%c = 0.2; %高斯变换常数系数</span></span><br><span class="line">    <span class="comment">%d = 4000; %高斯变换系数</span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    input_img = double(input_img);</span><br><span class="line"></span><br><span class="line">    log_img = <span class="built_in">log</span>(input_img+<span class="number">1</span>);</span><br><span class="line">    ft_img = fft2(log_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%构造高斯滤波器</span></span><br><span class="line">    H = <span class="built_in">zeros</span>(M,N);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            D = (<span class="built_in">i</span>.^<span class="number">2</span>+<span class="built_in">j</span>.^<span class="number">2</span>);</span><br><span class="line">            H(<span class="built_in">i</span>,<span class="built_in">j</span>) = (rH-rL).*(<span class="number">1</span>-<span class="built_in">exp</span>(-c.*(D./(d^<span class="number">2</span>))))+rL;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    filted_img = H.*ft_img;</span><br><span class="line">    ift_img = ifft2(filted_img);</span><br><span class="line">    exp_img = <span class="built_in">exp</span>(ift_img)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    output_img = uint8(<span class="built_in">abs</span>(exp_img));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="有关中心化的处理"><a href="#有关中心化的处理" class="headerlink" title="有关中心化的处理"></a>有关中心化的处理</h4><p>参考了许多CSDN网站上的博客，发现他们都有将高斯滤波器中心化的操作，但是我个人认为这是不必要的操作，仅仅是坐标轴的变换而已。<br>我们来分类讨论一下，如果图像的傅里叶变换没有进行平移操作（fftshift），那么结果的左上角是低频成分，沿着x、y轴坐标增加的方向，频率逐渐增高，那么高通滤波器应该如何设置呢？以左上角为原点，到远点的距离为变量即可构造高斯高通滤波器。但是如果以图片中心点为原点，这时候H需要进行平移，将它和图像的傅里叶变换结果的高低频区域对齐。</p><h3 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h3><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/1.jpg">  <center>原图</center><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/0_2-2-0_2-1000.jpg">  <center>变换后的图</center><h3 id="四、失误与总结"><a href="#四、失误与总结" class="headerlink" title="四、失误与总结"></a>四、失误与总结</h3><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><p>这次的实验参数较多，调参的过程比设计算法的过程还要长，但是通过调参也能够理解各个参数的对图像的影响。比如d和rH的作用又互相抵消的效果，c参数会让图片整体明暗发生变化。至于为什么会出现这些现象，还是要从原理入手，这里还需研究。后续如果有可能的话，可以制作四个参数在一定范围内变化的图像效果变化动图，更加直观的显示四个参数的影响。</p><img src="/2020/10/06/Matlab-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/sign.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是同态滤波&quot;&gt;&lt;a href=&quot;#一、什么是同态滤波&quot; class=&quot;headerlink&quot; title=&quot;一、什么是同态滤波&quot;&gt;&lt;/a&gt;一、什么是同态滤波&lt;/h3&gt;&lt;p&gt;根据成像原理，一幅图像可以分成两种成分的乘积叠加，一种成分是入射的光强&lt;strong
      
    
    </summary>
    
    
      <category term="Matlab图像处理" scheme="http://Jiahaohong.github.io/categories/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:直方图均衡化</title>
    <link href="http://jiahaohong.github.io/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/"/>
    <id>http://jiahaohong.github.io/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</id>
    <published>2020-10-05T10:37:57.000Z</published>
    <updated>2020-10-06T11:51:14.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是直方图均衡化"><a href="#一、什么是直方图均衡化" class="headerlink" title="一、什么是直方图均衡化"></a>一、什么是直方图均衡化</h3><h4 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h4><p>原图的灰度直方图形象的反映了图片整体的明暗程度，横轴为像素灰度级，范围是0到255，纵轴是各个灰度的像素个数占总像素的比。当图片偏亮时，灰度级高的像素占比大，当图片偏暗时，灰度级低的像素占比大。  </p><h4 id="均衡化"><a href="#均衡化" class="headerlink" title="均衡化"></a>均衡化</h4><p>均衡化的意义是将所有灰度级的像素出现概率调整成一致的，但是这只在连续情况下有效，一般来说，离散的图像灰度级均衡化后各级的概率是不一样的。</p><h4 id="为什么要均衡化"><a href="#为什么要均衡化" class="headerlink" title="为什么要均衡化"></a>为什么要均衡化</h4><p>根据香农信息的定义，图像在灰度均匀出现时所携带的信息量最大，因此，过亮或过暗的图片携带的信息都很少，不利于人眼等的分辨，直方图均衡化可以尽可能的增加图像的信息量。</p><h3 id="二、直方图均衡化的实现"><a href="#二、直方图均衡化的实现" class="headerlink" title="二、直方图均衡化的实现"></a>二、直方图均衡化的实现</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-histogram_equalize %直方图均衡化</span><br><span class="line">| |</span><br><span class="line">| |-count_gray %统计灰度直方图</span><br><span class="line">| |-acc_gray   %计算累计直方图</span><br></pre></td></tr></table></figure><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ output_img ]</span> = <span class="title">histogram_equalize</span><span class="params">( input_img )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    output_img = <span class="built_in">zeros</span>(M,N); <span class="comment">%初始化输出图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%统计原图像灰度直方图</span></span><br><span class="line">    gray_histogram = count_gray(input_img);</span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">25565</span>);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    bar(gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'orig gray histogram'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%计算累计直方图</span></span><br><span class="line">    acc_gray_histogram = acc_gray(gray_histogram);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    bar(acc_gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'acc gray histogram'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%灰度转换</span></span><br><span class="line">    gray_trans = acc_gray_histogram*<span class="number">255</span>;</span><br><span class="line">    gray_trans = uint8(<span class="built_in">round</span>(gray_trans));</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    bar(gray_trans);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'gray trans'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            gray_level = input_img(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">            output_img(<span class="built_in">i</span>,<span class="built_in">j</span>) = gray_trans(gray_level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    output_img = uint8(output_img);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%统计转换后图像的灰度直方图</span></span><br><span class="line">    new_gray_histogram = count_gray(output_img);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    bar(new_gray_histogram);</span><br><span class="line">    xlim([<span class="number">0</span> <span class="number">255</span>]);</span><br><span class="line">    title(<span class="string">'new gray histogram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="统计灰度直方图"><a href="#统计灰度直方图" class="headerlink" title="统计灰度直方图"></a>统计灰度直方图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ gray_histogram ]</span> = <span class="title">count_gray</span><span class="params">( input_img )</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%建立和灰度级登场的数组，数组下标就是灰度级，数组内容为该灰度级的像素出现概率</span></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(input_img);</span><br><span class="line">    gray_histogram = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:N</span><br><span class="line">            gray_level = input_img(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">            gray_histogram(gray_level+<span class="number">1</span>) = gray_histogram(gray_level+<span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    gray_histogram = gray_histogram / M / N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="计算累计直方图"><a href="#计算累计直方图" class="headerlink" title="计算累计直方图"></a>计算累计直方图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ acc_gray_histogram ]</span> = <span class="title">acc_gray</span><span class="params">( gray_histogram )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(gray_histogram);</span><br><span class="line">    acc_gray_histogram = <span class="built_in">zeros</span>(M,N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%将每个灰度级加上前一个灰度级和本灰度级的概率</span></span><br><span class="line">    acc_gray_histogram(<span class="number">1</span>) = gray_histogram(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:N</span><br><span class="line">        acc_gray_histogram(<span class="built_in">i</span>) = gray_histogram(<span class="built_in">i</span>)+acc_gray_histogram(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h3><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/hw_all.jpg" width="800"><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/hw_all_data.jpg" width="800"><center>图1</center><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/dark_all.jpg" width="800"><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/dark_all_data.jpg" width="800"><center>图2</center><h3 id="四、失误与总结"><a href="#四、失误与总结" class="headerlink" title="四、失误与总结"></a>四、失误与总结</h3><h4 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h4><p>由于对matlab的数组下表还是不太熟悉，统计灰度图那里一直报错索引问题，后来查出是图像中有灰度为0的像素，但是数组下标没有0，而是从1开始，所以统计灰度的时候图片像素大小都加了1，转换的时候也是。</p><h4 id="figure覆盖"><a href="#figure覆盖" class="headerlink" title="figure覆盖"></a>figure覆盖</h4><p>由于以前显示的时候总会覆盖之前的figure，所以我索性把函数里的figure值设得非常大，就不会出现覆盖的问题，后来查到代码<strong>hold on</strong>也有同样的效果。</p><h4 id="bar柱状图"><a href="#bar柱状图" class="headerlink" title="bar柱状图"></a>bar柱状图</h4><p>柱状图的命名，限制范围和普通plot图一样，输入可以是x数组和有数组，x、y一一对应，也可以是一个一维数组，这样数组下标作为x轴。  </p><img src="/2020/10/05/Matlab-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/sign.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是直方图均衡化&quot;&gt;&lt;a href=&quot;#一、什么是直方图均衡化&quot; class=&quot;headerlink&quot; title=&quot;一、什么是直方图均衡化&quot;&gt;&lt;/a&gt;一、什么是直方图均衡化&lt;/h3&gt;&lt;h4 id=&quot;灰度直方图&quot;&gt;&lt;a href=&quot;#灰度直方图&quot; class
      
    
    </summary>
    
    
      <category term="Matlab图像处理" scheme="http://Jiahaohong.github.io/categories/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux:Ubuntu18.04小白安装教程</title>
    <link href="http://jiahaohong.github.io/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://jiahaohong.github.io/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2020-09-25T23:38:59.000Z</published>
    <updated>2020-09-29T09:00:28.683Z</updated>
    
    <content type="html"><![CDATA[<p><em>本教程原系统Windows10</em><br><em>安装Ubuntu18.04.3版本</em><br><em>电脑联想Y7000</em><br><em>手机华为P10</em> </p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p><a href="https://releases.ubuntu.com/18.04.5/ubuntu-18.04.5-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu18.05下载</a>  </p></li><li><p>8G U盘一个</p></li><li><p>能上网的手机一个</p></li></ul><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p><em><strong>注意之后提到的按键以平台为准，可能和你的电脑或手机不一样</strong></em></p><h4 id="1-制作启动盘"><a href="#1-制作启动盘" class="headerlink" title="1. 制作启动盘"></a>1. 制作启动盘</h4><p>WIN10下用文件资源管理器打开上面下载的ISO文件，把里面的文件全部复制粘贴到U盘里。<strong>接下来的操作不要拔下U盘</strong>。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ISO.jpg"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ISO2.jpg"></p><h4 id="2-重启电脑进入BIOS"><a href="#2-重启电脑进入BIOS" class="headerlink" title="2. 重启电脑进入BIOS"></a>2. 重启电脑进入BIOS</h4><p>重启电脑，在<strong>电脑重新开启之前</strong>按住F2键不放，然后进入BIOS界面。<strong>注意每个厂家生产的电脑进入BIOS的键不一样</strong>，我的联想Y7000是F2键，其他电脑的快捷键可以去网上查。  </p><h4 id="3-修改安全启动项SecurityBoot"><a href="#3-修改安全启动项SecurityBoot" class="headerlink" title="3. 修改安全启动项SecurityBoot"></a>3. 修改安全启动项SecurityBoot</h4><p>左右键切换页面到Security界面，上下键选择到SecurityBoot项，按下F5键将其改为Disable。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/SecurityBoot.jpg">  </p><h4 id="4-将启动盘（U盘）启动优先级调到第一"><a href="#4-将启动盘（U盘）启动优先级调到第一" class="headerlink" title="4. 将启动盘（U盘）启动优先级调到第一"></a>4. 将启动盘（U盘）启动优先级调到第一</h4><p>左右键切换页面到Boot界面，上下键选择到U盘启动项，一般来说后面<strong>括号</strong>里显示的是你<strong>U盘的型号</strong>那个就是启动盘，按F6键将其上移到第一个。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Boot.jpg"></p><h4 id="5-保存修改并重启"><a href="#5-保存修改并重启" class="headerlink" title="5. 保存修改并重启"></a>5. 保存修改并重启</h4><p>按F10键保存BIOS修改，弹出确认框，左右键选择Yes后回车，系统自动关机，重新打开电脑即可进入U盘里的启动项。</p><h4 id="6-选择安装Ubuntu项"><a href="#6-选择安装Ubuntu项" class="headerlink" title="6. 选择安装Ubuntu项"></a>6. 选择安装Ubuntu项</h4><p>进入U盘里的启动项后，选择Install Ubuntu选项安装Ubuntu系统。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Install.jpg"></p><h4 id="7-连接手机"><a href="#7-连接手机" class="headerlink" title="7. 连接手机"></a>7. <strong>连接手机</strong></h4><p>注意，这是很重要的一步，之后的自动更新需要用到手机的网络。用USB线连接手机和电脑，这时手机上会显示几个选项，选择传输文件（点了之后弹窗就没了）。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone1.jpg" width="200" height="200"><br>找到设置-&gt;移动网络-&gt;移动网络共享，打开USB共享网络。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone4.jpg" width="200" height="400"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone2.jpg" width="200" height="400"><br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Phone3.jpg" width="200" height="400"><br>这时候，Ubuntu安装界面右上角出现一个图标就表示电脑已经连上网了。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Wireless.png"></p><p>现在万事俱备，进入Ubuntu安装程序后，跟着他的步骤一步一步来。</p><h4 id="8-键盘布局"><a href="#8-键盘布局" class="headerlink" title="8. 键盘布局"></a>8. 键盘布局</h4><p>键盘布局选择汉语。</p><h4 id="9-连接wifi无线网络"><a href="#9-连接wifi无线网络" class="headerlink" title="9. 连接wifi无线网络"></a>9. 连接wifi无线网络</h4><p>选择不想连接，因为手机已经共享了。  </p><h4 id="10-更新和其他软件"><a href="#10-更新和其他软件" class="headerlink" title="10. 更新和其他软件"></a>10. 更新和其他软件</h4><p>选择最小安装，并且安装第三方软件。安装第三方软件需要之前手机的网络，大概两三百MB。<br><img src="/2020/09/26/Linux-Ubuntu18-04%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/update.jpg"></p><h4 id="11-安装类型"><a href="#11-安装类型" class="headerlink" title="11. 安装类型"></a>11. 安装类型</h4><p>选择和Win10Boot共存的那个选项。</p><h4 id="12-等待安装完成！"><a href="#12-等待安装完成！" class="headerlink" title="12. 等待安装完成！"></a>12. 等待安装完成！</h4><p>这个安装方式十分方便，安装完成后可以直接用，不需要自己再配置什么驱动，独立显卡驱动除外，之后可能会有一篇博客讲解Nvidia独显驱动安装。总结：见文章内容导航！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本教程原系统Windows10&lt;/em&gt;&lt;br&gt;&lt;em&gt;安装Ubuntu18.04.3版本&lt;/em&gt;&lt;br&gt;&lt;em&gt;电脑联想Y7000&lt;/em&gt;&lt;br&gt;&lt;em&gt;手机华为P10&lt;/em&gt; &lt;/p&gt;
&lt;h3 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class
      
    
    </summary>
    
    
      <category term="Linux学习笔记" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://Jiahaohong.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Matlab:快速傅里叶变换实现</title>
    <link href="http://jiahaohong.github.io/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jiahaohong.github.io/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-19T19:13:55.000Z</published>
    <updated>2020-10-06T03:33:41.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是傅里叶变换"><a href="#一、什么是傅里叶变换" class="headerlink" title="一、什么是傅里叶变换"></a>一、什么是傅里叶变换</h3><p>简单来说，傅里叶变换将一个函数分解为一组三角函数的和，通过将这个函数分别和这组三角函数中的每一个进行内积运算，可以求得每个三角函数前面的系数。  </p><h4 id="正交函数集"><a href="#正交函数集" class="headerlink" title="正交函数集"></a>正交函数集</h4><p>正交函数集满足如下两条性质：  </p><ol><li>正交函数集中的任意两个不相同函数的内积为0；  </li><li>如果某函数集中存在一个函数可以由函数集中除它以外的函数表示，则这个函数集不是正交函数集。  </li></ol><p>用类比的角度看，这个定义和线性代数中的基向量组的定义一致。说明正交函数集其实相当于函数空间中的一组基向量，函数空间中的一个函数对应向量空间中的一个向量，任何向量可以由基向量表示，同样的，任何函数可以由正交函数集表示。基向量可以写成矩阵的形式，同理，正交函数集也可以写成向量的形式。如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  这是一个1维向量，当前乘一个函数时就可以利用矩阵的乘法将函数分解到这个正交函数集上。  <center>[f(x)] * [1, sin(wx), cos(wx), ..., sin(nwx), cos(nwx), ...] =</center>  <center>[a0, b1*sin(wx), a1*cos(wx), ..., bn*sin(nwx), an*cos(nwx), ...]</center>  注意这些系数通过原函数f(x)和基函数内积等运算得到的。  <h4 id="内积运算"><a href="#内积运算" class="headerlink" title="内积运算"></a>内积运算</h4><p>内积定义为向量a在向量b上的投影向量，当内积运算后的结果除以向量b的模长，就可以计算出向量a在向量b上投影占向量b的比例，这个比例就是基函数前面的系数。内积是反映两个向量相似度的重要指标，当两个向量完全相等时，它们的内积取得最大值。因此正交函数集的系数的含义，可以理解为原函数和基函数的相似度，相似度越大，这个基函数的系数越大。</p><p>因此，总体上来看，正交函数集构成了一个无穷维数的函数空间，这个空间里的任何函数都可以由这些基函数的加权求和表示，权重就是原函数和积函数的内积，及将原函数投影到这些正交函数上。当然可以用欧拉公式将这些三角基函数合并指数基函数，只不过这些基函数建立在复数域内了，后面的快速傅里叶实现也采用复数域内的正交函数集。  </p><h3 id="二、离散傅里叶变换"><a href="#二、离散傅里叶变换" class="headerlink" title="二、离散傅里叶变换"></a>二、离散傅里叶变换</h3><p>第一部分中讲到傅里叶变换是连续函数空间里的，如果处理的函数是一个离散的函数，那么就要用到离散傅里叶变换。离散傅里叶变换与来连续傅里叶变换的最大区别是求系数时的积分运算变成了求和运算。将正交函数集的向量形式抄写如下：  </p><center>[1, sin(wx), cos(wx), sin(2wx), cos(2wx), ..., sin(nwx), cos(nwx), ...]</center>  注意，这里的每一列都是一个连续函数，如果用离散的x坐标将其离散化，就可以获得离散傅里叶变换的正交函数集矩阵，如下：<div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/DMat.jpg" width="500" height="280"></div><p>这是一个二维矩阵，每一列代表一个正交函数，每一行坐标代表一个离散坐标x。将离散函数写成向量的形式后就可以用矩阵的乘法求出变换后的函数。这时有人会注意到，这个离散的矩阵两个维度都是无穷的，如果离散信号不一定是无穷的，那怎么运算呢？我们分别讨论一下：  </p><ol><li>变换矩阵的行数<br>如果要满足矩阵乘法定义，那么变换矩阵的行的个数必须和输入信号的变量取值范围相同，及与x的取值范围一致。如果输入信号的取值范围是无穷的，那么变换矩阵的行也有无数个。</li><li>变换矩阵的列数<br>由于变换矩阵的列数没有严格的定义，可多可少，但是由于每一列代表一种基函数，基函数的个数决定了表达的误差，一般来说和输入变量的x取值范围相同即可。</li></ol><h3 id="三、一维快速傅里叶变换的原理"><a href="#三、一维快速傅里叶变换的原理" class="headerlink" title="三、一维快速傅里叶变换的原理"></a>三、一维快速傅里叶变换的原理</h3><p>快速傅里叶变换有许多种，这里介绍的快速傅里叶变换通过将冗余的指数运算记录下来，以此减少乘法次数，加快运算速度。一维离散傅里叶公式如下：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1D.jpg" width="290" height="55"></div>  能否找到冗余计算？看样子很难，这里直接给出简化算法的核心公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo.jpg" width="280" height="50"></div>  这个公式其实很简单，本质就是一个约分，但是这个约分给我们提供了分离傅里叶变换的思路——奇偶分离。当一维傅里叶变换的输入信号的变量取值范围是2的整数倍，那么一维傅里叶变换的求和可以分为奇数部分求和、偶数部分求和，如下公式所示：<div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo2.jpg" width="500" height="200"></div>  看出来了吗？这里奇数部分和偶数部分有相同的分量，取值范围都是从0到M-1，你能看出来它也是傅里叶变换公式吗？下面这个公式将更加清晰：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo3.jpg" width="450" height="100"></div>    其中g(x)部分是原函数中自变量x取偶数时组成的新函数，h(x)是原函数自变量取奇数时组成的函数，将他们看成新的原函数，那么奇数部分和偶数部分就都是新的一维离散傅里叶变换了。这说明，原函数自变量取值范围是偶数时，原函数的傅里叶变换可以由自变量是偶数部分的傅里叶变换和自变量是奇数部分的傅里叶变换组合而成，并且这两部分互不影响。这是一个重要的结论，为后面的递归提供依据。为了方便书写，我们将偶数部分的傅里叶变换记作F<sub>even</sub>(u)，将奇数部分的傅里叶变换记作F<sub>odd</sub>(u)，那么一维傅里叶变换可以写成如下公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo4.jpg" width="290" height="55"></div>  必须要注意的是，上述公式的奇数部分和偶数部分都是N/2个，那么根据一般变换后自变量取值范围和原函数相同，可以知道u的取值范围从原来的N变成了N/2，那么后面一半怎么补全呢？我们再来看两个核心公式：  <div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT1DCoreAlgo5.jpg" width="200" height="110"></div>   将这两个公式带入F(u+M)，就可以算出后半部分其表达式。<h3 id="四、二维傅里叶变换的性质"><a href="#四、二维傅里叶变换的性质" class="headerlink" title="四、二维傅里叶变换的性质"></a>四、二维傅里叶变换的性质</h3><p>第三部分讲到一维离散傅里叶快速变换的基本原理，但对于二维快速傅里叶变换这还不够，我们需要探讨一下二维傅里叶变换的基本性质，才能将一维的变换应用到二维的求解中。在讨论二维傅里叶变换的性质之前，我们给出其定义公式：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2D.png" width="290" height="55"></div>   <h4 id="可分离性"><a href="#可分离性" class="headerlink" title="可分离性"></a>可分离性</h4><p>根据二维傅里叶变换的公式，可以比较轻松地看出，中括号里的计算是不涉及变量x的，换句话说，中括号里的计算是需要事先给定x的值，然后再计算，x在这里相当于一个常数，因此可以将中括号里面和外面的计算分离。这样，一个二维的傅里叶变换就变成了两个一维傅里叶变换：  </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2DCoreAlgo.jpg" width="420" height="95"></div>  <h4 id="平移性"><a href="#平移性" class="headerlink" title="平移性"></a>平移性</h4><p>二维傅里叶变换的平移性质和一维傅里叶变换的平移性质一脉相承，只不过一维中讲的是时域的平移，二维中讲的是空域的平移。这个性质在之后对图像的二维傅里叶变换中将要用到。    </p><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/FT2DCoreAlgo2.jpg" width="400" height="160"></div>  <h3 id="五、二维快速傅里叶变换的实现"><a href="#五、二维快速傅里叶变换的实现" class="headerlink" title="五、二维快速傅里叶变换的实现"></a>五、二维快速傅里叶变换的实现</h3><p>原理和性质都讲完了，接下来讲讲如何实现二维快速傅里叶变换。<br><em>本次使用软件MATLAB R2017a</em></p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">|</span><br><span class="line">|-image input</span><br><span class="line">|</span><br><span class="line">|-myft3</span><br><span class="line">| |</span><br><span class="line">| |-myfft</span><br><span class="line">| |(recursion)</span><br><span class="line">|</span><br><span class="line">|-shift myft3</span><br><span class="line">|</span><br><span class="line">|-ifft2</span><br></pre></td></tr></table></figure><h4 id="图像输入"><a href="#图像输入" class="headerlink" title="图像输入"></a>图像输入</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origImg = imread(<span class="string">'2.jpg'</span>);</span><br><span class="line">grayImg = rgb2gray(origImg); <span class="comment">%将图像转变成灰度图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">imshow(grayImg);</span><br></pre></td></tr></table></figure><h4 id="二维快速傅里叶变换"><a href="#二维快速傅里叶变换" class="headerlink" title="二维快速傅里叶变换"></a>二维快速傅里叶变换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ftImg = myft3(grayImg);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">imshow(<span class="built_in">abs</span>(<span class="built_in">log</span>(ftImg)+<span class="number">1</span>),[]);</span><br></pre></td></tr></table></figure><p>由于傅里叶变换的结果是一个<strong>complex double</strong>类型的矩阵，直接使用imshow函数的化将会造成无法正确输出的情况，所以需要对傅里叶变换后的矩阵进行<strong>log(x)+1</strong>的灰度变换，将矩阵的取值范围限制在合理范围，并且取模长使第二个参数[]可以自动调整输出灰度范围。<br>接下来详细介绍一下快速傅里叶变换的具体实现。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ outputMat ]</span> = <span class="title">myft3</span><span class="params">( inputMat )</span></span></span><br><span class="line"></span><br><span class="line">    [M0,N0] = <span class="built_in">size</span>(inputMat); <span class="comment">%获得输入图像的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%找到最接近输入图像大小（并且大于图像大小）的2^n，并将图片padding补零</span></span><br><span class="line">    M1 = find_upper_2n(M0);</span><br><span class="line">    N1 = find_upper_2n(N0);</span><br><span class="line">    outputMat = double(<span class="built_in">zeros</span>(M1,N1)); </span><br><span class="line">    tempMat = double(<span class="built_in">zeros</span>(M1,N1));</span><br><span class="line">    inputMat(M1,N1) = <span class="number">0</span>;</span><br><span class="line">    inputMat = double(inputMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%行列分开计算</span></span><br><span class="line">    <span class="keyword">for</span> x = <span class="number">1</span>:N1</span><br><span class="line">        tempMat(:,x) = myfft( inputMat(:,x).' ).'; <span class="comment">%输入是行向量，所以列向量转置再转置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:M1</span><br><span class="line">        outputMat(y,:) = myfft( tempMat(y,:) );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上一段是进入快速傅里叶变换的铺垫步骤，利用padding补零，使得后续一维傅里叶快速变换可以最大限度地递归进行，最大限度地减少重复计算。而padding补上的零值在傅里叶变换的求和中是没有起作用的，因此不影响原图片的傅里叶变换的值。  </p><h4 id="一维快速傅里叶变换"><a href="#一维快速傅里叶变换" class="headerlink" title="一维快速傅里叶变换"></a>一维快速傅里叶变换</h4><p>由第三部分可知，当输入函数的自变量取值范围是偶数时，输入函数的傅里叶变换可以由偶数部分和奇数部分各自的傅里叶变换通过简单组合得到，因此，我们采取递归的方式不断拆分输入函数，直到输入函数的自变量只能取1个值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ outputMat ]</span> = <span class="title">myfft</span><span class="params">( inputMat )</span></span></span><br><span class="line"></span><br><span class="line">    [M,N] = <span class="built_in">size</span>(inputMat);  <span class="comment">%获得输入一维矩阵（向量）的列数N，行数M没有用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(N,<span class="number">2</span>)==<span class="number">0</span>  <span class="comment">%当输入向量的长度可以拆分时进行递归</span></span><br><span class="line">        oddMat = myfft( inputMat(<span class="number">1</span>:<span class="number">2</span>:<span class="keyword">end</span>) );</span><br><span class="line">        evenMat = myfft( inputMat(<span class="number">2</span>:<span class="number">2</span>:<span class="keyword">end</span>) );</span><br><span class="line">        <span class="keyword">for</span> u=<span class="number">1</span>:N/<span class="number">2</span></span><br><span class="line">            evenMat(u) = evenMat(u)*<span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(u<span class="number">-1</span>)/N);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        foreMat = (oddMat + evenMat);</span><br><span class="line">        backMat = (oddMat - evenMat);</span><br><span class="line">        outputMat = <span class="built_in">cat</span>(<span class="number">2</span>,foreMat,backMat);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">%当输入向量长度为1时停止递归，返回单点傅里叶变换的值，及自身</span></span><br><span class="line">        outputMat = inputMat;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实不需要完全分到1个点再进行傅里叶变换，可以适当提前结束递归。</p><h4 id="二维快速傅里叶反变换"><a href="#二维快速傅里叶反变换" class="headerlink" title="二维快速傅里叶反变换"></a>二维快速傅里叶反变换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iftImg = <span class="built_in">abs</span>(ifft2(ftImg));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">imshow(iftImg,[]);</span><br></pre></td></tr></table></figure><p>这里反变换是利用Matlab提供的函数<strong>ifft2</strong>进行验证，如果正确的话，结果应该是原图片加上黑色边框。这里的验证完全可以用自己写的函数进行，将傅里叶变换后的矩阵进行共轭，再次进行傅里叶变换就可以得到原图像。如下代码所示：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftImg2 = <span class="built_in">conj</span>(ftImg);</span><br><span class="line">iftImg = <span class="built_in">abs</span>(myft3(ftImg2));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">imshow(iftImg,[]);</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/orig.jpg">  原图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/ft.jpg">  原傅里叶变换图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/shiftFt.jpg">  平移后的傅里叶变换图像</div><div align="center"><img src="/2020/09/20/Matlab-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E7%8E%B0/check.jpg">  iff2反变换结果图像</div><h3 id="六、失误与总结"><a href="#六、失误与总结" class="headerlink" title="六、失误与总结"></a>六、失误与总结</h3><h4 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标"></a>数组下标</h4><p>习惯了0作为初始下标，但是matlab的下标从1开始，有些地方需要转换。</p><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>matlab力有两种转置，<strong>.’</strong>是普通转置，<strong>‘</strong>是共轭转置，要分清楚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是傅里叶变换&quot;&gt;&lt;a href=&quot;#一、什么是傅里叶变换&quot; class=&quot;headerlink&quot; title=&quot;一、什么是傅里叶变换&quot;&gt;&lt;/a&gt;一、什么是傅里叶变换&lt;/h3&gt;&lt;p&gt;简单来说，傅里叶变换将一个函数分解为一组三角函数的和，通过将这个函数分别和这
      
    
    </summary>
    
    
      <category term="Matlab图像处理" scheme="http://Jiahaohong.github.io/categories/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Matlab" scheme="http://Jiahaohong.github.io/tags/Matlab/"/>
    
      <category term="图像处理" scheme="http://Jiahaohong.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Keil5安装芯片包</title>
    <link href="http://jiahaohong.github.io/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/"/>
    <id>http://jiahaohong.github.io/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/</id>
    <published>2020-07-29T06:03:03.000Z</published>
    <updated>2020-07-29T06:54:41.016Z</updated>
    
    <content type="html"><![CDATA[<p>如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：</p><ul><li><p>打开下载芯片包的界面</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/1.png"> </li><li><p>在左侧双击你需要的芯片</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/2.png"></li><li><p>点击右侧你需要的芯片包的Install按钮</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/3.png"></li><li><p>单击选中下方报错的行</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/4.png"></li><li><p>复制后粘贴到浏览器网址栏</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/5.png"></li><li><p>去掉头尾留下地址，按回车即可下载</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/6.png">  <img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/7.png"></li><li><p>下载完毕后回到下载芯片包界面，点击file里的import选项</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/8.png"></li><li><p>在弹出窗口里找到之前下载的文件导入</p><img src="/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E5%8C%85/9.png"></li></ul><p>完成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在使用Keil5安装芯片包时显示找不到包的错误，可以通过手动下载包后导入的方法解决。操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开下载芯片包的界面&lt;/p&gt;
&lt;img src=&quot;/2020/07/29/Keil5%E5%AE%89%E8%A3%85%E8%8A%AF%E
      
    
    </summary>
    
    
    
      <category term="Keil5" scheme="http://Jiahaohong.github.io/tags/Keil5/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:制作数据集</title>
    <link href="http://jiahaohong.github.io/2020/07/22/Tensrflow-%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://jiahaohong.github.io/2020/07/22/Tensrflow-%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-07-22T13:45:51.000Z</published>
    <updated>2020-07-22T13:48:29.221Z</updated>
    
    <content type="html"><![CDATA[<p>tf.data.Dataset.from_tensor_slice(tensor)<br>将输入tensor按照第一个维度拆分</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tf.data.Dataset.from_tensor_slice(tensor)&lt;br&gt;将输入tensor按照第一个维度拆分&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令（重制版）</title>
    <link href="http://jiahaohong.github.io/2020/07/18/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://jiahaohong.github.io/2020/07/18/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-07-18T13:55:57.000Z</published>
    <updated>2020-09-25T23:30:18.137Z</updated>
    
    <content type="html"><![CDATA[<p><em>系统使用Ubuntu18.04，无图形界面，本地系统为Windows10</em></p><h3 id="一、Linux系统指令"><a href="#一、Linux系统指令" class="headerlink" title="一、Linux系统指令"></a>一、Linux系统指令</h3><ul><li>进入指定文件夹<br>cd /root/mygit/project1</li><li>进入上层文件夹<br>cd ..</li><li>进入根目录文件夹(root)<br>cd ~</li><li>显示当前文件夹路径<br>pwd</li><li>显示当前文件夹里的文件和文件夹<br>ls -l</li><li>在当前文件夹下创建文件夹<br>mkdir project2</li><li>在当前文件夹下创建文件<br>touch readme.txt<br>touch gitCommand.md<br>touch go.sh</li><li>删除文件或文件夹<br>sudo rm -r readme.txt<br>sudo rm -r project2</li><li>重命名文件或文件夹<br>mv readme.txt README.txt  </li><li>将上述指令结合起来使用，你就可以非常方便的解决一些文件操作的小问题了。比如进入某个文件夹，新建一个子文件夹用来存放自己的markdown笔记，就可以在命令窗口里输入如下命令：<br>cd /usr/note &amp;&amp; mkdir LinuxNotes &amp;&amp; touch day1.md</li></ul><h3 id="二、常用软件指令"><a href="#二、常用软件指令" class="headerlink" title="二、常用软件指令"></a>二、常用软件指令</h3><ul><li>screen<ul><li>新建一个新窗口<br>screen -S name<br>注意S是大写</li><li>将当前窗口挂起（后台运行）<br>ctrl + A + D<br>注意这是快捷键，按后面的键时不要松开前面的键</li><li>显示当前已经开启的窗口<br>screen -ls<br>显示的时候会显示窗口ID和名字，以及是否挂起</li><li>进入挂起窗口<br>screen -r name<br>注意r是小写</li><li>关闭窗口<br>kill ID<br>注意ID可以用screen -ls指令查看</li></ul></li><li>zip  <ul><li>解压文件到当前目录<br>unzip file.zip</li><li>压缩文件<br>zip -r file_name.zip file.txt<br>注意是将file.txt文件压缩为file_name.zip文件，不要弄反了 </li></ul></li></ul><h3 id="三、上传下载文件"><a href="#三、上传下载文件" class="headerlink" title="三、上传下载文件"></a>三、上传下载文件</h3><ul><li>rz/sz  <ul><li>从服务器下载文件<br>sz file.zip</li><li>从本地上传文件<br>rz<br>注意本地需要相应软件，比如Xshell</li></ul></li><li>windows命令窗口上传文件  <ul><li>pscp C:/fold1/fold1_2/file.txt <a href="mailto:root@xx.xxx.xxx.xxx">root@xx.xxx.xxx.xxx</a>:/usr/folderA  </li></ul></li></ul><h3 id="四、anaconda使用指令"><a href="#四、anaconda使用指令" class="headerlink" title="四、anaconda使用指令"></a>四、anaconda使用指令</h3><ul><li>查看虚拟环境列表<br>conda info -e</li><li>创建虚拟环境<br>conda create -n env_name</li><li>进入虚拟环境<br>conda activate env_name</li><li>退出虚拟环境<br>conda deactivate</li><li>在当前虚拟环境下安装 包<br>conda install appname<br>conda install URL</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;系统使用Ubuntu18.04，无图形界面，本地系统为Windows10&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、Linux系统指令&quot;&gt;&lt;a href=&quot;#一、Linux系统指令&quot; class=&quot;headerlink&quot; title=&quot;一、Linux系统指令&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux学习笔记" scheme="http://Jiahaohong.github.io/categories/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://Jiahaohong.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="http://Jiahaohong.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深度学习：卷积神经网络</title>
    <link href="http://jiahaohong.github.io/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://jiahaohong.github.io/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-17T13:57:15.000Z</published>
    <updated>2020-09-25T23:29:00.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、卷积神经网络符号说明"><a href="#一、卷积神经网络符号说明" class="headerlink" title="一、卷积神经网络符号说明"></a>一、卷积神经网络符号说明</h3><p><em>这里将卷积层和池化层看作一层神经网络，但分开描述</em><br><em>这里手的图像可以是抽象的多维矩阵</em></p><ol><li><p>图像n  </p><ul><li>图像数量：m  </li><li>图像高度：n<sub>H</sub>  </li><li>图像宽度：n<sub>W</sub>  </li><li>图像信道：n<sub>C</sub></li></ul></li><li><p>过滤器Filter  </p><ul><li>形状：f<sub>H</sub><sup>[l]</sup> * f<sub>W</sub><sup>[l]</sup>，指一个过滤器的一层矩阵的高和宽，大多数的时候，f<sub>H</sub><sup>[l]</sup> =  f<sub>W</sub><sup>[l]</sup> = 3  </li><li>边沿padding：p<sup>[l]</sup>，用来将过滤器要过滤的图像填充成指定形状</li><li>步长step：s<sup>[l]</sup>，表示过滤器在输入图像上移动一次所经过的像素个数</li><li>信道channel：n<sub>C</sub><sup>[l-1]</sup>，注意，第l层的过滤器的信道数量和上一层的输出图像信道数量相同，这是卷积运算的前提条件  </li></ul></li><li><p>池化层Pooling  </p><ul><li>形状：f<sub>H</sub><sup>[l]</sup> * f<sub>W</sub><sup>[l]</sup></li><li>边沿padding：p<sup>[l]</sup>，用来将池化层要池化的图像填充成指定形状</li><li>步长step：s<sup>[l]</sup>，表示池在输入图像上移动一次所经过的像素个数</li><li>信道channel：n<sub>C</sub><sup>[l]</sup> = f<sub>m</sub>，注意，第l层的池的信道数量和这一层过滤器的个数相同。</li></ul></li><li><p>全连接FullConnection</p><ul><li>普通的神经网络连接层</li></ul></li></ol><h3 id="二、卷积神经网络的基本模块"><a href="#二、卷积神经网络的基本模块" class="headerlink" title="二、卷积神经网络的基本模块"></a>二、卷积神经网络的基本模块</h3><ol><li>卷积层<br>卷积操作是由过滤器和上一层的输出完成的。首先来看看卷积操作是如何完成的，然后再研究其中的数据维数等细节。  <ul><li>卷积操作<br>图像的形状为n<sub>H</sub> * n<sub>W</sub>，过滤器的形状为f<sub>H</sub> * f<sub>W</sub>，假设图像没有加边沿padding，过滤器的步长为1，那么将过滤器矩阵和图像矩阵左上角对齐，重叠的格子中的数据相乘，将得到的结果相加作为输出矩阵的第一个元素，然后将过滤器矩阵右移一个像素（一个步长），重复上述操作得到输出矩阵的第二个元素，以此类推，直到右移超出图像边界时，向下移动一个像素，再从最左边开始重复上述操作。</li><li>数据维数<br>由于过滤器所操作的图像可能有多层通道，那么过滤器的通道数和图像必须对应，相同通道的过滤器和图像矩阵进行卷积操作，得到的结果相加作为输出矩阵的一个通道。因此，过滤器有几个，输出矩阵的通道数就有几个。</li></ul></li><li>池化层<br>池化操作简单来说是将图片分为几个区域，从中挑选出符合要求的数据组成新的图像。池和过滤器的结构和定义相似，只不过池中矩阵的每一位上没有权重，只是用来区分图像区域。池化操作和卷积的操作流程相似，但不是将池中的数据加权求和，而是取最大值或平均值作为输出。</li><li>全连接层<br>全连接层时普通的DNN网络，通过将之前网络提取出来的特征展平，再连接，最后输出结果</li></ol><h3 id="三、卷积神经网络的前向传播和反向传播算法"><a href="#三、卷积神经网络的前向传播和反向传播算法" class="headerlink" title="三、卷积神经网络的前向传播和反向传播算法"></a>三、卷积神经网络的前向传播和反向传播算法</h3><p>。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、卷积神经网络符号说明&quot;&gt;&lt;a href=&quot;#一、卷积神经网络符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、卷积神经网络符号说明&quot;&gt;&lt;/a&gt;一、卷积神经网络符号说明&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这里将卷积层和池化层看作一层神经网络，但分开描述&lt;/
      
    
    </summary>
    
    
      <category term="深度学习学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://Jiahaohong.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Python:Numpy</title>
    <link href="http://jiahaohong.github.io/2020/07/11/Python-Numpy/"/>
    <id>http://jiahaohong.github.io/2020/07/11/Python-Numpy/</id>
    <published>2020-07-11T09:39:51.000Z</published>
    <updated>2020-07-19T11:56:49.614Z</updated>
    
    <content type="html"><![CDATA[<ul><li>np.zeros(shape, dtype=float)  </li><li>np.random.rand()<br>括号里为矩阵维数，获得数值在0~1之间的随机数矩阵</li><li>np.random.randn()<br>括号里为矩阵维数，获得数值为正态分布的随机数矩阵</li><li>np.sum(A,axis=None)<br>把axis对应的维度的数相加，变成0维</li><li>np.squeeze(X)<br>把X中只有1个元素的维度去掉</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;np.zeros(shape, dtype=float)  &lt;/li&gt;
&lt;li&gt;np.random.rand()&lt;br&gt;括号里为矩阵维数，获得数值在0~1之间的随机数矩阵&lt;/li&gt;
&lt;li&gt;np.random.randn()&lt;br&gt;括号里为矩阵维数，获得数值为正
      
    
    </summary>
    
    
    
      <category term="Python" scheme="http://Jiahaohong.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习:逻辑回归的符号和公式</title>
    <link href="http://jiahaohong.github.io/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <id>http://jiahaohong.github.io/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F/</id>
    <published>2020-07-07T01:48:36.000Z</published>
    <updated>2020-09-25T23:32:35.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、符号说明"><a href="#一、符号说明" class="headerlink" title="一、符号说明"></a>一、符号说明</h3><p>一个样本包含两个部分，特征x和标签y</p><ul><li>x<br>表示某一个样本的特征的集合，通常是一个列向量，其中每一个维度表示一个特征</li><li>x<sub>j</sub><br>表示第j个特征</li><li>x<sup>(i)</sup><br>表示第i个样本的特征数据，注意上标是小括号</li><li>x<sup>(i)</sup><sub>j</sub><br>表示第i个样本的第j个特征，注意上标是小括号</li><li>y<br>表示一个样本的真实标签，通常时一个列向量，其中每一个维度代表一个种类，如果该样本这一个维度为0，表示该样本不属于该种类；如果该样本的这一维度为1，表示该样本属于该种类</li><li>y<sup>(i)</sup><br>表示第i个样本的标签，注意上标是小括号  </li></ul><p>一层神经网络由三部分组成，第一部分是与上一层神经网络连接的权重矩阵，第二部分是权重矩阵的输出，第三部分是权重矩阵的输出经过该层神经元的激活函数后的输出结果</p><ul><li>n<sub>i</sub><br>表示第i层神经网络的神经元个数，通常输入层（第0层）写作n<sub>x</sub>，输出层（最后一层）写作n<sub>L</sub></li><li>W<sup>[i]</sup><br>表示连接第i-1层和第i层神经元的权重矩阵，矩阵形状为(n<sub>i</sub>,n<sub>i-1</sub>)，n<sub>i</sub>是第i层的神经元个数</li><li>Z<sup>[i]</sup><br>表示第i层神经元的输入</li><li>A<sup>[i]</sup><br>表示Z<sup>[i]</sup>经过第i层神经元的激活函数后的输出，之后要输入到下一层的权重矩阵W<sup>[i+1]</sup>里；特别的，输入的样本特征可以看作是A<sup>[0]</sup>  </li></ul><p>偏导数部分的符号是程序里的变量标识符，不是数学里的微分字符</p><ul><li>dW<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li><li>dZ<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li><li>dA<sup>[i]</sup><br>表示损失函数对第i层神经元输出的偏导数</li></ul><h3 id="二、公式"><a href="#二、公式" class="headerlink" title="二、公式"></a>二、公式</h3><ol><li>前向传播公式<br>(1) Z<sup>[i]</sup> = W<sup>[i]</sup> · A<sup>[i-1]</sup> + b<sup>[i]</sup><br>(2) A<sup>[i]</sup> = g<sup>[i]</sup>(Z<sup>[i]</sup>)</li><li>反向传播公式<br>(1) dW<sup>[i]</sup> = (1/m)·dZ<sup>[i]</sup>·A<sup>[i-1]T</sup><br>(2) db<sup>[i]</sup> = (1/m)·sum(dZ<sup>[i]</sup>)<br>(3) dZ<sup>[i-1]</sup> = W<sup>[i]T</sup>·dZ<sup>[i]</sup>*g<sup>[i-1]’</sup>(Z<sup>[i-1]</sup>)</li><li>公示推导的简单说明<br>对于公式1，根据矩阵求导公式d( f(X) ) = d( A·X )/dX = A<sup>T</sup>，再由矩阵相等时维度相同，可得1个样本时的偏导数为dZ<sup>[i]</sup>·A<sup>[i-1]T</sup>，如果有m个样本，则取平均值1/m。<br>对于公式3，类似公式1的求导公式得出下一层网络的输入Z<sup>[i]</sup>对上一层网络的输出A<sup>[i-1]</sup>的偏导函数为W<sup>[i]T</sup>,同样根据矩阵相等时维度必须相同可得公式3，注意后面的g<sup>[i-1]’</sup>(Z<sup>[i-1]</sup>)只不过是A<sup>[i-1]</sup>对Z<sup>[i-1]</sup>的偏导函数，因为A<sup>[i-1]</sup> = g<sup>[i-1]</sup>(Z<sup>[i-1]</sup>)。</li></ol><h3 id="三、常用激活函数导数"><a href="#三、常用激活函数导数" class="headerlink" title="三、常用激活函数导数"></a>三、常用激活函数导数</h3><ul><li>S(x) = sigmoid(X)<br> S<sup>‘</sup>(x) = S(x)·(1-S(x))</li><li>f(x) = tanh(x)<br> f<sup>‘</sup>(x) = 1-(f(x))<sup>2</sup></li><li>f(x) = ReLU(x)<br> f<sup>‘</sup>(x) = max{0,a}</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、符号说明&quot;&gt;&lt;a href=&quot;#一、符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、符号说明&quot;&gt;&lt;/a&gt;一、符号说明&lt;/h3&gt;&lt;p&gt;一个样本包含两个部分，特征x和标签y&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x&lt;br&gt;表示某一个样本的特征的集合，通常是
      
    
    </summary>
    
    
      <category term="深度学习学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://Jiahaohong.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：竞争与冒险</title>
    <link href="http://jiahaohong.github.io/2020/05/29/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%86%92%E9%99%A9/"/>
    <id>http://jiahaohong.github.io/2020/05/29/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%86%92%E9%99%A9/</id>
    <published>2020-05-29T08:35:53.000Z</published>
    <updated>2020-09-29T08:55:36.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、竞争与冒险的定义"><a href="#一、竞争与冒险的定义" class="headerlink" title="一、竞争与冒险的定义"></a>一、竞争与冒险的定义</h3><p>当一个逻辑门的两个输入变量在同一时刻发生翻转，而变化的时间有差异的现象，称为竞争。<br>由竞争产生输出干扰脉冲的现象称为冒险。</p><h3 id="二、竞争与冒险的判别"><a href="#二、竞争与冒险的判别" class="headerlink" title="二、竞争与冒险的判别"></a>二、竞争与冒险的判别</h3><p>已知一个逻辑表达式，如何判别由该逻辑表达式设计的电路会不会产生竞争与冒险？<br>首先我们需要找到在该表达式中同时出现有原变量和反变量的输入变量，然后我们将所有其他变量选择合适的值，看逻辑表达式是否能成为该输入变量的原变量和反变量的组合，若是那么就会有竞争与冒险现象。</p><h3 id="三、如何消除竞争与冒险现象"><a href="#三、如何消除竞争与冒险现象" class="headerlink" title="三、如何消除竞争与冒险现象"></a>三、如何消除竞争与冒险现象</h3><ol><li>发现并消去互补相乘项<br>如果互补项没有直接的相乘，尝试拆括号将互补项乘到一起消去。</li><li>增加乘积项避免互补项相加<br>从原表达式中增加一些不改变结果的乘积项，使得原来满足互补项相加的条件作用下，多出一些其他表达式，避免互补项相加。   </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、竞争与冒险的定义&quot;&gt;&lt;a href=&quot;#一、竞争与冒险的定义&quot; class=&quot;headerlink&quot; title=&quot;一、竞争与冒险的定义&quot;&gt;&lt;/a&gt;一、竞争与冒险的定义&lt;/h3&gt;&lt;p&gt;当一个逻辑门的两个输入变量在同一时刻发生翻转，而变化的时间有差异的现象，称为
      
    
    </summary>
    
    
      <category term="数电学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%95%B0%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数字电路" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:搭建网络步骤</title>
    <link href="http://jiahaohong.github.io/2020/05/20/Tensorflow-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E6%AD%A5%E9%AA%A4/"/>
    <id>http://jiahaohong.github.io/2020/05/20/Tensorflow-%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E6%AD%A5%E9%AA%A4/</id>
    <published>2020-05-20T01:50:21.000Z</published>
    <updated>2020-07-22T08:46:55.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、六步法"><a href="#一、六步法" class="headerlink" title="一、六步法"></a>一、六步法</h3><ol><li>import   </li><li>train,test  </li><li>model = tf.keras.models.Seque ntial  </li><li>model.compile<br>配置训练方法，比如优化器、损失函数   </li><li>model.fit  </li><li>model.summary</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、六步法&quot;&gt;&lt;a href=&quot;#一、六步法&quot; class=&quot;headerlink&quot; title=&quot;一、六步法&quot;&gt;&lt;/a&gt;一、六步法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;import   &lt;/li&gt;
&lt;li&gt;train,test  &lt;/li&gt;
&lt;li&gt;model = tf.
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:激活函数和损失函数</title>
    <link href="http://jiahaohong.github.io/2020/05/20/Tensorflow-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>http://jiahaohong.github.io/2020/05/20/Tensorflow-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-20T01:02:28.000Z</published>
    <updated>2020-05-20T03:26:45.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、激活函数"><a href="#一、激活函数" class="headerlink" title="一、激活函数"></a>一、激活函数</h3><ul><li><p>Sigmoid函数<br>tf.nn.sigmoid(x)<br>特点：<br>（1）导数不为0的范围太小，容易造成梯度消失<br>（2）输出非0均值，收敛慢<br>（3）幂运算计算复杂，训练时间长</p></li><li><p>Relu函数</p></li></ul><h3 id="二、损失函数"><a href="#二、损失函数" class="headerlink" title="二、损失函数"></a>二、损失函数</h3><ul><li>softmax</li><li>cross-entropy</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、激活函数&quot;&gt;&lt;a href=&quot;#一、激活函数&quot; class=&quot;headerlink&quot; title=&quot;一、激活函数&quot;&gt;&lt;/a&gt;一、激活函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sigmoid函数&lt;br&gt;tf.nn.sigmoid(x)&lt;br&gt;特点：&lt;br&gt;（1）导数
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:常用函数</title>
    <link href="http://jiahaohong.github.io/2020/05/19/Tensorflow-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://jiahaohong.github.io/2020/05/19/Tensorflow-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-19T01:22:16.000Z</published>
    <updated>2020-05-19T09:14:05.723Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>强制类型转换<br>tf.cast(张量名,dtype=数据类型)</p></li><li><p>计算张量维度上的最值<br>tf.reduce_min(张量名)<br>tf.reduce_max(张量名)<br>如果没有指定维度，那么默认寻找这个张量所有元素里的最值。</p></li><li><p>axis<br>用于指定函数作用的维度。比如在二维张量中(数组)，axis=0代表作用维度是列，tf.reduce_mean(a,axis=0)表示分别在张量a的所有列中找到最小值。</p></li></ul><ul><li><p>tf.Variable<br>将变量标记为“可训练”，被标记的变量会在反向传播中记录梯度信息。可用于参数初始化。</p></li><li><p>张量对应元素的四则运算<br>tf.add(a,b)<br>tf.subtract(a,b)<br>tf.multiply(a,b)<br>tf.divide(a,b)<br>张量a，b维度必须相同。</p></li><li><p>矩阵乘<br>tf.matmul(A,B)</p></li><li><p>tf.data.Dataset.from_tensor_slices<br>将特征和标签配对</p></li><li><p>tf.GradientTape</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    w = tf.Variable(tf.constant(<span class="number">3.0</span>))</span><br><span class="line">    loss = tf.pow(w,<span class="number">2</span>)</span><br><span class="line">grad = tape.gradient(loss,w)</span><br><span class="line">print(grad)</span><br></pre></td></tr></table></figure></li><li><p>tf.one_hot<br>独热编码，在分类问题中常用做标签，1表示是，0表示非。<br>tf.one_hot(代转换数据,depth=几分类)</p></li><li><p>assign_sub<br>只能作用于“可训练”变量，相当于i–。</p></li><li><p>tf.argmax<br>返回张量指定维度的最大值的索引，及最大值的位置。注意不是最大索引值。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;强制类型转换&lt;br&gt;tf.cast(张量名,dtype=数据类型)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算张量维度上的最值&lt;br&gt;tf.reduce_min(张量名)&lt;br&gt;tf.reduce_max(张量名)&lt;br&gt;如果没有指定维度，那么默认寻找这个张量
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow:Tensor</title>
    <link href="http://jiahaohong.github.io/2020/05/18/Tensorflow-Tensor/"/>
    <id>http://jiahaohong.github.io/2020/05/18/Tensorflow-Tensor/</id>
    <published>2020-05-18T14:28:09.000Z</published>
    <updated>2020-05-19T01:19:59.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p><font color="yellow">tf.int, tf.float</font><br>    tf.int32, tf.int64, tf.float32, tf.float64<br><font color="yellow">tf.bool</font><br>    tf.constant([True,False])<br><font color="yellow">tf.string</font><br>    tf.constrant(“Hello,world!”)</p><h3 id="二、张量（Tensor）"><a href="#二、张量（Tensor）" class="headerlink" title="二、张量（Tensor）"></a>二、张量（Tensor）</h3><p>向量和矩阵的高维拓展。<strong>张量可以表示n维数组。</strong></p><ul><li><p>如何创建张量？<br><font color="yellow">tf.constant(张量内容，dtype=数据类型)</font>  </p></li><li><p>如何查看张量形状（维数）？<br><font color="yellow">print(a.shape)</font><br>输出：shape=(2,)<br>输出中shape的括号里逗号隔开了几个数字，该张量就是几维，上例中张量a是一个一维数组，包含两个元素。</p></li><li><p>numpy数据类型和tensor数据类型的转换<br><font color="yellow">tf.convert_to_tensor(数据名，dtype=数据类型)</font></p></li><li><p>创建全为指定值的张量<br><font color="yellow">tf.zeros(维度)<br>tf.ones(维度)<br>tf.fill(维度，指定值)</font><br>其中，维度如果是1维就直接写元素个数，如果是二维及二维以上，用[n,m,j,k,……]表示张量形状。</p></li><li><p>生成正太分布的随机数<br><font color="yellow">tf.random.normal(维度，mean=均值，stdev=标准差)</font><br>默认mean=0，stdev=1。</p></li><li><p>生成2$delta$范围内的正太分布随机数<br><font color="yellow">tf.random.truncated_normal(维度，mean=均值，stdev=标准差)</font><br>随机数生成在均值加减2倍标准差的范围内。</p></li><li><p>生成均匀分布随机数<br><font color="yellow">tf.random.uniform(维度，minval=最小值，maxval=最大值)</font><br>随机数在[minval,maxval)的左闭右开区间上。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、数据类型&quot;&gt;&lt;a href=&quot;#一、数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型&quot;&gt;&lt;/a&gt;一、数据类型&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;yellow&quot;&gt;tf.int, tf.float&lt;/font&gt;&lt;br&gt;    tf
      
    
    </summary>
    
    
    
      <category term="Tensorflow" scheme="http://Jiahaohong.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：触发器</title>
    <link href="http://jiahaohong.github.io/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://jiahaohong.github.io/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2020-05-18T07:45:24.000Z</published>
    <updated>2020-09-29T08:55:10.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、主从D触发器"><a href="#一、主从D触发器" class="headerlink" title="一、主从D触发器"></a>一、主从D触发器</h3><p>略</p><h3 id="二、触发器逻辑功能"><a href="#二、触发器逻辑功能" class="headerlink" title="二、触发器逻辑功能"></a>二、触发器逻辑功能</h3><p>下面介绍一些常用的触发器的特性方程（Q’代表次态）。</p><ul><li>D触发器<br>Q’=D</li><li>JK触发器<br>Q’=J<span style="text-decoration:overline">Q</span>+<span style="text-decoration:overline">K</span>Q</li><li>T触发器<br>相当于JK触发器J端和K端接到一起：<br>Q’=T<span style="text-decoration:overline">Q</span>+<span style="text-decoration:overline">T</span>Q</li><li>T’触发器<br>相当于T触发器T端始终接高电平：<br>Q’=<span style="text-decoration:overline">Q</span></li><li>SR触发器<br>Q’=S+<span style="text-decoration:overline">R</span>Q<br>S·R=0</li></ul><h3 id="三、触发器的逻辑功能转换"><a href="#三、触发器的逻辑功能转换" class="headerlink" title="三、触发器的逻辑功能转换"></a>三、触发器的逻辑功能转换</h3><p>用D触发器可以实现其他所有的触发器。总体方法是：由于D触发器的特性方程和需要转换的触发器的特性方程是等价的，那么就可以由代转换的触发器特性方程推出输入端D的逻辑表达式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、主从D触发器&quot;&gt;&lt;a href=&quot;#一、主从D触发器&quot; class=&quot;headerlink&quot; title=&quot;一、主从D触发器&quot;&gt;&lt;/a&gt;一、主从D触发器&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&quot;二、触发器逻辑功能&quot;&gt;&lt;a href=&quot;#二、触发器逻辑功能&quot; 
      
    
    </summary>
    
    
      <category term="数电学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%95%B0%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数字电路" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：锁存器</title>
    <link href="http://jiahaohong.github.io/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/"/>
    <id>http://jiahaohong.github.io/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/</id>
    <published>2020-05-18T03:19:29.000Z</published>
    <updated>2020-09-29T08:55:26.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基本双稳态电路"><a href="#一、基本双稳态电路" class="headerlink" title="一、基本双稳态电路"></a>一、基本双稳态电路</h3><p>先直接给出书本上的定义：具有0、1两种逻辑状态，并且进入其中任何一种逻辑状态后均能长期保持这种状态不变的单元电路。<br>并且<strong>规定</strong>Q端输出为0的时候，该电路逻辑状态为0；Q端输出为1的时候，该电路逻辑状态为1。  </p><img src="/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/基本双稳态电路.png">   <p>那么如何分析该电路的状态呢？<br>首先假定电路的一个逻辑状态，比如为0；然后确定两输出端的逻辑电平，此时Q为0，Q非为1；接着分析反馈到输入端的逻辑电平，G1输入1，G2输入0；最后通过输入和逻辑门检查输出端的逻辑电平是否和假设一致（此例G1输出0和假设一致），如果一致，表示电路逻辑状态就是假设的逻辑状态，已经稳定了，如果不一致，需要修改假设的逻辑状态再进行一次判断，若第二次分析结果还是不一致，则说明电路进入了不确定状态。</p><h3 id="二、基本SR锁存器"><a href="#二、基本SR锁存器" class="headerlink" title="二、基本SR锁存器"></a>二、基本SR锁存器</h3><p>将基本双稳态电路的非门换成两输入或非门就构成了一种基本SR锁存器，如果换成两输入与非门就构成了另一种基本SR锁存器。   </p><ul><li><p>或非门SR锁存器<br><strong>定义Q=1为锁存器的1状态，Q=0为锁存器的0状态。</strong>  </p><img src="/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/基本SR锁存器.png">  <p>这个电路的状态如何分析？<br>总体来说和双稳态电路的分析过程差不多，但是考虑到多出来两个输入端，所以在分析锁存器的状态的时候，不仅需要假设锁存器的输出状态，还要假设锁存器的输入状态。下面给出锁存器的功能表：</p></li></ul><table><thead><tr><th align="center">S</th><th align="center">R</th><th align="center">Q</th><th align="center"><span style="text-decoration: overline">Q</span></th><th align="center">Function</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">不变</td><td align="center">不变</td><td align="center">保持</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">置0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">置1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">非定义状态（危险）</td></tr></tbody></table><p>  总结一下：S端代表SET，及设置为1状态；R端代表RESET，及重置0状态；S端和R端接收到高电平时才会发挥作用，接收到低电平时不起作用；S端和R端不能同时起作用，及送入S端和R端的信号满足S·R=0，二者不能同时为1。</p><ul><li><p>与非门锁存器<br><strong>定义Q=1为锁存器的1状态，Q=0为锁存器的0状态。</strong>  </p><img src="/2020/05/18/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%94%81%E5%AD%98%E5%99%A8/基本SR锁存器2.png">  <p>与非门锁存器和或非门锁存器送入输入端的信号是互补的，其他一摸一样。可以理解为在或非门两个输入端外分别连接一个非门。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基本双稳态电路&quot;&gt;&lt;a href=&quot;#一、基本双稳态电路&quot; class=&quot;headerlink&quot; title=&quot;一、基本双稳态电路&quot;&gt;&lt;/a&gt;一、基本双稳态电路&lt;/h3&gt;&lt;p&gt;先直接给出书本上的定义：具有0、1两种逻辑状态，并且进入其中任何一种逻辑状态后均能长
      
    
    </summary>
    
    
      <category term="数电学习笔记" scheme="http://Jiahaohong.github.io/categories/%E6%95%B0%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数字电路" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据库：什么是范式？（下）</title>
    <link href="http://jiahaohong.github.io/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://jiahaohong.github.io/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-26T08:02:04.000Z</published>
    <updated>2020-08-27T06:46:25.335Z</updated>
    
    <content type="html"><![CDATA[<p><em>范式的规定随着序号的增加而逐渐严格，序号大的范式一定满足序号小的范式的要求</em></p><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><em><strong>属性不可分</strong></em><br>这是最简单也是最基础的范式，<strong>所有关系模型</strong>必须满足这个范式。这个定义已经十分清晰明了了，即在实际情况中，我们选取的关系模型的属性必须具有原子性，不可分性，但是同时又不必过于细致，能够满足实际应用要求即可。</p><p><em>接下来的范式定义就逐渐晦涩难懂了，我会采用实际例子来辅助理解</em></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p><em><strong>所有非主属性完全依赖于任意一个键码</strong></em><br>在这里我们要重点关注一个词：完全。什么样的依赖从才能说是完全依赖呢？我们看看下面这个图书馆借书登记的例子。  </p><table><thead><tr><th align="center">Name</th><th align="center">Title</th><th align="center">Date</th><th align="center">Domitory</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Pride And Prejudice</td><td align="center">2020/3/26</td><td align="center">Domitory A</td></tr><tr><td align="center">Lucy</td><td align="center">Jane Eyre</td><td align="center">2020/1/18</td><td align="center">Domitory B</td></tr></tbody></table><p>在这个借书信息关系表中，我们可以<strong>通过生活实际</strong>得出如下的函数依赖关系：Name Title-&gt;Date和Name-&gt;Domitory。通过<strong>闭包</strong>，我们可以求出关系表的键码为{Name，Title}，Date这个属性是通过这个键码确定的，但是Domitory这个属性是通过这个<strong>键码的子集</strong>{Name}确定的，因此这个关系表不符合第二范式。<br>这时候只要选择一个函数依赖分离出一个新的关系表就可以解决这个问题。比如选择函数依赖Name-&gt;Domitory分离出第一个表：  </p><table><thead><tr><th align="center">Name</th><th align="center">Domitory</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Domitory A</td></tr><tr><td align="center">Lucy</td><td align="center">Domitory B</td></tr></tbody></table><p><strong>剩下的属性集</strong>作为第二个表：  </p><table><thead><tr><th align="center">Name</th><th align="center">Title</th><th align="center">Date</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Pride And Prejudice</td><td align="center">2020/3/26</td></tr><tr><td align="center">Lucy</td><td align="center">Jane Eyre</td><td align="center">2020/1/18</td></tr></tbody></table><p>这样两个表就都符合第二范式了。当然，实际问题可能更加复杂，比如上面第二个表分离出来后还是不符合第二范式，那么就要根据别的函数依赖继续分离第二个表。</p><p>需要注意的是，第二范式并不要求非主属性直接依赖于同一个键码，但是非主属性一定能够通过某种函数传递而依赖于同一个键码。看上去挺绕的是不是？我们来看一个例子：  </p><table><thead><tr><th align="center">Name</th><th align="center">Domitory</th><th align="center">DomitoryManagement</th></tr></thead><tbody><tr><td align="center">Darcy</td><td align="center">Domitory A</td><td align="center">Uncle Ben</td></tr><tr><td align="center">Lucy</td><td align="center">Domitory B</td><td align="center">Aunt Jenny</td></tr></tbody></table><p>在这个关系表中，DomitoryManagement不直接依赖于键码{Name}，但是它依赖于Domitory，并且Domitory依赖于键码{Name}，这是一个传递依赖，所以符合第二范式。这一点是区分第二范式和第三范式的关键，因为第三范式要求不能有传递依赖。</p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><em><strong>如果对于关系R中的任何非平凡依赖A1A2…An-&gt;B，它们满 足条件：或者A1A2…An是超键码，或者B是某个键码的组成部分，则关系R满足第三范式</strong></em></p><h2 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;范式的规定随着序号的增加而逐渐严格，序号大的范式一定满足序号小的范式的要求&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一范式&quot;&gt;&lt;a href=&quot;#第一范式&quot; class=&quot;headerlink&quot; title=&quot;第一范式&quot;&gt;&lt;/a&gt;第一范式&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;str
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：什么是范式（上）？</title>
    <link href="http://jiahaohong.github.io/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://jiahaohong.github.io/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-03-24T13:00:35.000Z</published>
    <updated>2020-03-30T06:11:51.682Z</updated>
    
    <content type="html"><![CDATA[<p>在细致讨论关系数据库的范式之前，我们要理解几个重要概念。</p><h2 id="关系的键码"><a href="#关系的键码" class="headerlink" title="关系的键码"></a>关系的键码</h2><h3 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h3><p>一个关系表的键码满足如下条件：</p><ol><li>键码是该关系表中的一个<strong>属性</strong>或<strong>多个属性的集合</strong></li><li>由给定的键码可以确定该关系的所有属性</li><li>键码的任何<strong>真子集</strong>都不能确定该关系的所有属性</li></ol><p>看上去有点绕？没关系，看看下面的栗子就明白了。</p><blockquote><p>1号栗子</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Gender</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">18</td></tr><tr><td align="center">002</td><td align="center">Jessica</td><td align="center">Female</td><td align="center">18</td></tr><tr><td align="center">003</td><td align="center">Lucy</td><td align="center">Female</td><td align="center">17</td></tr><tr><td align="center">004</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">17</td></tr></tbody></table><p>1号栗子中有四个属性，如果你只知道后面三个属性中的任何一个的内容，你都无法确定这个属性是谁的。比如告诉你这个人18岁，问他叫什么名字？再比如告诉你这个人叫Darcy，问他几岁？<br>同样的，如果你知道后面三个属性中的任何两个，你也是无法确定这个人的其他信息的。比如告诉你这个人叫Darcy，Male，问你他几岁？<br>但是如果你同时知道后面这三个属性的内容，那么你就可以在这个表中唯一确定一个人了！比如告诉你这个人叫Darcy，性别Male，年龄17，那么查表你就知道这个人是004号而不是001号。那么这三个属性就可以作为这个表的键码，写成这样{Name，Gender，Age}。<br>聪明的你发现，直接告诉我一个人的ID不就好了？的确如此，ID属性也是这个表的一个键码，这也说明一个关系表中的键码可以有多个，而且每个键码的优劣也有区别，这里不做讨论。</p></blockquote><p>综上所述，一个关系表的键码其实没有多神秘，它也是属性（属性集），只不过它比较特别，它可以帮你找到这个表中的其他属性。而且这样热心的属性（属性集）在一个表中可能会有多个。</p><h3 id="超键码"><a href="#超键码" class="headerlink" title="超键码"></a>超键码</h3><p>一个表中的键码加上其他0个或多个非键码属性构成的属性集合就是超键码。</p><blockquote><p>还是1号栗子<br>如果该表的键码{ID}加上Age属性，那么新的属性集合{ID，Age}就构成了一个超键码。</p></blockquote><p>注意咯，键码一定是超键码，但是超键码不一定是键码。</p><h3 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h3><p>如果一个属性是任意键码的子集，那么这个属性是主属性。<br>如果一个属性不是任何键码的子集，那么这个属性是非主属性。</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="什么是函数依赖？"><a href="#什么是函数依赖？" class="headerlink" title="什么是函数依赖？"></a>什么是函数依赖？</h3><p>简单理解为：如果已知属性A1和属性A2就一定可以推出属性B，那么称函数A1，A2决定B，并且记作A1A2-&gt;B。其中属性A1和A2可以更多。<br><del>数学理解为：一个函数依赖（函数）将定义属性集（定义域）映射到值属性集（值域）。这是我瞎写的。</del></p><blockquote><p>下面再次有请我们的1号栗子</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Gender</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">18</td></tr><tr><td align="center">002</td><td align="center">Jessica</td><td align="center">Female</td><td align="center">18</td></tr><tr><td align="center">003</td><td align="center">Lucy</td><td align="center">Female</td><td align="center">17</td></tr><tr><td align="center">004</td><td align="center">Darcy</td><td align="center">Male</td><td align="center">17</td></tr></tbody></table><p>由键码的分析可以看到，从属性集ID可以推知属性集Name、Gender、Age，那么这就构成了一个函数依赖，写为ID-&gt;Name Gender Age。</p></blockquote><h3 id="函数依赖的分类"><a href="#函数依赖的分类" class="headerlink" title="函数依赖的分类"></a>函数依赖的分类</h3><p>下面将函数依赖简记为{A}-&gt;{B}，其中{A}和{B}都是属性集。</p><ul><li>平凡依赖<br>B是A的子集。<br><del>这个函数依赖很差劲，它不能告诉我们任何它没有的信息。</del></li><li>非平凡依赖<br>B不是A的子集，但B和A的交集不为空。<br><del>这个函数依赖还是有点用的，至少告诉了我们一些其他信息。</del></li><li>完全非平凡依赖<br>B和A的交集为空<br><del>Amazing！这个函数依赖告诉了我们全新的东西！</del></li></ul><h3 id="函数依赖的运算规则"><a href="#函数依赖的运算规则" class="headerlink" title="函数依赖的运算规则"></a>函数依赖的运算规则</h3><ul><li>分解规则<br>A1A2…An-&gt;B1B2…Bm等价于A1A2…An-&gt;Bi(i=1,2,…,m),即将一个函数依赖分解成为一组函数依赖。</li><li>合并规则<br>A1A2…An-&gt;Bi(i=1,2,…,m)等价于A1A2…An-&gt;B1B2…Bm，即将一组函数依赖合成为一个函数依赖，是分解规则的逆运算。</li><li>平凡依赖规则<br>A1A2…An-&gt;B1B2…Bm等价于A1A2…An-&gt;C1C2…Ck，其中C属于B但不属于A，即将B中和A相同的属性去掉，剩下的属性构成新的集合C还是满足原来的函数依赖。</li><li>增长规则<br>如果A1A2…An-&gt;B1B2…Bm，则对于任何属性集 C1C2…Ck，A1A2…An C1C2…Ck-&gt;B1B2…Bm C1C2…Ck,即平凡依赖规则的逆运算。</li><li>传递规则<br>若函数依赖A-&gt;B和B-&gt;C在关系R中成立,则函数依赖A-&gt;C在关系R中也成立.</li></ul><h2 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>准确的定义：首先我们有一个属性集A{A1，A2，···，An}，然后我们又有了一个函数依赖集S{S1，S2，···，Sn}，至此我们就能够通过函数依赖集中的函数依赖，确定属性集A能够决定的属性集B，称为属性集A的闭包，并记为{A1，A2，···，An}+。<br>通过上述闭包的定义，我们知道要确定一个闭包必须知道两个缺一不可的信息，一是原来的属性集，二是给定的函数依赖集。如果属性集改变，或者函数依赖集改变，都会改变闭包最终包含的属性。<br><del>数学的定义：给定一系列函数Si，将定义域A映射到值域Bi，那么Bi的集合就是定义域A的闭包。</del></p><h3 id="闭包的计算"><a href="#闭包的计算" class="headerlink" title="闭包的计算"></a>闭包的计算</h3><blockquote><p>2号栗子登场<br>给定属性集{A，B，C}和函数依赖集{AB-&gt;D，C-&gt;E}，求{A，B，C}+？<br>计算方法：选取一个函数依赖，作用于属性集上，去掉这个函数依赖，并将原来的属性集更新为新的属性集，再次选取一个函数依赖，重复此步骤，直到函数依赖集为空或者余下的所有函数依赖都无法作用于当前属性集，那么当前的属性集就是原属性集的闭包。<br>X = {A，B，C}<br>选AB-&gt;D作用于X<br>X = {A，B，C，D}<br>选C-&gt;E作用于X<br>X = {A，B，C，D，E}<br>此时函数依赖集为空，得到闭包{A，B，C，D，E}</p></blockquote><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul><li>检验一个属性集是否为关系的键码</li><li>检验一个函数依赖是否蕴含于函数依赖集</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在细致讨论关系数据库的范式之前，我们要理解几个重要概念。&lt;/p&gt;
&lt;h2 id=&quot;关系的键码&quot;&gt;&lt;a href=&quot;#关系的键码&quot; class=&quot;headerlink&quot; title=&quot;关系的键码&quot;&gt;&lt;/a&gt;关系的键码&lt;/h2&gt;&lt;h3 id=&quot;键码&quot;&gt;&lt;a href=&quot;#键码&quot;
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库：E-R图</title>
    <link href="http://jiahaohong.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AE-R%E5%9B%BE/"/>
    <id>http://jiahaohong.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AE-R%E5%9B%BE/</id>
    <published>2020-03-12T12:11:32.000Z</published>
    <updated>2020-03-12T13:29:17.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ER图三要素"><a href="#ER图三要素" class="headerlink" title="ER图三要素"></a>ER图三要素</h2><ul><li>实体集<br>具有相同特性的同一类事物的集合，矩形表示。</li><li>属性<br>描述实体摸个特性的值，椭圆形表示。</li><li>联系<br>两个或多个实体集之间的联系，菱形表示。</li></ul><h2 id="联系的多重性"><a href="#联系的多重性" class="headerlink" title="联系的多重性"></a>联系的多重性</h2><ul><li>一对一联系，双边箭头。</li><li>一对多联系，从一指向多的箭头。</li><li>多对多联系，不加箭头。  <h3 id="如何判断两个实体集之间的联系的多重性？"><a href="#如何判断两个实体集之间的联系的多重性？" class="headerlink" title="如何判断两个实体集之间的联系的多重性？"></a>如何判断两个实体集之间的联系的多重性？</h3>如果从某个实体集A中的一个实体a出发，经过一个联系，只有另一个实体集B中唯一的一个实体b与之对应，则从A经过联系指向实体集B的连线应该加箭头。</li></ul><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>ER图中的联系可以涉及多个实体，这是ODL中所不具备的。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>键码<br>在实体集中，唯一标识一个实体的属性或属性集。用下划线表示某些属性或属性集构成了键码。注意，键码本质上也是属性。</li><li>参照完整性约束  <ol><li>必须是多对一或一对一联系。</li><li>R是从实体集E到实体集F的联系，如果若E中的一个实体e存在，那么与之对应的实体f必须存在。</li></ol></li></ul><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>如果实体集C具有实体集D的全部属性和联系，并且还拥有一些其他的属性，那么称实体集C是实体集D的子类。用等腰三角形链接超类（可以理解为父类）和子类，顶点指向超类。</p><h3 id="ODL子类和ER图子类的区别"><a href="#ODL子类和ER图子类的区别" class="headerlink" title="ODL子类和ER图子类的区别"></a>ODL子类和ER图子类的区别</h3><ul><li>ODL的子类必须是同一个类的部分成员。</li><li>ER图的实体可以属于多个实体集。</li><li>ODL子类类似Java，ER图子类类似C++。</li></ul><h2 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h2><p>如果实体集C的<strong>键码</strong>中的一些或全部属于实体集D，那么实体集C为实体集D的弱实体集。用双边矩形表示弱实体集，用双边菱形表示实体集C和D的联系。</p><h3 id="如何理解弱实体集"><a href="#如何理解弱实体集" class="headerlink" title="如何理解弱实体集"></a>如何理解弱实体集</h3><ul><li>层次结构<br>在现实世界中的弱实体集E依赖于提供给他键码的实体集F，没有实体集F，就不能确定实体集E。</li><li>连接实体集</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ER图三要素&quot;&gt;&lt;a href=&quot;#ER图三要素&quot; class=&quot;headerlink&quot; title=&quot;ER图三要素&quot;&gt;&lt;/a&gt;ER图三要素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实体集&lt;br&gt;具有相同特性的同一类事物的集合，矩形表示。&lt;/li&gt;
&lt;li&gt;属性&lt;br&gt;描述实体
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://Jiahaohong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
