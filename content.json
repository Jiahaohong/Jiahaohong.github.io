{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Darcy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"数字电路：数据分配器","slug":"数字电路：数据分配器","date":"2020-02-14T02:07:15.000Z","updated":"2020-02-14T03:47:16.631Z","comments":true,"path":"2020/02/14/数字电路：数据分配器/","link":"","permalink":"http://yoursite.com/2020/02/14/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%99%A8/","excerpt":"","text":"什么是数据分配器 将公共输入信号分配到不同通道上的逻辑电路。 用译码器实现数据分配器 现在之前说到过的译码器多使能端派上用场了。 先简单说说使能端E2和E1的特性，当总使能端E3有效时（高电平），E2和E1中任何一个接收到无效信号（低电平）都会使所有输出端输出无效信号（低电平）。 再来看看各输出端的逻辑函数：Y5 = E3 · E2 · E1 · A3 · A2 · A1 = E3 · E2 · E1 · m5 其余端口由5号端口同理得出，通式如下：Yi = E3 · E2 · E1 · mi 现在设计使能端。将总使能端E3保持有效，E2也保持有效，E1通入要分配的信号D。那么，当信号D为高电平时，E1有效，有且仅有mi所对应的那一路输出端输出高电平（其余输出端为低电平，参看译码器真值表）；当信号D为低电平时，E1无效，所有输出端输出低电平，包括mi所对应的那一路输出端。这样就保证了mi对应的那一路输出端高低电平与输入信号D保持一致，而其他输出端一直为低电平。 两个译码器可以组成更多路输出的译码器，这种组合译码器用上述方法也同样可以做成更多路的数据分配器。 用逻辑门实现数据分配器 先来介绍三态门。三态门有一个输入端，一个输出端，和一个使能端，当使能端有效时，三态门输出和输入相同；当使能端无效时，三态门输出为高阻态。","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：译码器","slug":"数字电路：译码器","date":"2020-02-13T01:50:37.000Z","updated":"2020-02-14T03:10:49.938Z","comments":true,"path":"2020/02/13/数字电路：译码器/","link":"","permalink":"http://yoursite.com/2020/02/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%AF%91%E7%A0%81%E5%99%A8/","excerpt":"","text":"译码器的原理 2线-4线译码器 先看看这种译码器的真值表： E A1 A0 Y0 Y1 Y2 Y3 0 X X 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 1 0 0 1 1 0 0 0 1 0 1 1 1 0 0 0 1 在使能端有效的情况下，我们可以写出各个输出端的逻辑表达式，如下： Y0 = A1 · A0 Y1 = A1 · A0 Y2 = A1 · A0 Y3 = A1 · A0 不难发现，每个输出端的逻辑表达式都是输入逻辑变量的最小项。如果将使能端也考虑进去，将上述每一个输出端的逻辑表达式和使能端逻辑变量相与即可。 3线-4线译码器 先看看这种译码器的使能端的真值表： E3 E2 E1 A3 A2 A1 Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 0 X X X X X 0 0 0 0 0 0 0 0 1 0 X X X X 0 0 0 0 0 0 0 0 1 X 0 X X X 0 0 0 0 0 0 0 0 可以看出，这三个使能端中E3优先级最高，是总开关，E2和E1的功能是一样的，但是怎么用呢？ 几个问题 为什么2线-4线译码器74HC139的逻辑符号中，使能端和输出端要各自连接一个非门？ 为什么3线-8线译码器74HC138需要三个使能端？ 如何使用74HC138和少量逻辑门实现三变量逻辑函数？ 关于译码器连接非门的问题 虽然说逻辑函数可以使用与或非三种逻辑门来实现，但是，通常情况下这些逻辑门都不是结构上最简单的。实际上与非门的结构最为简单，并且可以由与非门完成其他基本逻辑们的功能。因此，逻辑电路可能会有一些非门在输入输出端。 关于译码器的多使能端的问题 多个使能端可以拓展译码器的功能，比如之后的数据分配器和数据选择器等。","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：编码器","slug":"数字电路：编码器","date":"2020-02-11T08:20:07.000Z","updated":"2020-02-11T09:25:04.922Z","comments":true,"path":"2020/02/11/数字电路：编码器/","link":"","permalink":"http://yoursite.com/2020/02/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%BC%96%E7%A0%81%E5%99%A8/","excerpt":"","text":"什么是编码，什么是编码器 编码就是赋予二进制代码特殊含义的过程。 编码器就是实现编码功能的逻辑电路。 普通编码器 任何时候只允许一个信号输入的编码器称为普通编码器。 下面看看普通编码器的真值表： I0 I1 I2 I3 Y0 Y1 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 1 1 1 普通编码器的逻辑表达式如下（通过卡诺图得出，如果你从真值表看出更厉害）： Y0 = I2 + I3 Y1 = I1 + I3 结合真值表和逻辑表达式可知，普通编码器只有在有且仅有一个输入有效时才能正常工作，否则将会出现编码重叠的问题。比如，0101的输入信号会产生11的输出，这样的话编码器之后的电路就会将0101误认为0001。 优先编码器 事先规定好信号的优先级的编码器称为优先编码器。 下面看看优先级编码器的真值表： I0 I1 I2 I3 Y0 Y1 1 0 0 0 0 0 x 1 0 0 0 1 x x 1 0 1 0 x x x 1 1 1 你能看出这个编码器输入信号的优先级吗？ 同样的，分别根据Y0和Y1的卡诺图可以求出它们的逻辑表达式，如下： Y0 = I2 + I3 Y1 = I1 · I2 + I3","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：卡诺图（2）","slug":"数字电路：卡诺图（2）","date":"2020-02-09T08:53:34.000Z","updated":"2020-02-11T03:55:58.894Z","comments":true,"path":"2020/02/09/数字电路：卡诺图（2）/","link":"","permalink":"http://yoursite.com/2020/02/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%882%EF%BC%89/","excerpt":"","text":"由上篇blog知道，卡诺图是一个将最小项按二维格雷码的形式排布的表格，每个格子对应着一个最小项，那么卡诺图怎么使用呢？ 什么是逻辑函数的卡诺图 逻辑函数的卡诺图每一个格子不仅对应着一个最小项了，若该格子为1，表示这个格子对应的最小项在逻辑函数中出现，反之若该格子为0，表示该格子对应的最小项在逻辑函数中没有出现。将逻辑函数的每一个最小项对应填到同变量数的卡诺图中，这个卡诺图就是该逻辑函数的卡诺图。 如何获得逻辑函数的卡诺图 首先将逻辑函数化成与或表达式，然后通过重叠律（A+A=1）将表达式中每一个乘积项（与项）增补成最小项，然后画出卡诺图，最后在卡诺图中找到逻辑函数每一个最小项对应的格子，将改格子写为1，其余格子全写0。 逻辑函数的卡诺图如何化简 先看看哪里数字1多，然后画圈圈把他们围住，注意，这些圈圈不能随便画，有以下几点原则: 圈圈中包围的数字1的个数必须为2的整数幂，即1、2、4、8个等等。 圈圈中包围的数字只能是1，且圈圈围住的方格组合起来必须是矩形，即1x1、1x2、2x2、2x4的大小等等。 圈圈个数尽可能少（因为每个圈圈最后就是一个乘积项，圈圈越少结果越简单），每个圈圈包围的数字1尽可能多。 不同的圈圈可以重复包围同一个数字1（这一点初学容易忽视）。 如果一个圈圈中所有的数字1都已经被其他圈圈围住了，那么这个圈圈就是多余的，可以省去（这一点消除竞争与冒险时会反过来利用）。 现在圈圈画完了，开始整理，将每一个圈圈所对应的乘积项写出来（即圈圈中所有最小项相“与”），然后将这些乘积项全部“或”起来，就是化简后的表达式了。","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：卡诺图（1）","slug":"数字电路：卡诺图（1）","date":"2020-02-08T02:49:33.000Z","updated":"2020-02-11T02:53:02.773Z","comments":true,"path":"2020/02/08/数字电路：卡诺图（1）/","link":"","permalink":"http://yoursite.com/2020/02/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%8D%A1%E8%AF%BA%E5%9B%BE%EF%BC%881%EF%BC%89/","excerpt":"","text":"什么是卡诺图 相邻最小项若两个最小项之间仅有一个逻辑变量互为反变量，那么这两个最小项为相邻最小项。例如：m2（A·B·C）与m6（A·B·C）仅有逻辑变量A不同，因此m2与m6互为相邻最小项。 卡诺图由一个个小方格组成，每个小方格代表一种最小项。几何位置上相邻的格子代表相邻最小项。 如何构造卡诺图 这里将构造卡诺图只是将卡诺图的形式构造出来，只表示最小项之间的几何位置关系，与之后要讲的“逻辑函数的卡诺图”有区别。 其实卡诺图没有固定的画法，比如两变量的卡诺图可以画成一行，也可以画成两行两列，但为了方便，之后的卡诺图都是如下画法。 展开折叠法 先记住两变量卡诺图，假设两逻辑变量分别为C和D，列号从左至右依次为00、01、11、10，最小项就是列号； 将两变量卡诺图沿着水平线对称翻折到下方，变成两行，第一行对应第三个逻辑变量B的反变量，行号为0，第二行对应第三个逻辑变量B的原变量，行号为1； 同理，将三变量卡诺图沿着水平线对称翻折到下方，变成四行，一二行对应第四个逻辑变量A的反变量，行号依次为00和01，三四行对应第四个逻辑变量A的原变量，行号依次为11和10。 卡诺图的特点 由上述卡诺图的构造方法，可以将卡诺图理解成二维的格雷码，因为他们的构造方法十分相似，只是格雷码只能在一个方向上反复对称翻折构造，而卡诺图可以在两个方向上对称翻折构造。 基于1的理解，不难发现卡诺图的两个维度标号都是格雷码，但是这里的格雷码的0和1有着明确的含义，即逻辑变量的反变量和原变量。这样就可以轻松的画出卡诺图，也可以由卡诺图轻松的获得每一个各自对应的最小项（自行理解）。 如果将最小项的标号（格雷码）转换成二进制码，可以发现这些二进制码按照从小到大的顺序S行排列，即从左上角开始，第一行从左向右递增，第二行从右向左递增，以此类推。这为从真值表到卡诺图的转换提供了方便（自行理解）。 卡诺图最左边的格子和最右边的格子、最下面的格子和最上面的格子也是几何相邻的格子。","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：逻辑代数基本定理","slug":"数字电路：逻辑代数基本定理","date":"2020-02-07T02:48:54.000Z","updated":"2020-02-08T07:59:52.694Z","comments":true,"path":"2020/02/07/数字电路：逻辑代数基本定理/","link":"","permalink":"http://yoursite.com/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/","excerpt":"","text":"逻辑代数基本定律 0、1律 重叠律 互补律 还原律 交换律 结合律 分配律 A·（B + C）= A · B + A · C A + B · C = （A + B）·（A + C） 反演律（摩根定理） A·B·C = A + B + C A+B+C = A · B · C 逻辑代数基本公式 吸收律 A + A·B = A A（A + B） = A 逻辑代数基本规则 带入规则 反演规则如果将表达式中与（·）换成或（+）、或（+）换成与（·）、反变量换成原变量、原变量换成反变量、1换成0、0换成1，那么得到的表达式即使原表达式的反演表达式。注意不要改变运算顺序，适当使用小括号保证原表达式的运算顺序。 对偶规则","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：最小项最大项","slug":"数字电路：最小项最大项","date":"2020-02-07T01:35:48.000Z","updated":"2020-02-08T03:33:00.781Z","comments":true,"path":"2020/02/07/数字电路：最小项最大项/","link":"","permalink":"http://yoursite.com/2020/02/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%A1%B9%E6%9C%80%E5%A4%A7%E9%A1%B9/","excerpt":"","text":"最小项 什么是最小项？ 现在有N个逻辑变量，若一个乘积项（与项）包含了这N个变量的原变量或非变量，且每种变量只以原变量或非变量的形式出现一次，那么该乘积项称为最小项。例如三个逻辑变量的最小项有如下8种:A·B·C、A·B·C、A·B·C、A·B·CA·B·C、A·B·C、A·B·C、A·B·C 可以看出，每个最小项中，A、B、C分别只出现一次，要么是原变量（A、B、C），要么是反变量（A、B、C）。 为什么叫最小项？ 从概率论的角度看，如果每一个逻辑变量代表一个事件，事件发生和不发生的概率都是0.5，那么所有事件的交集（与运算）的发生概率最小，所以叫最小项。 也可以将最小项看成是组成其他事件的基本单位，通过最小项的合并（或运算）来实现其他事件。 最小项如何编号？ 简单的来说，原变量用1表示，反变量用0表示，然后组合起来转换成十进制就是对应最小项的编号。如下表： A B C 编号 A B C 编号 0 0 0 m0 1 0 0 m4 0 0 1 m1 1 0 1 m5 0 1 0 m2 1 1 0 m6 0 1 1 m3 1 1 1 m7 为什么这样编号？因为当与运算中任意一个因子为0时，与运算结果为0，因子取值不具有唯一性；当且仅当与运算中所有因子为1时，与运算结果为1，因子取值具有唯一性。因此当原变量取1反变量取0时，最小项表达式所有因子为1，最小项表达式结果为1。 什么是最小项表达式？ 基本表达式中与或表达式的一种标准形式，各逻辑变量之间先进行与运算形成最小项，然后各最小项之间进行或运算形成最小项表达式。 如何获得最小项表达式？ 常用配项法获得。利用逻辑表达式基本定律（A+A=1）增加各项中的逻辑变量。 最大项最大项与最小项互补，大家自行脑补:)","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：码制","slug":"数字电路：码制","date":"2020-02-04T07:35:22.000Z","updated":"2020-02-05T08:46:10.785Z","comments":true,"path":"2020/02/04/数字电路：码制/","link":"","permalink":"http://yoursite.com/2020/02/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E7%A0%81%E5%88%B6/","excerpt":"","text":"码制概念码制是用0和1组成的代码表示人类交流的字符的规则。 格雷码 特点：循环码、反射码 格雷码与二进制码的转换二进制码转换为格雷码 格雷码最高位（最左边）与二进制码最高位相同 二进制码从左到右，相邻两位相加，作为格雷码的下一位 格雷码转换为二进制码 二进制码的最高位（最左边）与格雷码相同 将产生的二进制码与下一位格雷码相加，作为下一位二进制码","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路：补码","slug":"数字电路：补码","date":"2020-02-03T07:09:40.000Z","updated":"2020-02-03T14:12:00.611Z","comments":true,"path":"2020/02/03/数字电路：补码/","link":"","permalink":"http://yoursite.com/2020/02/03/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E8%A1%A5%E7%A0%81/","excerpt":"","text":"真值补码对应表以8bit数为例 真值-无符号 补码 真值-有符号 补码 0 0000 0000 0 0000 0000 1 0000 0001 1 0000 0001 … … … … 127 0111 1111 127 0111 1111 128 1000 0000 -128 1000 0000 129 1000 0001 -127 1000 0001 … … … … 255 1111 1111 -1 1111 1111 小结 可以看出，负数与其绝对值的真值和为0，但是补码和为 1 0000 0000，由于只能存储8bit，故多出的第8号位上的1舍去，余下的0到7号位均为0，对应真值也就是0了。 为什么-1规定为1111 1111呢？由数学同余概念可知，255对256余-1，所以-1对应255，同理可得其他负数。这样一来，一个数减去1就可以用这个数加上255来表示，只不过计算结果多出的第8位会舍去，剩下的0到7号位表示的就是减法的结果。","categories":[],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Python语法（一）","slug":"Python语法（一）","date":"2020-01-31T08:37:28.000Z","updated":"2020-02-04T03:12:11.812Z","comments":true,"path":"2020/01/31/Python语法（一）/","link":"","permalink":"http://yoursite.com/2020/01/31/Python%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"基本数据类型整数 范围：无穷 表示：十进制、二进制(0b)、十六进制(0x)、八进制(0o) 常用函数：pow(x,y) 函数作用：计算x的y次幂，y为任意整数或浮点数 浮点数 范围：近似无穷（有不确定尾数） 表示：小数点、科学计数法 常用函数：round(x[,y]) 函数作用：对x四舍五入，y为截取的小数位数，若省去y则对x取整 应用场景：判断两个浮点数是否相等 复数 范围：无穷（数字类型中级别最高，范围最广） 字符串 表示：单引号或双引号括起来的多个字符，对应即可 操作符： +：将两个字符串连接 *：将一个字符串复制n次 操作： str.split(x)：将字符串以x为分隔符分割成列表 x.join(str)：将字符串str的每一个字符后面插入字符串x，str最后一个字符后面不插入 组合数据类型集合 定义：s = set(…)或s = {…} 注意：要生成空集合只能使用set方法，空大括号默认生成空字典 操作符： A|B：并 A-B：差 A&amp;B：交 A^B：补 关系操作符 应用场景：数据去重 序列 定义：具有先后关系的一组元素 衍生：字符串、元组、列表 字符串：str = ‘abc’ 元组：t = (…)或t = tuple(…) 列表：lt = […]或lt = list[…] 字典 映射是一种键（索引/属性）和值（数据）的对应 定义：d = {…}或d = dict(…)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-30T23:45:56.429Z","updated":"2020-01-30T23:45:56.429Z","comments":true,"path":"2020/01/31/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}